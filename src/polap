#!/usr/bin/env bash
################################################################################
# This file is part of polap.
#
# polap is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# polap is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# polap. If not, see <https://www.gnu.org/licenses/>.
################################################################################

# Created by argbash-init v2.10.0
# DEFINE_SCRIPT_DIR([])
# INCLUDE_PARSING_CODE([polap-parsing.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}
. "$script_dir/polap-parsing.sh" # '.' means 'source'

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# vvv  PLACE YOUR CODE HERE  vvv

################################################################################
# include bash shell files
################################################################################

source "$script_dir/polap-constants.sh"
source "$script_dir/run-polap-function-utilities.sh"
source "$script_dir/run-polap-function-menus.sh"
source "$script_dir/run-polap-function-reset.sh"
source "$script_dir/polap-function-set-variables.sh"
source "$script_dir/run-polap-function-wga.sh"
source "$script_dir/run-polap-function-blast-genome.sh"
source "$script_dir/run-polap-function-count-gene.sh"
source "$script_dir/run-polap-function-annotate.sh"

# Template
source "$script_dir/run-polap-function-template.sh"

# NCBI: BioProject, NCBI
source "$script_dir/run-polap-function-get-bioproject.sh"
source "$script_dir/run-polap-function-get-mtdna.sh"
source "$script_dir/run-polap-function-compare-mtdna.sh" # FIXME: not tested yet.

# BioProject
source "$script_dir/run-polap-function-assemble-bioproject.sh"
source "$script_dir/run-polap-function-get-bioproject-sra.sh"
source "$script_dir/run-polap-function-copy-sra-bioproject.sh"

# contig selection
source "$script_dir/run-polap-function-select-contigs.sh"
source "$script_dir/run-polap-function-assemble-draft.sh"
source "$script_dir/run-polap-function-select-contigs-by.sh"

# read selection

# mtDNA or ptDNA selection
source "$script_dir/run-polap-function-select-mtdna.sh"

# mtDNA annotation and plotting
source "$script_dir/run-polap-function-blast-mtdna.sh"
source "$script_dir/run-polap-function-plot-mtdna.sh"

# report, archive, and cleanup
source "$script_dir/run-polap-function-report-assembly.sh"
source "$script_dir/run-polap-function-archive.sh"
source "$script_dir/run-polap-function-cleanup.sh"

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_select-reads() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		INUM=0
		JNUM=1
	elif [ $# -eq 1 ]; then
		INUM=0
		JNUM=$1
	elif [ $# -eq 2 ]; then
		INUM=$1
		JNUM=$2
	fi

	_run_polap_select-reads

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects reads mapped on a genome assembly.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTSEEDSDIR
#   $MTDIR/contig.fa
#   $MTDIR/contig_total_length.txt
#   $MTDIR/contig.paf
#   $MTDIR/contig.tab
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/1.fq.gz
#   $MTSEEDSDIR/2.fq.gz
################################################################################
function _run_polap_select-reads() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	# Set verbosity level: stderr if verbose >= 2, otherwise discard output
	local _polap_output_dest="/dev/null"
	[ "${_arg_verbose}" -ge "${_polap_var_function_verbose}" ] && _polap_output_dest="/dev/stderr"

	LRNK="$ODIR/nk.fq.gz"
	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	ADIR="$FDIR"/50-annotation
	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	MTCONTIGNAME="$FDIR"/mt.contig.name-$JNUM

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta

	help_message=$(
		cat <<HEREDOC
# Selects reads mapped on a genome assembly.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/2.fq.gz
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>] [-r|--pair-min <arg>] [-x|--bridge-min <arg>] [-w|--single-min <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTCONTIGNAME" ]; then
		echoall "ERROR: no such mt.contig.name file: $MTCONTIGNAME"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${assembly_graph_final_fasta}" ]; then
		echoall "ERROR: no assembly fasta file: ${assembly_graph_final_fasta}"
		exit $EXIT_ERROR
	fi

	if [ -d "$MTDIR" ] && [ "${_arg_yes}" = "off" ]; then
		while true; do
			read -r -p "Folder [$MTDIR] already exists. Do you want to replace it? [y/n] " yn
			case $yn in
			[Yy]*)
				rm -rf "$MTDIR"
				echo "INFO: $MTDIR is deleted."
				break
				;;
			[Nn]*)
				echoall "INFO: [$MTDIR] is not replaced."
				echoerr "you might want a new mt.contig.name file for flye2 step."
				exit $EXIT_FAIL
				;;
			*) echo "Please answer yes or no." ;;
			esac
		done
	else
		rm -rf "$MTDIR"
		echo "INFO: $MTDIR is deleted if there is one."
	fi

	echo "$CMD" >"$ODIR"/organelle-assembly_"${INUM}"-"${JNUM}"

	mkdir -p "$MTSEEDSDIR"
	ln -s "$PWD"/"$ODIR"/nk.fq.gz -t "$MTDIR"
	echoall "INFO: extracts contigs from the assembly ${assembly_graph_final_fasta}"
	echo "INFO: uses mt.contig.name at $MTCONTIGNAME"
	echoerr "FILE: reading contigs in $MTCONTIGNAME"
	cat "$MTCONTIGNAME" >&2
	echoerr "please, wait for a long-read data selection ... $INUM -> $JNUM ... bridge=$MBRIDGE p_mapping=$MPAIR s_mapping=$MSINGLE min_len_read=$MR"
	seqkit grep --threads "$NT" -f "$MTCONTIGNAME" "${assembly_graph_final_fasta}" -o "$MTDIR"/contig.fa >/dev/null 2>&1

	contig_count=$(wc -l <"$MTCONTIGNAME")
	if [[ $CIRCULARIZE == "on" ]]; then
		if [ "$contig_count" -eq 1 ]; then
			seqkit fx2tab --length --name "$MTDIR"/contig.fa -o "$MTDIR"/contig.fa.len >/dev/null 2>&1
			A=$(cut -f2 "$MTDIR"/contig.fa.len)
			B=$(echo "scale=0; $A/2" | bc)
			C=$((B + 1))
			seqkit subseq -r 1:"$B" "$MTDIR"/contig.fa -o "$MTDIR"/c1.fa >/dev/null 2>&1
			seqkit subseq -r "$C":"$A" "$MTDIR"/contig.fa -o "$MTDIR"/c2.fa >/dev/null 2>&1
			cat "$MTDIR"/c?.fa | seqkit replace -p '.+' -r 'edge_{nr}' -o "$MTDIR"/contig.fa >/dev/null 2>&1
			cp "$MTCONTIGNAME" "$MTCONTIGNAME"-backup
			echo -e "edge_1\nedge_2" >"$MTCONTIGNAME"
			echo "INFO: creates new $MTDIR/contig.fa and $MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit $EXIT_ERROR
			# "$WDIR"/run-polap-single.R "$MTSEEDSDIR"/contig.tab "$MTSEEDSDIR" "$MSINGLE" >/dev/null 2>&1
			# cat "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
			# echo "INFO: creates long read single name in $MTSEEDSDIR/1.names"
		fi
	fi
	echo "DATA: $MTDIR/contig.fa is created."

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	if [[ -s "$MTDIR"/contig.paf ]]; then
		echo "DATA: previously created $MTDIR/contig.paf is used without executing minimap2."
	else
		minimap2 -cx map-ont "$MTDIR"/contig.fa "$LRNK" -t "$NT" -o "$MTDIR"/contig.paf >/dev/null 2>&1
		echo "DATA: $LRNK is used to select reads."
		echo "DATA: $MTDIR/contig.paf is created."
	fi

	cut -f1-11 "$MTDIR"/contig.paf | awk -v minlength="$MR" '{if ($2>=minlength) {print}}' >"$MTDIR"/contig.tab
	echo "DATA: minimum length of long reads in the read selection: $MR"
	echo "DATA: $MTDIR/contig.tab is created."

	# MT: MPAIR=3000 MBRIDGE=3000 MSINGLE=3000
	# PT: MPAIR=1000 MBRIDGE=5000 MSINGLE=0
	Rscript --vanilla "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" "$MTDIR"/contig.tab "$MTSEEDSDIR" "$MPAIR" "$MBRIDGE" "$MSINGLE" >/dev/null 2>&1
	# "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" $MTDIR/contig.tab $MTSEEDSDIR $MPAIR $MBRIDGE $MSINGLE >/dev/null 2>&1
	echo "OPTION polap pairs alignment minimum: $MPAIR"
	echo "OPTION polap pairs bridge minimum: $MBRIDGE"
	echo "DATA: pair contig names in $MTSEEDSDIR are created."
	echo "DATA: single contig name in $MTSEEDSDIR is created."

	# cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	cat "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	echo "INFO: creates long read names and the single name in $MTSEEDSDIR/1.names"

	# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names $LRNK -o "$MTSEEDSDIR"/1.fq.gz >/dev/null 2>&1
	seqtk subseq "$LRNK" "$MTSEEDSDIR"/1.names | gzip >"$MTSEEDSDIR"/1.fq.gz
	echo "DATA: organelle reads in $MTSEEDSDIR/1.fq.gz"

	TOTAL_LENGTH=$(seqkit stats -Ta "$MTSEEDSDIR"/1.fq.gz | csvtk cut -t -f "sum_len" | csvtk del-header)
	EXPECTED_ORGANELLE_COVERAGE=$((TOTAL_LENGTH / CONTIG_LENGTH))
	echo "INFO: expected coverage: ${EXPECTED_ORGANELLE_COVERAGE}x"

	if [[ "${_arg_test}" == "on" ]]; then
		echoall "OPTION: --test : No reduction of the test long-read data"
		ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
	elif [[ "${_arg_coverage_check}" == "off" ]]; then
		echoall "OPTION: --no-coverage-check : No reduction of the long-read data"
		ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
	else
		if [ "$EXPECTED_ORGANELLE_COVERAGE" -lt "$COV" ]; then
			echoall "LOG: No reduction of the long-read data because $EXPECTED_ORGANELLE_COVERAGE < $COV"
			ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
		else
			echoall "SUGGESTION: you might want to increase the minimum read lengths because you have enough long-read data."
			RATE=$(echo "scale=10; $COV/$EXPECTED_ORGANELLE_COVERAGE" | bc)
			echoall "LOG: long-read data reduction by rate of $RATE <= COV[$COV] / long-read organelle coverage[$EXPECTED_ORGANELLE_COVERAGE]"
			echoall "sampling long-read data by $RATE ... wait ..."
			# seqkit sample -p "$RATE" "$MTSEEDSDIR/1.fq.gz" -o "$MTSEEDSDIR/2.fq.gz" >/dev/null 2>&1
			local seed=${_arg_seed:-$RANDOM}
			_polap_log3_cmd "seqkit sample -p ${RATE} -s ${seed} ${MTSEEDSDIR}/1.fq.gz -o ${MTSEEDSDIR}/2.fq.gz 2>${_polap_output_dest}"
			echoall "DATA: a reduced long-read data $MTSEEDSDIR/2.fq.gz is created"
		fi
	fi

	C=$(ls -1 "$MTSEEDSDIR/"*".name" 2>/dev/null | wc -l)
	if [ "$C" != 0 ]; then
		echo "INFO: bridging reads exist: combinations of $C."
		seqkit seq -n -i "$MTSEEDSDIR"/2.fq.gz >"$MTSEEDSDIR"/single.names.2
		cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names.2 | sort | uniq >"$MTSEEDSDIR"/1.names.2
		# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names.2 $LRNK -o "$MTSEEDSDIR"/2.fq.gz >/dev/null 2>&1
		seqtk subseq "$LRNK" "$MTSEEDSDIR"/1.names.2 | gzip >"$MTSEEDSDIR"/2.fq.gz
	fi
	echoall "DATA: organelle reads in $MTSEEDSDIR/2.fq.gz"

	# put the backup to the original
	if [[ $CIRCULARIZE == "on" ]]; then
		if [[ -s "$MTCONTIGNAME"-backup ]]; then
			mv "$MTCONTIGNAME"-backup "$MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit $EXIT_ERROR
		fi
	fi

	echoerr NEXT: "$(basename "$0")" flye2 -o "$ODIR" -j "$JNUM" -t "$NT" -c "$COV"

	_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_flye2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		JNUM=1
	else
		JNUM=$1
	fi

	_run_polap_flye2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Executes Flye for an organelle-genome assembly
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
# Outputs:
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
################################################################################
function _run_polap_flye2() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	echo "INFO: organelle-genome assembly on $JNUM"

	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	help_message=$(
		cat <<HEREDOC
# Executes Flye for an organelle-genome assembly
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
# Outputs:
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-j|--jnum <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTDIR/contig.fa" ]; then
		echoall "ERROR: no selected-contig file [$MTDIR/contig.fa]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTSEEDSDIR/2.fq.gz" ]; then
		echoall "ERROR: no long-read file [$MTSEEDSDIR/2.fq.gz]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: executing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for an organelle-genome assembly on $JNUM ..."
	flye --nano-raw "$MTSEEDSDIR"/2.fq.gz \
		--out-dir "$MTDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$CONTIG_LENGTH" \
		--stop-after contigger \
		>/dev/null 2>&1
	echoall "CHECK: assembly graph "$PWD/$MTDIR"/30-contigger/graph_final.gfa"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"

	jnum_next=$((JNUM + 1))
	echoall Create and edit $ODIR/$JNUM/mt.contig.name-${jnum_next}
	echoall NEXT: "$(basename "$0")" assemble2 -o "$ODIR" -j ${jnum_next}
	echoall or you could finish with Flye organelle-genome assembly with its polishing stage.
	echoall NEXT: "$(basename "$0")" flye-polishing -o "$ODIR" -j "$JNUM"

	_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# Finishes the Flye organelle-genome assembly.
# Polishes an organelle-genome assembly using long-reads.
# Note: use the same options as flye2 menu.
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/30-contigger
# Outputs:
#   $MTDIR/assembly_graph.gfa
################################################################################
function _run_polap_flye-polishing() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	echo "INFO: polishing organelle-genome assembly on $JNUM"

	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	help_message=$(
		cat <<HEREDOC
# Finishes the Flye organelle-genome assembly.
# Polishes an organelle-genome assembly using long-reads.
# Note: use the same options as flye2 menu.
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/30-contigger
# Outputs:
#   $MTDIR/assembly_graph.gfa
Example: $(basename "$0") ${_arg_menu[0]} [-j|--jnum <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTDIR/contig.fa" ]; then
		echoall "ERROR: no selected-contig file [$MTDIR/contig.fa]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTSEEDSDIR/2.fq.gz" ]; then
		echoall "ERROR: no long-read file [$MTSEEDSDIR/2.fq.gz]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: polishing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for Flye long-read polishing of the organelle-genome assembly on $JNUM ..."
	flye --nano-raw "$MTSEEDSDIR"/2.fq.gz \
		--out-dir "$MTDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$CONTIG_LENGTH" \
		--resume \
		>/dev/null 2>&1
	echoall "CHECK: the long-read polished assembly graph $PWD/$MTDIR/assembly_graph.gfa"
	echoerr "DO: extract a draft organelle genome sequence (mt.0.fasta) from the polished assembly graph"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"
	# echoall NEXT: $(basename $0) check-coverage [-p $PA]
	echoall NEXT: "$(basename "$0")" prepare-polishing -a "$SR1" -b "$SR2"

	_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# Prepares the polishing using FMLRC.
# Arguments:
#   -a s1.fq
#   -b s2.fq
# Inputs:
#   s1.fq
#   s2.fq
# Outputs:
#   $$ODIR/msbwt
################################################################################
function _run_polap_prepare-polishing() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	# Set verbosity level: stderr if verbose >= 2, otherwise discard output
	local _polap_output_dest="/dev/null"
	[ "${_arg_verbose}" -ge "${_polap_var_function_verbose}" ] && _polap_output_dest="/dev/stderr"

	_polap_set-variables-short-read
	source "$script_dir/polap-variables-base.sh" # '.' means 'source'

	help_message=$(
		cat <<HEREDOC
# Prepares the polishing using FMLRC.
# Arguments:
#   -a $SR1
#   -b $SR2
#   or
#   --bioproject ${_arg_bioproject}
# Inputs:
#   $SR1
#   $SR2
# Outputs:
#   $ODIR/msbwt/comp_msbwt.npy
# Precondition:
#   get-bioproject --bioproject ${_arg_bioproject}
Example: $(basename "$0") ${_arg_menu[0]} [-a|--short-read1 <arg>] [-b|--short-read2 <arg>]
Example: $(basename "$0") ${_arg_menu[0]} -o $ODIR
HEREDOC
	)

	# Display help message
	[[ ${_arg_menu[1]} == "help" ]] && _polap_echo0 "${help_message}" && exit $EXIT_SUCCESS

	# Display the content of output files
	if [[ "${_arg_menu[1]}" == "view" ]]; then
		ls -l "${ODIR}/msbwt" >&2
		# Disable debugging if previously enabled
		[ "$DEBUG" -eq 1 ] && set +x
		exit $EXIT_SUCCESS
	fi

	if [ -s "${_polap_var_base_msbwt_tar_gz}" ]; then
		_polap_log1_file "${_polap_var_base_msbwt_tar_gz}"
		if [[ -s "${_polap_var_base_msbwt}" ]]; then
			_polap_log1_file "${_polap_var_base_msbwt}"
			_polap_log1 "  skipping the short-read polishing preparation."
		else
			tar -zxf "${_polap_var_base_msbwt_tar_gz}" -C "${ODIR}"
		fi
	elif [[ -s "${_polap_var_base_msbwt}" ]]; then
		_polap_log1_file "${_polap_var_base_msbwt}"
		_polap_log1 "  skipping the short-read polishing preparation."
	else

		source $HOME/miniconda3/bin/activate polap-fmlrc

		if ! run_check2; then
			echoerr "ERROR: change your conda environment to polap-fmlrc."
			echoerr "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
			echoerr "INFO: (base) $ conda activate polap-fmlrc"
			exit $EXIT_ERROR
		fi

		check_file_existence "${SR1}"
		check_file_existence "${SR2}"

		_polap_log1 "excuting ropebwt2 and msbwt on the short reads ... be patient!"
		if [[ $SR1 = *.fastq || $SR1 = *.fq ]]; then
			cat "$SR1" "$SR2" |
				awk 'NR % 4 == 2' | sort | tr NT TN |
				ropebwt2 -LR 2>"${_polap_output_dest}" |
				tr NT TN |
				msbwt convert "$ODIR"/msbwt \
					>/dev/null 2>&1
		elif [[ $SR1 = *.fq.gz ]] || [[ $SR1 = *.fastq.gz ]]; then
			zcat "$SR1" "$SR2" |
				awk 'NR % 4 == 2' | sort | tr NT TN |
				ropebwt2 -LR 2>"${_polap_output_dest}" |
				tr NT TN |
				msbwt convert "$ODIR"/msbwt \
					>/dev/null 2>&1
		fi
		conda deactivate
	fi

	_polap_log1 "NEXT: $(basename $0) polish [-p mt.0.fasta] [-f mt.1.fa]"

	_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# Polishes using FMLRC.
# Arguments:
#   -p mt.0.fasta
#   -f mt.1.fa
# Inputs:
#   $ODIR/msbwt/comp_msbwt.npy
#   $PA
# Outputs:
#   $FA
################################################################################
function _run_polap_polish() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	# Set verbosity level: stderr if verbose >= 2, otherwise discard output
	local _polap_output_dest="/dev/null"
	[ "${_arg_verbose}" -ge "${_polap_var_function_verbose}" ] && _polap_output_dest="/dev/stderr"

	help_message=$(
		cat <<HEREDOC
# Polishes using FMLRC.
# Arguments:
#   -p $PA: a long-read draft genome assembly
#   -f $FA: a final genome assembly sequence name
# Inputs:
#   $ODIR/msbwt/comp_msbwt.npy
#   $PA
# Outputs:
#   $FA
Example: $(basename "$0") ${_arg_menu[0]} [-p|--unpolished-fasta <arg>] [-f|--final-assembly <arg>]
HEREDOC
	)

	# Display help message
	[[ ${_arg_menu[1]} == "help" ]] && _polap_echo0 "${help_message}" && exit $EXIT_SUCCESS

	source $HOME/miniconda3/bin/activate polap-fmlrc

	if ! run_check2; then
		_polap_log0 "ERROR: change your conda environment to polap-fmlrc."
		_polap_log0 "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		_polap_log0 "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	if [[ ! -s "$ODIR/msbwt/comp_msbwt.npy" ]]; then
		_polap_log0 "ERROR: no msbwt at $ODIR/msbwt/comp_msbwt.npy"
		_polap_log0 "HINT: $0 prepare-polishing [-a s1.fq] [-b s2.fq]"
		exit $EXIT_ERROR
	fi

	_polap_log1 "INFO: executing fmlrc on the draft sequence $PA ... be patient!"
	if [[ -s "${PA}" ]]; then
		fmlrc -p "${NT}" "$ODIR"/msbwt/comp_msbwt.npy "${PA}" "${FA}" >/dev/null 2>&1
	else
		_polap_log0 "ERROR: no unpolished fasta file: [$PA]"
		exit $EXIT_ERROR
	fi

	conda deactivate

	_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# Runs the whole-genome assembly.
# Defaults:
#   l.fq
#   s1.fq
#   s2.fq
#   number of threads: $NT
#   assembly coverage: $COV
# Outputs:
#   $ODIR/long_total_length.txt
#   $ODIR/jellyfish_out.histo
#   $ODIR/short_expected_genome_size.txt
#   $LRNK
#   $FDIR
################################################################################
function _run_polap_assemble1() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x
	_polap_log_function "Function start: $(echo $FUNCNAME | sed s/_run_polap_//)"

	# Set verbosity level: stderr if verbose >= 2, otherwise discard output
	local _polap_output_dest="/dev/null"
	[ "${_arg_verbose}" -ge "${_polap_var_function_verbose}" ] && _polap_output_dest="/dev/stderr"

	source "$script_dir/polap-variables-base.sh" # '.' means 'source'
	source "$script_dir/polap-variables-wga.sh"  # '.' means 'source'
	LRNK="${_polap_var_base_nk_fq_gz}"

	help_message=$(
		cat <<HEREDOC
# Runs the whole-genome assembly.
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
#   -m $MR: the long-read sequence length threshold
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $LR: a long-read fastq 
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
ta file
# Outputs:
#   $ODIR/long_total_length.txt
#   $ODIR/short_expected_genome_size.txt
#   $LRNK
#   $FDIR/30-contigger/contigs.fasta
#   $FDIR/30-contigger/contigs_stats.txt
#   $FDIR/30-contigger/graph_final.fasta
#   $FDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-o|--outdir <arg>] [-l|--long-reads <arg>] [-a|--short-read1 <arg>] [-b|--short-read2 <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	# Display help message
	[[ ${_arg_menu[1]} == "help" ]] && _polap_echo0 "${help_message}" && exit $EXIT_SUCCESS

	# Display the content of output files
	if [[ "${_arg_menu[1]}" == "view" ]]; then

		if [[ -s "${_polap_var_wga_contigger_gfa}" ]]; then
			_polap_log0_file "${_polap_var_wga_contigger_gfa}"
		fi
		_polap_log2 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
		# Disable debugging if previously enabled
		[ "$DEBUG" -eq 1 ] && set +x
		exit $EXIT_SUCCESS
	fi

	# check_file_existence "${LR}"
	# check_file_existence "${SR1}"
	# check_file_existence "${SR2}"

	source "$script_dir/polap-variables-base.sh" # '.' means 'source'

	if [ -s "${_polap_var_base_fq_stats}" ]; then
		_polap_log2 "  skipping summary-reads ..."
	else
		_run_polap_summary-reads
	fi

	if [ -s "${_polap_var_base_long_total_length}" ]; then
		_polap_log2 "  skipping total-length-long ..."
	else
		_run_polap_total-length-long
	fi

	if [ -s "${_polap_var_base_genome_size}" ]; then
		_polap_log2 "  skipping find-genome-size ..."
	else
		_run_polap_find-genome-size
	fi

	if [ -s "${_polap_var_base_nk_fq_gz}" ]; then
		_polap_log2 "  skipping reduce-data ..."
	else
		_run_polap_reduce-data
	fi

	check_file_existence "${_polap_var_base_nk_fq_gz}"

	_run_polap_flye1

	_polap_log1 "Function end: $(echo $FUNCNAME | sed s/_run_polap_//)"
	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# FIXME: separate command parser
################################################################################
function ncbi_command_parse() {
	BIOPRJ=""
	SPECIES=""
	SRA=""
	while getopts "b:s:r:o:" option; do
		case $option in
		b) BIOPRJ=$OPTARG ;;
		s) SPECIES=$OPTARG ;;
		r) SRA=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		# h) usage_of ;;
		\?) # incorrect option
			echo "Error: Invalid option; try -h option"
			exit
			;;
		esac
	done
}

################################################################################
# FIXME: something are complicated. Do we need it?
################################################################################
function _run_polap_x-bioproject2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	mkdir $ODIR
	BIOPRJ=$_arg_bioproject

	MDATA="$ODIR/accessions_demo.txt"
	esearch -db bioproject -query $BIOPRJ | elink -target biosample | efetch -format docsum | xtract.Linux -pattern DocumentSummary -block Ids -element Id -group SRA >${MDATA}
	SRSs=$(cat ${MDATA} | while read LINE; do
		NCOL=$(echo ${LINE} | wc -w)
		ACC=$(echo ${LINE} | cut -d ' ' -f ${NCOL})
		echo ${ACC}
	done | xargs)

	# SRS_str=$(join_by ' OR ' ${SRSs[@]})
	# echoall $SRS_str
	# esearch -db SRA -query "\"" $SRS_str "\"" | efetch -format runinfo | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	for SRS in ${SRSs[@]}; do
		esearch -db SRA -query ${SRS} | efetch -format runinfo
		# esearch -db SRA -query ${SRS} | efetch -format runinfo | tail -n +2
	done >$ODIR/accessions_demo.tab
	# csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

###############################################################################
# Feteches SRA data file.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   SRR10190639.fastq
###############################################################################
function _run_polap_x-ncbi-fetch-sra() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Feteches SRA data file.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   SRR10190639.fastq
Example: $(basename $0) ${_arg_menu[0]} --sra <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if ! run_check1; then
		error_polap_conda
		exit $EXIT_ERROR
	fi

	if [ -z "$_arg_sra" ]; then
		echoerr "ERROR: no --sra option is used."
		exit $EXIT_SUCCESS
	fi

	SRA=$_arg_sra
	"$script_dir"/run-polap-ncbitools fetch sra "$SRA"

	echoerr You have a file called "$SRA".fastq and a folder named "$SRA"
	echoerr if your download try is successful. Then, you would want to delete
	echoerr the folder because we need only the fastq file.

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --sra SRR10190639
################################################################################
function _run_polap_x-ncbi-fetch-sra-runinfo() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   bases
Example: $(basename $0) ${_arg_menu[0]} --sra <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_sra" ]; then
		echoerr "ERROR: no --sra option is used."
		exit $EXIT_SUCCESS
	fi

	echoerr "counting bases in SRA database and its downloaded FASTQ files of SRA [${_arg_sra}] ..."
	bases=$(esearch -db sra -query "${_arg_sra}" |
		efetch -format runinfo |
		csvtk cut -f "bases" |
		csvtk del-header)
	echoall "SRA: ${_arg_sra}: ${bases} (bp)"

	bases2=$(seqkit stats -T "${_arg_sra}"*.fastq 2>/dev/null | csvtk cut -t -f "sum_len" | paste -s -d+ - | bc)
	echoall "FASTQ: ${_arg_sra}*.fastq: ${bases2} (bp)"

	if [ "${bases}" -eq "${bases2}" ]; then
		echoall "LOG: SRA ${_arg_sra} and its FASTQ files: total bases match."
	else
		echoall "ERROR: SRA ${_arg_sra} and its FASTQ files: total bases do not match."
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --species
################################################################################
function _run_polap_x-ncbi-fetch-mtdna-genbank() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --species species-name
# Inputs:
#   species-name
# Outputs:
#   species-name.mt.gb
Example: $(basename "$0") ${_arg_menu[0]} --species <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_species" ]; then
		echoerr "ERROR: no --species option is used."
	else
		S="${_arg_species// /-}"
		esearch -db nuccore -query "(mitochondrion[Title] AND complete[Title] AND genome[Title]) AND ${_arg_species}[Organism]" |
			efetch -format gb >"${S}".mt.gb
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by accession.
# Arguments:
#   --accession
# Inputs:
#   accession ID
# Outputs:
#   <accession>.fa
################################################################################
function _run_polap_x-ncbi-fetch-mtdna-nucleotide() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --accession <arg>
# Inputs:
#   accession ID
# Outputs:
#   <accession>.fa
Example: $(basename "$0") ${_arg_menu[0]} --accession <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_accession" ]; then
		echoerr "ERROR: no --accession option is used."
	else
		esearch -db nuccore -query "${_arg_accession}[ACCN]" </dev/null |
			efetch -format fasta >"${_arg_accession}".fa
		echoall "NEXT: $(basename "$0") align-two-dna-sequences --query mt.1.fa --subject ${_arg_accession}.fa"
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Uses BLAST to align two very similar DNA sequences.
# Before align the two sequences, rearrange the assembled query sequences
# so that they are alignable using multiple sequence alignment tools
# like ClustalW.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
# Outputs:
#   pairwise-alignment.txt
################################################################################
function _run_polap_x-align-two-dna-sequences() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Uses BLAST to align two very similar DNA sequences.
# Before align the two sequences, rearrange the assembled query sequences
# so that they are alignable using multiple sequence alignment tools
# like ClustalW.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
# Outputs:
#   pairwise-alignment.txt
Example: $(basename "$0") ${_arg_menu[0]} [--query <arg>] [--subject <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_query" -a -z "$_arg_subject" ]; then
		echoerr "ERROR: no --query and --subject option are used."
		echoerr "INFO: --query mt.1.fa --subject NCBI.fa"
		echoerr "INFO: seqkit seq -p -r mt.1.fa -o mt.1r.fa"
		echoerr "INFO: seqkit restart -i <POS> mt.1.fa -o mt.2.fa"
	else
		blastn -query "$_arg_query" -subject "$_arg_subject" >pairwise-alignment.txt
		echoerr "INFO: seqkit seq -p -r mt.1.fa -o mt.1r.fa"
		echoerr "INFO: seqkit restart -i <POS> mt.1.fa -o mt.2.fa"
		echoerr "INFO: $(basename "$0") clustal --query mt.2.fa --subject NCBI-ACC.fa"
		echoerr see pairwise-alignment.txt
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Uses clustalw to align two DNA sequences.
# After rearranging parts of a query assembled sequence,
# we use clustalw to align the two to check how similar they are.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
################################################################################
function _run_polap_x-clustal() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Uses clustalw to align two DNA sequences.
# After rearranging parts of a query assembled sequence,
# we use clustalw to align the two to check how similar they are.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
Example: $(basename "$0") ${_arg_menu[0]} [--query <arg>] [--subject <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [[ -s x.aln ]]; then
		echoall "INFO: clustalw alignemnt is found."
	else
		local MT1=$_arg_query
		shift
		local MT2=$_arg_subject
		shift
		command -v clustalw2 >/dev/null 2>&1 || {
			echo >&2 "clustalw2: not installed"
			exit 1
		}
		cat "$MT1" "$MT2" >x.fa
		clustalw2 x.fa
	fi
	# TODO: works for only Linux.
	GAP1=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	GAP2=$(sed -n '5~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	MATCH=$(sed -n '6~4p' x.aln | tr -dc '*' | wc -c)
	TOTAL=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | wc -c)
	GAP=$((GAP1 + GAP2))
	MISMATCH=$((TOTAL - MATCH - GAP))
	echoall "INFO: pairwise alignment:   length: $TOTAL"
	echoall "INFO: pairwise alignment:    match: $MATCH"
	echoall "INFO: pairwise alignment: mismatch: $MISMATCH"
	echoall "INFO: pairwise alignment:     gaps: $GAP"
	LENGTH1=$(seqkit stats -Ta "$_arg_subject" | csvtk cut -t -f "sum_len" | csvtk del-header)
	LENGTH2=$(seqkit stats -Ta "$_arg_query" | csvtk cut -t -f "sum_len" | csvtk del-header)
	NAME1=$(seqkit seq -n -i "$_arg_subject")
	NAME2=$(seqkit seq -n -i "$_arg_query")
	echoall "INFO: Sequence1: $NAME1"
	echoall "INFO: SequenceLen1: $LENGTH1"
	echoall "INFO: Sequence2: $NAME2"
	echoall "INFO: SequenceLen2: $LENGTH2"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Checks the coverage using samtools.
# Arguments:
#   -p mt.0.fasta
# Inputs:
#   $LRNK
#   $PA
# Outputs:
#   $FA
################################################################################
function _run_polap_x-check-coverage() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	LRNK="$ODIR/nk.fq.gz"

	help_message=$(
		cat <<HEREDOC
# NOT IMPLEMENTED YET
# Checks the coverage on a draft genome using samtools.
# Arguments:
#   -p $PA: a draft genome
# Inputs:
#   $LRNK
#   $PA
# Outputs:
Example: $(basename "$0") ${_arg_menu[0]} [-p|--unpolished-fasta <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$PA" ] && [ -z "$LRNK" ]; then
		echoerr "ERROR: no -p option are used."
		echoerr "INFO: --p mt.0.fasta"
	else
		echo "INFO: executing minimap2 and samtools for checking the long reads coverage on the $PA ... be patient!"
		if [[ ! -s "$PA" ]]; then
			echoall "ERROR: no such file $PA"
			exit $EXIT_ERROR
		fi

		if [[ ! -s "$LRNK" ]]; then
			echoall "ERROR: no such file $LRNK"
			exit $EXIT_ERROR
		fi

		minimap2 -t "$NT" -ax map-ont "$PA" "$LRNK" 2>/dev/null |
			samtools view -u 2>/dev/null |
			samtools sort -o "$ODIR"/1.bam \
				>/dev/null 2>&1
		samtools coverage -A -w 32 "$ODIR"/1.bam 1>&2

		echoerr INFO: conda env create -f "$WDIR"/environment-fmlrc.yaml
		echoerr INFO: conda activate polap-fmlrc
		echoerr "NEXT: $(basename "$0") prepare-polishing [-a s1.fq] [-b s2.fq]"
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects and assembles long-read data.
# Arguments:
#   -i 0
#   -j 1
#   -o o
#   -t $NT
#   -m $MR
#   MPAIR
#   MBRIDGE
#   COV
#   CIRCULARIZE
# Inputs:
# Outputs:
################################################################################
function _run_polap_assemble2() {
	[ "$DEBUG" -eq 1 ] && set -x

	LRNK="$ODIR/nk.fq.gz"
	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	ADIR="$FDIR"/50-annotation
	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	MTCONTIGNAME="$FDIR"/mt.contig.name-"$JNUM"

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta

	help_message=$(
		cat <<HEREDOC
# Selects reads mapped on a genome assembly and assembles an organelle genome.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>] [-r|--pair-min <arg>] [-x|--bridge-min <arg>] [-w|--single-min <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	# Display help message
	[[ ${_arg_menu[1]} == "help" ]] && _polap_echo0 "${help_message}" && exit $EXIT_SUCCESS

	check_file_existence "${MTCONTIGNAME}"
	check_file_existence "${assembly_graph_final_fasta}"
	check_file_existence "${LRNK}"

	echoerr "NEXT: $(basename $0) select-reads -o $ODIR -i $INUM -j $JNUM"
	_run_polap_select-reads
	_run_polap_flye2

	[ "$DEBUG" -eq 1 ] && set +x
}

################################################################################
# NOT IMPLEMENTED YET!
# because we need a manual long-read selection step.
# You could execute this menu with option --test.
#
# Runs the organelle-genome assembly.
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Inputs:
#   $LR: a long-read fastq
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
# Outputs:
#   $MTDIR/assembly_graph.gfa
################################################################################
function _run_polap_assemble() {
	# Enable debugging if DEBUG is set
	[ "$DEBUG" -eq 1 ] && set -x

	# Set verbosity level: stderr if verbose >= 2, otherwise discard output
	local _polap_output_dest="/dev/null"
	[ "${_arg_verbose}" -ge "${_polap_var_function_verbose}" ] && _polap_output_dest="/dev/stderr"

	source "$script_dir/polap-variables-base.sh" # '.' means 'source'
	source "$script_dir/polap-variables-wga.sh"  # '.' means 'source'

	help_message=$(
		cat <<HEREDOC
# Runs the POLAP organelle-genome assembly with sequencing data.
# 
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Inputs:
#   $LR: a long-read fastq 
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
# Outputs:
#   $MTDIR/assembly_graph.gfa
Example: $(basename $0) ${_arg_menu[0]} --test
HEREDOC
	)

	# Display help message
	[[ ${_arg_menu[1]} == "help" ]] && _polap_echo0 "${help_message}" && exit $EXIT_SUCCESS

	# Not delete the output directory.
	mkdir -p "$ODIR"

	# Run assembly, annotation, and contig selection steps
	if [ -s "${_polap_var_wga_contigger_gfa}" ]; then
		_polap_log1 "  skipping the whole-genome assembly"
	else
		check_file_existence "${LR}"
		_run_polap_assemble1
	fi

	if [ -s "${_polap_var_wga_annotation}" ]; then
		_polap_log1 "  skipping the organelle annotation on the whole-genome"
	else
		_run_polap_annotate
	fi

	# Select seed contigs
	_run_polap_select-contigs

	# Loop over numbers from 1 to 5
	for i in "${_arg_select_contig_numbers[@]}"; do
		# Call the function corresponding to the current number (index is i-1)
		INUM=0
		FDIR="${ODIR}/${INUM}"
		JNUM="${i}"

		MTCONTIGNAME="$FDIR"/mt.contig.name-$JNUM
		# check the mt.contig.name-1
		if [ -s "$MTCONTIGNAME" ]; then
			# Run secondary assembly, polishing, and mtDNA selection steps
			_polap_log1_file "${MTCONTIGNAME}"
			_run_polap_assemble2
			INUM="${i}" _run_polap_annotate
			INUM="${i}" _run_polap_flye-polishing
			INUM="${i}" _run_polap_select-mtdna
		else
			_polap_log1 "LOG: $MTCONTIGNAME is empty for select-contig type $i ..."
		fi
	done

	if [ -s "${_polap_var_base_msbwt}" ]; then
		_polap_log1 "  skipping the preparation of short-read polishing ..."
	else
		if [ -s "${_polap_var_base_msbwt_tar_gz}" ]; then
			_polap_log1 "  decompressing ${_polap_var_base_msbwt_tar_gz} ... later when we polish it with the short-read data."
			tar -zxf "${_polap_var_base_msbwt_tar_gz}" -C "${ODIR}"
		else
			_polap_log1 "  Do the preparation of short-read polishing ... early"
			check_file_existence "${SR1}"
			check_file_existence "${SR2}"
			_run_polap_prepare-polishing
		fi
	fi

	# Run the polishing step
	for i in "${_arg_select_contig_numbers[@]}"; do
		# Define the paths for mtDNA sequences to be polished
		PA="${ODIR}/${i}/mt.0.fasta"
		FA="${ODIR}/${i}/mt.1.fa"

		if [ -s "${PA}" ] && [ -s "${_polap_var_base_msbwt}" ]; then
			_run_polap_polish
		fi
	done

	# Disable debugging if previously enabled
	[ "$DEBUG" -eq 1 ] && set +x
}

function _run_polap_x-help() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	print_x-help 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# utilities
################################################################################

################################################################################
# for the magic logit function
################################################################################
function logit() {
	while read; do
		# echo "$(date) $REPLY" >> ${LOG_FILE}
		# -1 means "current time"
		# printf "[%(%Y-%m-%d %T)T] %s\n" -1 "$REPLY" >> ${LOG_FILE}
		printf "[%s] %s\n" "$(date +"%Y-%m-%d %T")" "$REPLY" >>${LOG_FILE}
	done
}

# Function to handle verbose output
function verbose_echo() {
	local msg_level=$1 # The verbosity level of this message
	shift              # Shift arguments to access the actual message
	local message="$@"

	# Only print if the current verbosity level is greater than or equal to the message level
	if [ "${_arg_verbose}" -ge "$msg_level" ]; then
		# echo "${_arg_verbose} > ${msg_level}: $message"
		echo "$message"
	fi
}

function verbose_echo_newline() {
	local msg_level=$1 # The verbosity level of this message
	shift              # Shift arguments to access the actual message
	local message="$@"

	# Only print if the current verbosity level is greater than or equal to the message level
	if [ "${_arg_verbose}" -ge "$msg_level" ]; then
		# echo "${_arg_verbose} > ${msg_level}: $message"
		echo ""
		echo "$message"
	fi
}

function verbose_cat() {
	local msg_level=$1 # The verbosity level of this message
	shift              # Shift arguments to access the actual message
	local message="$@"

	# Only print if the current verbosity level is greater than or equal to the message level
	if [ "${_arg_verbose}" -ge "$msg_level" ]; then
		# echo "${_arg_verbose} > ${msg_level}: $message"
		cat "$message"
	fi
}

function verbose_head() {
	local msg_level=$1 # The verbosity level of this message
	shift              # Shift arguments to access the actual message
	local message="$@"

	# Only print if the current verbosity level is greater than or equal to the message level
	if [ "${_arg_verbose}" -ge "$msg_level" ]; then
		# echo "${_arg_verbose} > ${msg_level}: $message"
		head "$message"
	fi
}

# default: no stderr output
# print to stderr if --verbose
function echoerr() { verbose_echo 2 "$@" 1>&2; }

# default: output to log but no stderr output
# print to stderr if --verbose
function echoall() {
	verbose_echo 2 "$@" 1>&2
	verbose_echo 1 "$@"
}

# function yell() { verbose_echo 1 "$0: $*" >&2; }
function yell() {
	verbose_echo 1 "$@" >&2
}

function die() {
	verbose_echo 0 "$@" 1>&2
	verbose_echo 0 "$@"
	exit $EXIT_FAIL
}

function _polap_die() {
	verbose_echo 0 "$@" 1>&2
	verbose_echo 0 "$@"
	exit $EXIT_FAIL
}

function try() { "$@" || die "cannot $*"; }

# Helper function for checking if a file exists
function check_file_existence() {
	local file=$1
	if [ ! -s "$file" ]; then
		die "ERROR: No such file: $file"
		exit $EXIT_ERROR
	fi
}

function check_folder_existence() {
	local folder=$1
	if [ ! -d "$folder" ]; then
		die "ERROR: No such folder: $folder"
		exit $EXIT_ERROR
	fi
}

# Helper function for logging
# only to the screen with --verbose
function log1_file() {
	echoerr "FILE: $1"
}

function _polap_log0_file() {
	_polap_log0 "FILE: $@"
}

function _polap_log1_file() {
	_polap_log1 "FILE: $@"
}

function _polap_log2_file() {
	_polap_log2 "FILE: $@"
}

function _polap_log3_file() {
	_polap_log3 "FILE: $@"
}

# --quiet level
# log only to the log file
function _polap_log0() {
	verbose_echo 0 "$@"
	verbose_echo 1 "$@" 1>&2
}

# log level 1 to the log file
# log level 0 to the screen
function _polap_log1() {
	verbose_echo 1 "$@"
	verbose_echo 2 "$@" 1>&2
}

# log level 2 to the log file
# log level 1 to the screen
function _polap_log2() {
	verbose_echo 2 "$@"
	verbose_echo 3 "$@" 1>&2
}

# log level 3 to the log file
# log level 2 to the screen
function _polap_log3() {
	verbose_echo 3 "$@"
	verbose_echo 4 "$@" 1>&2
}

function _polap_log3_cmd() {
	verbose_echo 3 "$@"
	verbose_echo 4 "$@" 1>&2
	"$@"
}

function _polap_log3_pipe() {
	verbose_echo 3 "$@"
	verbose_echo 4 "$@" 1>&2
	eval "$@"
}

function _polap_log0_log() {
	_polap_log0 "LOG: $@"
}

function _polap_log1_log() {
	_polap_log1 "LOG: $@"
}

function _polap_log2_log() {
	_polap_log2 "LOG: $@"
}

function _polap_log3_log() {
	_polap_log3 "LOG: $@"
}

function _polap_echo0() {
	verbose_echo 0 "$@" 1>&2
}

function _polap_log0_cat() {
	verbose_cat 0 "$@"
	verbose_cat 1 "$@" 1>&2
}

function _polap_log1_cat() {
	verbose_cat 1 "$@"
	verbose_cat 2 "$@" 1>&2
}

function _polap_log2_cat() {
	verbose_cat 2 "$@"
	verbose_cat 3 "$@" 1>&2
}

function _polap_log3_cat() {
	verbose_cat 3 "$@"
	verbose_cat 4 "$@" 1>&2
}

function _polap_log_function() {
	verbose_echo_newline 2 "$@"
	verbose_echo_newline 3 "$@" 1>&2
}

function _run_polap_gbs() {
	_run_polap_get-bioproject-sra
}

function _run_polap_scbg() {
	_run_polap_select-contigs-by-graph-depth-length
}

################################################################################
# All of the variables at our disposal
################################################################################

_polap_var_function_verbose=4

# include and execute other BASH and R scripts
WDIR="$(dirname "$0")"
WDIR="${BASH_SOURCE%/*}"
if [[ ! -d "$WDIR" ]]; then
	WDIR="$PWD"
fi
WDIR=$script_dir

# variables for input data file names for flexible data processing.
LR=$_arg_long_reads       # long-read data file
SR1=$_arg_short_read1     # paired short-read data file 1
SR2=$_arg_short_read2     # paired short-read data file 2
PA=$_arg_unpolished_fasta # assembled draft sequence extracted from bandage
FA=$_arg_final_assembly   # polished sequence

# variables for output
ODIR=$_arg_outdir
INUM=$_arg_inum
JNUM=$_arg_jnum
FDIR="$ODIR"/0 # flye 1st output
if [ "${_arg_archive_is}" = "off" ]; then
	_arg_archive="${ODIR}-a"
fi

# tuning variables for optimal performance
LRNK="$ODIR/nk.fq.gz"
MR=$_arg_min_read_length
MPAIR=$_arg_pair_min     # 3000 for MT, 1000 for PT
MBRIDGE=$_arg_bridge_min # used to be 3000,
MSINGLE=$_arg_single_min # not used deprecated
COV=$_arg_coverage
# NT=$(cat /proc/cpuinfo | grep -c processor)
NT=$_arg_threads
if test -z "$DEBUG"; then
	DEBUG=0
fi
CIRCULARIZE=$_arg_circularize # "--circularize"
SPECIES=$_arg_species

################################################################
# Variables
SRA=$_arg_sra
SRALONG=""
SRASHORT=""
RESUME=$_arg_resume
ALL_ANNOTATE="--selective-annotate"
FLYE_CONTIGGER="--contigger"
USE_EDGES="--no-use-edges"
NO_REDUCTION_READS=$_arg_reduction_reads
NO_COVERAGE_CHECK=$_arg_coverage_check

# Constants
EXIT_SUCCESS=0
EXIT_FAIL=1
EXIT_ERROR=2
RETURN_SUCCESS=0
RETURN_FAIL=1

SECONDS=0

################################################################
# MAIN
#
if [ $# -eq 0 ]; then
	print_help
	touch make-menus
	exit $EXIT_SUCCESS
fi

# all message to a log file
# https://stackoverflow.com/questions/49851882/how-to-log-echo-statement-with-timestamp-in-shell-script
if [ "${_arg_log}" = "polap.log" ]; then
	LOG_FILE="${ODIR}/polap.log"
	[[ ! -d "${ODIR}" ]] && mkdir -p "${ODIR}"
else
	LOG_FILE="${_arg_log}"
fi
exec 3>&1 1>> >(logit)
# exec 3>&1 1>> >(logit) 2>&1

CMD="$0 $*"
echo "CMD: $CMD"

# subcommand function call
if declare -f "_run_polap_${_arg_menu[0]}" >/dev/null 2>&1; then
	# invoke that function, passing arguments through
	# _run_polap_"$@" # same as "$1" "$2" "$3" ... for full argument list
	_run_polap_${_arg_menu[0]}
else
	_polap_log0 "Menu: assemble1, annotate, assemble2,"
	_polap_log0 "      reset, total-length-long, find-genome-size, reduce-data, flye1,"
	_polap_log0 "      blast-genome, count-gene, select-reads, flye2,"
	_polap_log0 "      flye-polishing, prepare-polishing, polish,"
	_polap_log0 "      assemble,"
	_polap_log0 "ERROR: no such menu of $1"
fi

ELAPSED="Time at $(hostname): $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"

# _polap_log0 "${_polap_var_apple}"
# _polap_log0 "var: ${_polap_var_apple}"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
