#!/usr/bin/env bash
# polap-bash-fast-mtseed-ont.sh v0.3.0
# Version: v0.3.0 (merged PT-removal + fast mtseed; steps start at 1)
#
# Pipeline outline (ONT):
#   1) Remove plastid-origin reads (PT) using isoform A/B + identity cutoff
#      (auto-learned or --identity-min override) → reads.nonpt.fq.gz
#      [optional: --profiling]
#   2) All-vs-all overlap (ignore overlap_mode here):
#        • try scan+stream+edges first (autotune scan), else
#        • fallback to full minimap2 ava-ont → build overlapness.tsv
#      Also: draw scan QC figures/tables via polap-r-scan-autotune-qc.R.
#   3) BUSCO QC on a 10% subsample (optional) → nuclear label list (sample).
#      Then select mito-enriched reads from overlapness (nuclear-aware if labels).
#   4) Assemble selected reads (miniasm | raven).
#   5) (Optional) Use miniasm GFA as seeds to run 'polap readassemble' finisher.
#   6) Map reads→ eeds (if iterating)
#   7) Stop when Δ|M| < threshold (if iterating)
#
# Required helpers (must exist; not embedded here):
#   ${_POLAPLIB_DIR}/polap-bash-pt-isoform.sh
#   ${_POLAPLIB_DIR}/remove-ptdna-reads/polap-py-pt-ident-threshold.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-overlapness-from-paf.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-topfrac-by-wdeg.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-filter-paf-by-ids.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-cds-coverage-from-paf.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-seed-mapped-reads.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-stop-delta.py
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-awk-filter-conservative.awk
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-bash-recruit-count.sh
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-bash-paf2mreads.sh
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-r-pick-high-recruit.R
#   ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-threshold-from-nuclear.py
#   (for scan+stream+edges mode)
#     ${_POLAPLIB_DIR}/fast-mtseed-ont/paf-topk-per-q.py
#     ${_POLAPLIB_DIR}/fast-mtseed-ont/paf-to-edges-stream.py
#     ${_POLAPLIB_DIR}/fast-mtseed-ont/polap-py-edges-components.py  (optional)
#
set -euo pipefail

# ────────────────────────────────────────────────────────────────────
# Paths & environment
# ────────────────────────────────────────────────────────────────────
_POLAPLIB_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${_POLAPLIB_DIR}/polap-lib-conda.sh" || true
source "${_POLAPLIB_DIR}/polap-lib-assert.sh" || true
HELP="${_POLAPLIB_DIR}/fast-mtseed-ont"
mkdir -p "${HELP}"

# Helpers (fast-mtseed)
SCAN_QCR="${HELP}/polap-r-scan-autotune-qc.R"
AUTOSCANPY="${HELP}/polap-py-autotune-scan.py"
OLPY="${HELP}/polap-py-overlapness-from-paf.py"
TOPPY="${HELP}/polap-py-topfrac-by-wdeg.py"
FILTPY="${HELP}/polap-py-filter-paf-by-ids.py"
CDSPY="${HELP}/polap-py-cds-coverage-from-paf.py"
SEEDREADSPY="${HELP}/polap-py-seed-mapped-reads.py"
STOPPY="${HELP}/polap-py-stop-delta.py"
AWK_CONS="${HELP}/polap-awk-filter-conservative.awk"
RECRUIT_SH="${HELP}/polap-bash-recruit-count.sh"
PAF2MREADS_SH="${HELP}/polap-bash-paf2mreads.sh"
R_PICK="${HELP}/polap-r-pick-high-recruit.R"
THRESH_NUC_PY="${HELP}/polap-py-threshold-from-nuclear.py"
PY_PT_THRESH="${HELP}/polap-py-pt-ident-threshold.py"

# Helpers for PT removal & isoforms
PT_ISOFORM_SH="${_POLAPLIB_DIR}/polap-bash-pt-isoform.sh"

# scan+stream+edges mode
TOPKPY="${HELP}/paf-topk-per-q.py"
EDGPY="${HELP}/paf-to-edges-stream.py"
EDGECOMP="${HELP}/polap-py-edges-components.py" # optional

# ────────────────────────────────────────────────────────────────────
# Logging & profiling
# ────────────────────────────────────────────────────────────────────
VERBOSE=1
DRY=0
LOG_FD="/dev/stderr"
TEE_ACTIVE=0
PROF=0
PROF_FILE=""

# Base helper for all note levels
_note_base() {
	local lvl=$1
	shift
	local msg="$*"
	local src="${BASH_SOURCE[2]##*/}"
	local ln="${BASH_LINENO[1]}"
	local ts
	ts="$(date +'%F %T')"
	local line="[$ts][${src}:${ln}] $msg"
	if [[ "${VERBOSE:-0}" -gt "$lvl" ]]; then
		if [[ "${_arg_log_stderr:-off}" == "off" ]]; then
			printf "%s\n" "$line" >&3 || printf "%s\n" "$line" >&2
		else
			printf "%s\n" "$line" >&2
		fi
	fi
	printf "%s\n" "$line" >/dev/null
}
note() { _note_base 1 "$@"; }
note0() { _note_base 0 "$@"; }
note1() { _note_base 1 "$@"; }
note2() { _note_base 2 "$@"; }
note3() { _note_base 3 "$@"; }

cmd() {
	if ((DRY)); then
		local p="$1"
		shift
		printf "[DRY] %q" "$p" | tee -a "$LOG_FD"
		for a in "$@"; do printf " %q" "$a" | tee -a "$LOG_FD"; done
		printf "\n" | tee -a "$LOG_FD"
		return 0
	fi
	local p="$1"
	shift
	printf "[RUN] %q" "$p" | tee -a "$LOG_FD"
	for a in "$@"; do printf " %q" "$a" | tee -a "$LOG_FD"; done
	printf "\n" | tee -a "$LOG_FD"
	"$p" "$@"
}
prof_start() { ((PROF)) && PROF_T0=$(date +%s) && PROF_STEP="$1" || true; }
prof_end() {
	((PROF)) || return 0
	local t1=$(date +%s)
	echo -e "${PROF_STEP}\t$((t1 - PROF_T0))" >>"$PROF_FILE"
}

require_tools() {
	local miss=0
	for t in "$@"; do
		command -v "$t" >/dev/null 2>&1 || {
			echo "ERR missing tool: $t" >&2
			miss=1
		}
	done
	_polap_assert '((miss == 0))'
	((miss == 1)) && {
		echo "ERR load modules/conda" >&2
		exit 127
	}
	# this return 0 is import for no silent exit.
	return 0
}

# ────────────────────────────────────────────────────────────────────
# CLI (merged options)
# ────────────────────────────────────────────────────────────────────
reads=""
pt_ref=""
outdir="fast_mtseed_ont_out"
threads=32
# PT removal knobs
pt_origin=""
nuc_origin=""
alen_min=3000
identity_min=""
fpr=0.01
tpr=0.95
profiling=0
# All-vs-all / selection / assembly
overlap_mode="scan"
scan_keep_frac="0.40"
scan_k=21
scan_w=9
scan_N=1
scan_mask="0.70"
scan_minocc=20
refine_k=19
refine_w=7
refine_N=30
refine_mask="0.60"
refine_minocc=10
topk_per_q=0
topk_edges_per_node=0
keep_scan_paf=0
gzip_edges=1
top_frac="0.20"
min_olen=1200
min_ident="0.84"
w_floor="0.12"
assembler="miniasm"
# intergenic / BUSCO
mcds=""
nprot=""
nuc_ids_opt=""
# iteration
rounds_max=1
delta_stop="0.05"
seed=13
steps=""

usage() {
	cat <<EOF
polap-bash-fast-mtseed-ont.sh v0.3.0 (merged PT removal + fast mtseed)
Usage:
  $0 -r reads.fq.gz -p pt_ref.fa -o outdir [options]
EOF
}

while [[ $# -gt 0 ]]; do
	case "$1" in
	-r | --reads)
		reads="$2"
		shift 2
		;;
	--step)
		steps="$2"
		shift 2
		;;
	-p | --pt-ref)
		pt_ref="$2"
		shift 2
		;;
	-o | --outdir)
		outdir="$2"
		shift 2
		;;
	--nuc-ids)
		nuc_ids_opt="$2"
		shift 2
		;;
	-t | --threads)
		threads="$2"
		shift 2
		;;
	--pt-origin)
		pt_origin="$2"
		shift 2
		;;
	--mt-origin)
		mt_origin="$2"
		shift 2
		;;
	--nuc-origin)
		nuc_origin="$2"
		shift 2
		;;
	--alen-min)
		alen_min="$2"
		shift 2
		;;
	--identity-min)
		identity_min="$2"
		shift 2
		;;
	--fpr)
		fpr="$2"
		shift 2
		;;
	--tpr)
		tpr="$2"
		shift 2
		;;
	--overlap-mode)
		overlap_mode="$2"
		shift 2
		;;
	--scan-keep-frac)
		scan_keep_frac="$2"
		shift 2
		;;
	--scan-k)
		scan_k="$2"
		shift 2
		;;
	--scan-w)
		scan_w="$2"
		shift 2
		;;
	--scan-N)
		scan_N="$2"
		shift 2
		;;
	--scan-mask)
		scan_mask="$2"
		shift 2
		;;
	--scan-minocc)
		scan_minocc="$2"
		shift 2
		;;
	--refine-k)
		refine_k="$2"
		shift 2
		;;
	--refine-w)
		refine_w="$2"
		shift 2
		;;
	--refine-N)
		refine_N="$2"
		shift 2
		;;
	--refine-mask)
		refine_mask="$2"
		shift 2
		;;
	--refine-minocc)
		refine_minocc="$2"
		shift 2
		;;
	--topk-per-q)
		topk_per_q="$2"
		shift 2
		;;
	--topk-edges-per-node)
		topk_edges_per_node="$2"
		shift 2
		;;
	--keep-scan-paf)
		keep_scan_paf=1
		shift
		;;
	--no-gzip-edges)
		gzip_edges=0
		shift
		;;
	--top-frac)
		top_frac="$2"
		shift 2
		;;
	--min-olen)
		min_olen="$2"
		shift 2
		;;
	--min-ident)
		min_ident="$2"
		shift 2
		;;
	--w-floor)
		w_floor="$2"
		shift 2
		;;
	-m | --mt-cds)
		mcds="$2"
		shift 2
		;;
	-n | --nuc-prot)
		nprot="$2"
		shift 2
		;;
	--rounds-max)
		rounds_max="$2"
		shift 2
		;;
	--delta-stop)
		delta_stop="$2"
		shift 2
		;;
	--seed)
		seed="$2"
		shift 2
		;;
	-v | --verbose)
		VERBOSE=$((VERBOSE + 1))
		shift
		;;
	--quiet | -q)
		VERBOSE=0
		shift
		;;
	--dry)
		DRY=1
		shift
		;;
	--profiling)
		PROF=1
		shift
		;;
	-h | --help)
		usage
		exit 0
		;;
	*)
		echo "ERR unknown arg: $1" >&2
		usage
		exit 2
		;;
	esac
done

note2 "check: required tools"

require_tools minimap2 samtools seqkit python Rscript awk sort comm cut gzip

note2 "check: required scripts"
for s in "$OLPY" "$TOPPY" "$FILTPY" "$CDSPY" "$SEEDREADSPY" \
	"$STOPPY" "$AWK_CONS" "$RECRUIT_SH" "$PAF2MREADS_SH" \
	"$R_PICK" "$THRESH_NUC_PY" "$PT_ISOFORM_SH" "$PY_PT_THRESH" \
	"$SCAN_QCR" "$AUTOSCANPY"; do
	_polap_assert '[[ -s "$s" ]]' "Tool $s is required."

	[[ -s "$s" ]] || {
		echo "ERR missing helper: $s" >&2
		exit 1
	}
done

note2 "check: long-read data: $reads"
[[ -n "$reads" && -s "$reads" ]] || {
	echo "ERR missing --reads" >&2
	exit 2
}

note2 "check: ptDNA ref: $pt_ref"
[[ -n "$pt_ref" && -s "$pt_ref" ]] || {
	echo "ERR missing --pt-ref" >&2
	exit 2
}

mkdir -p "$outdir" "$outdir/log"
LOG="${outdir}/pipeline.log"
LOG_FD="$LOG"
if ((!DRY)); then
	exec > >(tee -a "$LOG") 2>&1
	TEE_ACTIVE=1
fi
if ((PROF)); then
	PROF_FILE="$outdir/log/profile.tsv"
	echo -e "step\tseconds" >"$PROF_FILE"
fi

note "Outdir: $outdir"
note "Assembler: $assembler ; threads: $threads"
note "Overlap mode (ignored in Step2 scheduling): $overlap_mode"

# Step gating
_step_set=""
_add_steps() {
	local spec="$1"
	IFS=',' read -r -a arr <<<"$spec"
	for tok in "${arr[@]}"; do
		if [[ "$tok" =~ ^([0-9]+)-([0-9]+)$ ]]; then
			local a=${BASH_REMATCH[1]} b=${BASH_REMATCH[2]}
			for ((i = a; i <= b; i++)); do _step_set+=" $i "; done
		elif [[ "$tok" =~ ^[0-9]+$ ]]; then _step_set+=" $tok "; fi
	done
}
_should_run() {
	local s="$1"
	[[ -z "$steps" ]] && return 0
	[[ -z "$_step_set" ]] && _add_steps "$steps"
	[[ " $_step_set " == *" $s "* ]]
}

# ────────────────────────────────────────────────────────────────────
# Step 1: PT removal
# ────────────────────────────────────────────────────────────────────
R1="$reads"
if _should_run 1; then
	note0 "1a) Build PT isoforms A/B"
	PANEL_DIR="$outdir/01-panel"
	mkdir -p "$PANEL_DIR"
	prof_start "pt_isoform"
	cmd bash "$PT_ISOFORM_SH" -r "$pt_ref" -o "$PANEL_DIR" -t "$threads"
	prof_end
	ISO_A="$PANEL_DIR/pt_isomerA.fa"
	ISO_B="$PANEL_DIR/pt_isomerB.fa"
	[[ -s "$ISO_A" ]] || {
		echo "ERR missing pt_isomerA.fa" >&2
		exit 3
	}

	note0 "1b) Double isoforms (single-record)"
	dbld() {
		python - "$1" "$2" <<'PY'
import sys
inp,outp=sys.argv[1],sys.argv[2]
name=None; seq=[]
with open(inp) as f:
  for ln in f:
    if ln.startswith('>'):
      if name is None: name=ln[1:].strip().split()[0]
      else: break
    else: seq.append(ln.strip())
S=''.join(seq)
with open(outp,'w') as w:
  w.write('>pt.double\n'); w.write(S+S+'\n')
PY
	}
	DBL_A="$PANEL_DIR/pt_isomerA.double.fa"
	DBL_B="$PANEL_DIR/pt_isomerB.double.fa"
	prof_start "pt_double"
	((!DRY)) && dbld "$ISO_A" "$DBL_A"
	((!DRY)) && { [[ -s "$ISO_B" ]] && dbld "$ISO_B" "$DBL_B" || true; }
	prof_end

	note0 "1c) Map reads→ doubled A/B"
	MAP_DIR="$outdir/02-map"
	mkdir -p "$MAP_DIR"
	PAF_A="$MAP_DIR/formA.paf"
	PAF_B="$MAP_DIR/formB.paf"
	prof_start "map_ptA"
	cmd minimap2 -x map-ont --secondary=yes -N 50 -t "$threads" "$DBL_A" "$reads" >"$PAF_A"
	prof_end
	if [[ -s "$DBL_B" ]]; then
		prof_start "map_ptB"
		cmd minimap2 -x map-ont --secondary=yes -N 50 -t "$threads" "$DBL_B" "$reads" >"$PAF_B"
		prof_end
	fi

	note0 "1d) MT-guided identity cutoff & emit pt.ids"
	PT_VARS="$outdir/pt_thresh.vars"
	PT_DIAG="$outdir/pt_thresh.diag.tsv"
	PT_IDS="$outdir/pt.ids"
	if [[ -n "$identity_min" ]]; then
		note "using --identity-min=$identity_min ; alen_min=$alen_min"
		if ((!DRY)); then
			awk -v ID="$identity_min" -v AL="$alen_min" 'BEGIN{FS=OFS="\t"} NF>=12{ id=($11>0?$10/$11:0); if(id>=ID && $11+0>=AL) print $1 }' "$PAF_A" | sort -u >"$outdir/ptA.ids"
			if [[ -s "$PAF_B" ]]; then
				awk -v ID="$identity_min" -v AL="$alen_min" 'BEGIN{FS=OFS="\t"} NF>=12{ id=($11>0?$10/$11:0); if(id>=ID && $11+0>=AL) print $1 }' "$PAF_B" | sort -u >"$outdir/ptB.ids"
				sort -u "$outdir/ptA.ids" "$outdir/ptB.ids" >"$PT_IDS"
			else
				mv "$outdir/ptA.ids" "$PT_IDS"
			fi
			printf "ident_min=%s\nalen_min=%d\n" "$identity_min" "$alen_min" >"$PT_VARS"
			: >"$PT_DIAG"
		fi
	else
		prof_start "pt_ident_threshold"
		if ((!DRY)); then
			python "$PY_PT_THRESH" \
				--paf "$PAF_A" ${PAF_B:+ "$PAF_B"} \
				--pt-ids "${pt_origin:-/dev/null}" \
				--mt-ids "${mt_origin:-/dev/null}" \
				--alen-min "$alen_min" --fpr "$fpr" --tpr "$tpr" \
				--diag "$PT_DIAG" --emit-pt-ids "$PT_IDS" >"$PT_VARS"
		fi
		prof_end
	fi

	note0 "1e) Remove PT reads → R1"
	ident_min_out="$identity_min"
	if [[ -s "$PT_VARS" ]]; then
		while IFS== read -r kv; do
			case "$kv" in ident_min=*) ident_min_out="${kv#ident_min=}" ;; alen_min=*) alen_min="${kv#alen_min=}" ;; esac
		done <"$PT_VARS"
	fi
	if ((!DRY)); then
		seqkit fx2tab -ni "$reads" | sort -u >"$MAP_DIR/all.ids"
		sort -u "$PT_IDS" >"$MAP_DIR/pt.ids.sorted"
		comm -23 "$MAP_DIR/all.ids" "$MAP_DIR/pt.ids.sorted" >"$outdir/keep.nonpt.ids"
		seqkit grep -f "$outdir/keep.nonpt.ids" "$reads" -o "$outdir/reads.nonpt.fq.gz"
	fi
	R1="$outdir/reads.nonpt.fq.gz"
fi
[[ -s "$R1" ]] || {
	echo "ERR missing R1 ($R1)" >&2
	exit 3
}

# ────────────────────────────────────────────────────────────────────
# Step 2: all-vs-all (organized) + scan QC (figures/tables)
# ────────────────────────────────────────────────────────────────────
ST1="$outdir/03-allvsall"
mkdir -p "$ST1"
PAFALL="$ST1/allvsall.paf"
OTSV_GLOBAL="$ST1/overlapness.tsv"
EDGES_GLOBAL="$ST1/edges.tsv.gz"

if _should_run 2; then
	note0 "Step2: try scan+stream+edges first; fallback to full ava-ont if needed"

	SCAN_DIR="$ST1/02-scan"
	REF_DIR="$ST1/03-refine"
	mkdir -p "$SCAN_DIR" "$REF_DIR"

	# 2a) determine scan parameters (autotune) and run scan or reuse
	note0 "2a) determine scan parameters (autotune)"
	AUTO_DIR="$ST1/01-scan_auto"
	mkdir -p "$AUTO_DIR"
	AUTO_VARS="$AUTO_DIR/vars"
	if [[ "$overlap_mode" == "scan" ]]; then
		if ((!DRY)); then
			python "$AUTOSCANPY" --reads "$R1" --threads "$threads" \
				--olpy "$OLPY" --minimap2 minimap2 --outdir "$ST1" >"$AUTO_VARS" || true
		fi
	else
		>"$AUTO_VARS"
	fi

	# defaults
	scan_k="$scan_k"
	scan_w="$scan_w"
	scan_N="$scan_N"
	scan_mask="$scan_mask"
	scan_minocc="$scan_minocc"
	min_olen_scan=800
	min_ident_scan=0.82
	w_floor_scan=0.08
	scan_keep_frac_aut="$scan_keep_frac"
	topk_per_q_aut=0
	scan_olap_tsv=""

	if [[ -s "$AUTO_VARS" ]]; then
		while IFS== read -r kv; do
			case "$kv" in
			scan_k=*) scan_k="${kv#scan_k=}" ;;
			scan_w=*) scan_w="${kv#scan_w=}" ;;
			scan_N=*) scan_N="${kv#scan_N=}" ;;
			scan_secondary=*) : ;;
			scan_mask=*) scan_mask="${kv#scan_mask=}" ;;
			scan_minocc=*) scan_minocc="${kv#scan_minocc=}" ;;
			scan_min_olen=*) min_olen_scan="${kv#scan_min_olen=}" ;;
			scan_min_ident=*) min_ident_scan="${kv#scan_min_ident=}" ;;
			scan_w_floor=*) w_floor_scan="${kv#scan_w_floor=}" ;;
			scan_keep_frac=*) scan_keep_frac_aut="${kv#scan_keep_frac=}" ;;
			topk_per_q=*) topk_per_q_aut="${kv#topk_per_q=}" ;;
			scan_overlap_tsv=*) scan_olap_tsv="${kv#scan_overlap_tsv=}" ;;
			esac
		done <"$AUTO_VARS"

		# run scan if autotuner did not produce a TSV
		if ((!DRY)) && [[ -s "$scan_olap_tsv" ]]; then
			note "2a) reuse autotuned scan TSV: $scan_olap_tsv"
			cp -f "$scan_olap_tsv" "$SCAN_DIR/scan.overlapness.tsv"
		else
			note "2a) run scan: k=$scan_k w=$scan_w N=$scan_N mask=$scan_mask occ=$scan_minocc ; gates: olen=$min_olen_scan ident=$min_ident_scan wf=$w_floor_scan"
			prof_start "scan"
			if ((!DRY)); then
				minimap2 -t "$threads" -x ava-ont \
					-k "$scan_k" -w "$scan_w" -N "$scan_N" \
					--secondary=no --mask-level "$scan_mask" --min-occ-floor "$scan_minocc" \
					"$R1" "$R1" |
					{ ((topk_per_q_aut > 0)) && python "$TOPKPY" "$topk_per_q_aut" || cat; } |
					python "$OLPY" - \
						--min_olen "$min_olen_scan" --min_ident "$min_ident_scan" --w_floor "$w_floor_scan" \
						>"$SCAN_DIR/scan.overlapness.tsv"
			fi
			prof_end
		fi

		# shortlist if we have scan TSV; else fallback later
		if ((!DRY)) && [[ -s "$SCAN_DIR/scan.overlapness.tsv" ]]; then
			note "2b) shortlist by cum-wdegree 80% rule → scan_keep_frac=${scan_keep_frac_aut}"
			awk 'NR>1{print $1"\t"$3}' "$SCAN_DIR/scan.overlapness.tsv" |
				sort -k2,2nr |
				awk -v f="$scan_keep_frac_aut" '{a[NR]=$1} END{lim=int(NR*f); for(i=1;i<=lim;i++) print a[i]}' \
					>"$SCAN_DIR/shortlist.ids"
			seqkit grep -f "$SCAN_DIR/shortlist.ids" "$R1" -o "$SCAN_DIR/R1.short.fq.gz"
		fi

		# 2b) refine streamed → edges + global overlapness
		note0 "2c) refine streamed → edges + overlapness"
		prof_start "refine"
		if ((!DRY)) && [[ -s "$SCAN_DIR/R1.short.fq.gz" ]]; then
			minimap2 -t "$threads" -x ava-ont \
				-k"$refine_k" -w"$refine_w" --secondary=yes -N "$refine_N" \
				--mask-level "$refine_mask" --min-occ-floor "$refine_minocc" \
				"$SCAN_DIR/R1.short.fq.gz" "$SCAN_DIR/R1.short.fq.gz" |
				python "$EDGPY" \
					--min-olen "$min_olen" --min-ident "$min_ident" --w-floor "$w_floor" \
					--topk-node "$topk_edges_per_node" \
					--edges "$ST1/edges.tsv" --overlapness "$OTSV_GLOBAL"
			((gzip_edges)) && gzip -f "$ST1/edges.tsv"
			EDGES_GLOBAL="$ST1/edges.tsv${gzip_edges:+.gz}"
		fi
		prof_end

	else
		# 2d) Fallback: full ava-ont → PAFALL ; autotune reducer until overlapness is non-empty, then QC
		note0 "2d) fallback: full ava-ont →  $PAFALL ; compute overlapness with autotune"
		if ((!DRY)); then
			minimap2 -x ava-ont -t "$threads" --secondary=yes -N 50 \
				--mask-level 0.50 "$R1" "$R1" >"$PAFALL"

			# Try reducer settings from strict → loose until nonempty & sane
			# (You can tweak this ladder if you like.)
			_tiers=(
				"1200 0.84 0.12"
				"1000 0.82 0.10"
				"800  0.80 0.08"
				"600  0.78 0.06"
			)

			OTSV_OK=0
			for trio in "${_tiers[@]}"; do
				set -- $trio
				mo="$1"
				mi="$2"
				wf="$3"
				note "2d) OLPY try: min_olen=$mo min_ident=$mi w_floor=$wf"
				python "$OLPY" "$PAFALL" --min_olen "$mo" --min_ident "$mi" --w_floor "$wf" >"$OTSV_GLOBAL" || true

				# Quick checks: nonempty (has data rows) and edges/read in a sane band
				if [[ -s "$OTSV_GLOBAL" ]]; then
					# rows with data?
					n_rows=$(awk 'NR>1{c++} END{print c+0}' "$OTSV_GLOBAL")
					if ((n_rows > 0)); then
						epr=$(awk 'NR>1{s+=$2;c++} END{if(c>0) printf "%.2f", s/(2*c); else print 0}' "$OTSV_GLOBAL")
						# Accept if edges/read is not pathological; adjust bounds if you prefer
						awk_ok=0
						awk_ok=$(
							awk -v e="$epr" 'BEGIN{exit ! (e>=2.0 && e<=40.0)}'
						)
						rc=$?
						if ((rc == 0)); then
							OTSV_OK=1
							note "2d) accepted reducer: min_olen=$mo min_ident=$mi w_floor=$wf (edges/read=$epr; rows=$n_rows)"
							break
						else
							note "2d) reducer produced odd density (edges/read=$epr); trying looser gate…"
						fi
					else
						note "2d) reducer produced empty overlapness; trying looser gate…"
					fi
				else
					note "2d) reducer wrote no file; trying looser gate…"
				fi
			done

			if ((OTSV_OK == 0)); then
				note "2d) WARNING: autotune failed to produce a good overlapness.tsv; keeping last attempt"
				# Last attempt already wrote $OTSV_GLOBAL (possibly sparse). Continue anyway.
			fi

			# 2c (moved here): QC on the FINAL overlapness (use OTSV_GLOBAL)
			note0 "2c) overlapness QC (polap-r-scan-autotune-qc.R on $OTSV_GLOBAL)"
			QC_DIR="$ST1/qc"
			mkdir -p "$QC_DIR"
			OVL_VARS="$QC_DIR/overlap_qc.vars"
			if [[ -s "$OTSV_GLOBAL" ]]; then
				Rscript --vanilla "$SCAN_QCR" \
					--input "$OTSV_GLOBAL" \
					--outdir "$QC_DIR" \
					--target 0.80 >"$OVL_VARS" || true

				if [[ -s "$OVL_VARS" ]]; then
					skf="NA"
					tkq="NA"
					while IFS== read -r kv; do
						case "$kv" in
						scan_keep_frac=*) skf="${kv#scan_keep_frac=}" ;;
						topk_per_q=*) tkq="${kv#topk_per_q=}" ;;
						esac
					done <"$OVL_VARS"
					note "2c) QC summary: scan_keep_frac_suggest=${skf} ; topk_per_q_suggest=${tkq}"
				fi
			else
				note "2c) SKIP QC: $OTSV_GLOBAL not found or empty"
			fi
		fi

	fi

	# 2e) Copy global overlapness into round_1 for Step 3
	RDIR="$outdir/04-round_1"
	mkdir -p "$RDIR"
	if ((!DRY)) && [[ -s "$OTSV_GLOBAL" ]]; then cp -f "$OTSV_GLOBAL" "$RDIR/overlapness.tsv"; fi

	# optional graph summary
	if ((!DRY)) && [[ -s "$EDGECOMP" && -s "$EDGES_GLOBAL" ]]; then
		COMP_DIR="$ST1/comp"
		mkdir -p "$COMP_DIR"
		python "$EDGECOMP" "$EDGES_GLOBAL" \
			--summary "$COMP_DIR/summary.tsv" \
			--sizes "$COMP_DIR/comp_sizes.tsv" \
			--membership "$COMP_DIR/node2comp.tsv" \
			--deg "$COMP_DIR/degree.tsv" \
			--giant-nodes "$COMP_DIR/giant_nodes.txt" \
			--giant-edges "$COMP_DIR/giant_edges.tsv" \
			--print || true
	fi
fi

# ────────────────────────────────────────────────────────────────────
# Step 3: BUSCO QC on 10% subsample, then selection (uses $RDIR/overlapness.tsv)
# ────────────────────────────────────────────────────────────────────
RDIR="$outdir/04-round_1"
mkdir -p "$RDIR"
if _should_run 3; then
	note0 "3a) BUSCO QC on a 10% length-stratified subsample"
	if [[ -n "$nprot" ]]; then
		SAMP_FQ="$RDIR/reads.nonpt.sample.fq.gz"
		((!DRY)) && seqkit sample -s "$seed" -p 0.10 "$R1" -o "$SAMP_FQ"
		((!DRY)) && miniprot -d "$RDIR/nonpt.sample.mpi" "$SAMP_FQ"
		((!DRY)) && miniprot -t "$threads" -S -N 3 --outc 0.4 \
			"$RDIR/nonpt.sample.mpi" "$nprot" >"$RDIR/nonpt.sample.busco.paf"
		((!DRY)) && awk 'BEGIN{FS=OFS="\t"} NF>=12 && $11+0>=150 {print $1}' \
			"$RDIR/nonpt.sample.busco.paf" | sort -u >"$RDIR/nuc.ids.sample"
	fi

	# 3b) selection (prefer BUSCO sample labels; fallback to --nuc-ids; else top-frac)
	note0 "3b) selection (prefer BUSCO sample labels)"
	SELECT_IDS="$RDIR/select_ids.txt"
	OTSV="$RDIR/overlapness.tsv"

	NUC_SAMPLE="$RDIR/nuc.ids.sample"
	NUC_FOR_THRESH=""
	if [[ -s "$NUC_SAMPLE" ]]; then
		NUC_FOR_THRESH="$NUC_SAMPLE"
	elif [[ -n "$nuc_ids_opt" && -s "$nuc_ids_opt" ]]; then
		NUC_FOR_THRESH="$nuc_ids_opt"
	fi

	if [[ -n "$NUC_FOR_THRESH" ]]; then
		note "Step3: nuclear-guided selection using $NUC_FOR_THRESH -> $SELECT_IDS"
		if ((!DRY)); then
			python "$THRESH_NUC_PY" "$OTSV" "$NUC_FOR_THRESH" \
				--mode fpr --fpr 0.01 --diag "$RDIR/threshold_from_nuclear.tsv" \
				>"$RDIR/nuc_thresh.vars"
			wdeg_min=0
			deg_min=0
			while IFS== read -r kv; do
				case "$kv" in
				wdeg_min=*) wdeg_min="${kv#wdeg_min=}" ;;
				deg_min=*) deg_min="${kv#deg_min=}" ;;
				esac
			done <"$RDIR/nuc_thresh.vars"
			awk -v W="$wdeg_min" -v D="$deg_min" 'BEGIN{FS=OFS="\t"} NR>1 && ($3+0)>=W && ($2+0)>=D {print $1}' "$OTSV" |
				sort -u >"$RDIR/organelle.ids"
			comm -23 <(sort -u "$RDIR/organelle.ids") <(sort -u "$NUC_FOR_THRESH") >"$SELECT_IDS"
		fi
	else
		note "Step3: select top-frac ($top_frac) by wdegree"
		((!DRY)) && python "$TOPPY" "$OTSV" --top_frac "$top_frac" >"$SELECT_IDS"
	fi
fi

# ────────────────────────────────────────────────────────────────────
# Step 4: assemble selected reads
# ────────────────────────────────────────────────────────────────────
SEEDS_ROUND=""
if _should_run 4; then
	SELECT_IDS="$RDIR/select_ids.txt"
	if [[ "$assembler" == "miniasm" ]]; then
		TOPFA="$RDIR/top_reads.fa.gz"
		note0 "4a) extract selected reads → $TOPFA"
		((!DRY)) && seqkit fq2fa "$R1" | seqkit grep -f "$SELECT_IDS" -o "$TOPFA"
		GFA="$RDIR/miniasm.gfa"
		if [[ "$overlap_mode" != "scan+stream+edges" ]]; then
			note0 "4b) DEFAULT MODE: filter full PAF to selected overlaps → SUBPAF"
			SUBPAF="$RDIR/top_overlaps.paf.gz"
			((!DRY)) && python "$FILTPY" "$PAFALL" "$SELECT_IDS" -o "$SUBPAF"
			((!DRY)) && miniasm -f "$TOPFA" <(zcat -f "$SUBPAF") >"$GFA"
		else
			note0 "4b) STREAMED MODE: recompute overlaps among selected reads → SELPAF"
			SELPAF="$RDIR/selected_allvsall.paf.gz"
			((!DRY)) && minimap2 -x ava-ont -t "$threads" --secondary=yes -N 30 \
				--mask-level 0.60 --min-occ-floor 10 \
				"$TOPFA" "$TOPFA" | gzip -1 >"$SELPAF"
			((!DRY)) && miniasm -f "$TOPFA" <(zcat -f "$SELPAF") >"$GFA"
		fi
		note0 "4c) extract contigs from GFA → seeds"
		SEEDS_ROUND="$RDIR/m_seeds_raw.fa"
		((!DRY)) && awk '/^S/{print ">"$2"\n"$3}' "$GFA" >"$SEEDS_ROUND" || :
	else
		TOPFQ="$RDIR/top_reads.fq.gz"
		note0 "4b) raven path: extract selected reads (fq) → $TOPFQ"
		((!DRY)) && seqkit grep -f "$SELECT_IDS" "$R1" -o "$TOPFQ"
		SEEDS_ROUND="$RDIR/raven_contigs.fasta"
		note "raven --disable-polishing → $SEEDS_ROUND"
		((!DRY)) && raven --threads "$threads" --disable-polishing -o "$SEEDS_ROUND" "$TOPFQ"
	fi
	SEEDS_CUR="$SEEDS_ROUND"
fi

# Optional finisher (polap readassemble) using miniasm GFA
if _should_run 5; then
	note0 "5a) convert miniasm's gfa to flye-compatible gfa"
	contigger_dir="${RDIR}/30-contigger"
	mkdir -p "${contigger_dir}"
	sed 's/LN:i/dp:i/' "${RDIR}/miniasm.gfa" >"${contigger_dir}/graph_final.gfa"
	note0 "5b) polap readassemble using miniasm seeds"
	bash "${_POLAPLIB_DIR}/../polap.sh" readassemble annotated \
		-o "${outdir}" -i 04-round_1 -l "${reads}"
fi

_polap_lib_file-cleanup -d "${outdir}" -s 5M -a rm

# Finalize
if ((!DRY)); then
	FINAL_DIR="$(dirname "$SEEDS_CUR")"
	FINAL_SEEDS="$FINAL_DIR/m_seeds_final.fa"
	note "Finalize: cp $SEEDS_CUR → $FINAL_SEEDS"
	cp "$SEEDS_CUR" "$FINAL_SEEDS"
	note "Done. Final seeds: $FINAL_SEEDS"
else
	note "--dry finished (no commands executed)."
fi
