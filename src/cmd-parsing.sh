#!/bin/bash

config_cpu() {
	# Check the operating system type
	OS_TYPE=$(uname)

	# Determine the number of CPUs based on the OS
	if [ "$OS_TYPE" == "Linux" ]; then
		CPU_COUNT=$(nproc)
	elif [ "$OS_TYPE" == "Darwin" ]; then
		CPU_COUNT=$(sysctl -n hw.ncpu)
	else
		echo "Unsupported OS: $OS_TYPE"
		exit 1
	fi
}

config_cpu

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([outdir],[o],[output folder name],[o])
# ARG_OPTIONAL_SINGLE([number],[n],[number of sequences to analyze])
# ARG_OPTIONAL_SINGLE([threads],[t],[number of CPUs],[${CPU_COUNT}])
# ARG_OPTIONAL_BOOLEAN([test])
# ARG_POSITIONAL_MULTI([menu],[EBP menu],[4],[subcommand],[snumber],[infile],[outfile])
# ARG_VERSION([echo $0 v0.1.1])
# ARG_VERBOSE([])
# ARG_DEFAULTS_POS([])
# ARG_HELP([EBP.])
# DEFINE_SCRIPT_DIR([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

begins_with_short_option() {
	local first_option all_short_options='ontvh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_menu=("subcommand" "snumber" "infile" "outfile")
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_outdir="o"
_arg_number=
# _arg_threads="$(cat /proc/cpuinfo | grep -c processor)"
_arg_threads="${CPU_COUNT}"
_arg_test="off"
_arg_verbose=0

print_help() {
	printf '%s\n' "EBP - A phylogenomic pipeline"
	printf 'Usage: ebp <menu-1> [<menu-2>] [<menu-3>] [<menu-4>] [-o|--outdir <arg>] [-n|--number <arg>] [-t|--threads <arg>] [--(no-)test] [-v|--version] [--verbose] [-h|--help]\n' "$0"
	printf '\t%s\n' "menu-1: init, list, reset, make-commands, or clean"
	printf '\t%s\n' "<menu-1> help"
	printf '\t%s\n' "-o, --outdir: output folder name (default: 'o')"
	printf '\t%s\n' "-t, --threads: number of CPUs (default: ${CPU_COUNT})"
	printf '\t%s\n' "-v, --version: Prints version"
	printf '\t%s\n' "-h, --help: Prints help"
}

parse_commandline() {
	_positionals_count=0
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		-o | --outdir)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_outdir="$2"
			_arg_outdir_set=true
			shift
			;;
		--outdir=*)
			_arg_outdir="${_key##--outdir=}"
			;;
		-o*)
			_arg_outdir="${_key##-o}"
			;;
		-n | --number)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_number="$2"
			shift
			;;
		--number=*)
			_arg_number="${_key##--number=}"
			;;
		-n*)
			_arg_number="${_key##-n}"
			;;
		-t | --threads)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_arg_threads="$2"
			shift
			;;
		--threads=*)
			_arg_threads="${_key##--threads=}"
			;;
		-t*)
			_arg_threads="${_key##-t}"
			;;
		--no-test | --test)
			_arg_test="on"
			test "${1:0:5}" = "--no-" && _arg_test="off"
			;;
		-v | --version)
			echo $0 v0.1.1
			exit 0
			;;
		-v*)
			echo $0 v0.1.1
			exit 0
			;;
		--verbose)
			_arg_verbose=$((_arg_verbose + 1))
			;;
		-h | --help)
			print_help
			exit 0
			;;
		-h*)
			print_help
			exit 0
			;;
		*)
			_last_positional="$1"
			_positionals+=("$_last_positional")
			_positionals_count=$((_positionals_count + 1))
			;;
		esac
		shift
	done
}

handle_passed_args_count() {
	test "${_positionals_count}" -le 4 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 4, but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
	local _positional_name _shift_for=$1
	_positional_names="_arg_menu[0] _arg_menu[1] _arg_menu[2] _arg_menu[3] "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}; do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}

### END OF CODE GENERATED BY Argbash (sortof) ### ])
