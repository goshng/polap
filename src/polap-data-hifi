#!/usr/bin/env bash
################################################################################
# This file is part of polap.
#
# polap is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# polap is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# polap. If not, see <https://www.gnu.org/licenses/>.
################################################################################

# polap and polap-data-cflye are release-versions with _POLAP_RELEASE to be 1.
: "${_POLAP_DEBUG:=0}"
export _POLAP_DEBUG
: "${_POLAP_RELEASE:=1}"
export _POLAP_RELEASE

# Data directories: we download data from the NCBI SRA database
# unless they exist in the following folders.
_local_host="thorne"
_media_dir="/media/h2/sra"
_media1_dir="/media/h1/sra"
_media2_dir="/media/h2/sra"

# TODO:
# [ ] A manual for proper understanding and execution of tasks.

# Default values for options
opt_c_arg="off"
opt_t_arg="t5"
opt_m_arg="off"
opt_v_flag=false
opt_y_flag=false
opt_f_flag=false
opt_e_arg=""

# Use man folder for a release-version
# otherwise use a custom folder.
if [[ -d "man" ]]; then
	_brg_default_target_dir="man/v0.5/figures"
else
	_brg_default_target_dir="$HOME/all/manuscript/polap-v0.5/figures"
fi

help_message=$(
	cat <<HEREDOC
usage: polap-data-hifi [-h] [-y] [-c CSV] [--version] COMMAND [-h] ...

polap-data-hifi is a tool for data analysis of plant plastid genome assembly
by annotating long reads with organelle genome sequences and selecting those
originating from organelle genomes.

options:
  -h, --help          Show this help message and exit.
  -y                  Enable -y flag to say YES to any question.
  -v                  Enable verbose mode.
  -f                  Enable -f flag to say YES to profiling.
  -c <arg>            Set value for -c option (default: ${opt_c_arg})
  -t <arg>            Set value for -t option (default: ${opt_t_arg})
  -m <arg>            Set value for -m option figure folder (default: ${_brg_default_target_dir})
  -e <ame>            Call <name>_genus_species function and exit.
  --version           Show the polap-data-dflye version number and exit.

commands:
  The following commands are available for the script.

  COMMAND
    install            Install a list of tools to some conda environments.
    setup              Setup installed tools.
    update             Update tools.
    list (search)      List tools.
    run                Run an executable in a conda environment.
    remove (uninstall) Remove a list of tools.
    build (assemble)   Build plastid or mitochondrial genomes.
    download (mkdir)   Download data.
    config             Config view, add, etc.
    benchmark          Benchmark GetOrganelle, ptGAUL, PMAT, TIPPo, and Oatk.
    clean (delete, rm) Remove unnecessary folders.
    get                Get results.
    archive            Archive results.
    man                Generate reports.
    help               Print help message for commands and others.
    print-help-all     List all help messages.
HEREDOC
)

# Tesing groups of datasets
declare -a Sall

Smain=(
	'Eucalyptus_pauciflora'
)

# Data28
Stest=(
	Test_species
	Taxon_genus
)

Ssome=(
	Anthoceros_agrestis
	Arabidopsis_thaliana
	Canavalia_ensiformis
	Cinchona_pubescens
	Codonopsis_lanceolata
	Cucumis_sativus_var_hardwickii
	Dunaliella_tertiolecta
	Eucalyptus_pauciflora
	Euonymus_alatus
	Gossypium_herbaceum
	Juncus_effusus
	Leiosporoceros_dussii
	Macadamia_jansenii
	Notothylas_orbicularis
	Ophrys_lutea
	Oryza_rufipogon
	Phaeomegaceros_chiloensis
	Populus_x_sibirica
	Prunus_mandshurica
	Solanum_lycopersicum
	Spirodela_polyrhiza
	Vaccinium_vitis_idaea
	Vitis_vinifera
)

# OTHER STUFF GENERATED BY Argbash
_polap_script_bin_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}
_POLAPLIB_DIR="${_polap_script_bin_dir}/polaplib"

# Target version is 0.5.2
source "${_POLAPLIB_DIR}/polap-lib-version.sh"
source "${_POLAPLIB_DIR}/polap-lib-conda.sh"
source "${_POLAPLIB_DIR}/polap-lib-timing.sh"
source "${_POLAPLIB_DIR}/polap-lib-unit.sh"
source "${_POLAPLIB_DIR}/polap-lib-array.sh"
source "${_POLAPLIB_DIR}/polap-lib-number.sh"
source "${_POLAPLIB_DIR}/polap-lib-data.sh"
source "${_POLAPLIB_DIR}/polap-lib-file.sh"
source "${_POLAPLIB_DIR}/polap-lib-process.sh"
source "${_POLAPLIB_DIR}/polap-lib-extract.sh"
source "${_POLAPLIB_DIR}/polap-lib-csv.sh"
source <(echo 'export PATH="$PWD/bin:$PATH"')
source <(echo 'export QT_QPA_PLATFORM=minimal')
# source <(echo 'export QT_QPA_PLATFORM=offscreen')
# echo "export QT_QPA_PLATFORM=offscreen"

# NOTE: globaly defined in polap-lib-data.sh
#
# _polap_data_csv="$(basename "$0" .sh).csv"
# _polap_data_data="$(basename "$0" .sh).data"
# _polap_data_txt="$(basename "$0" .sh).txt"

setup-csv_genus_species() {
	local _brg_data="${1:-${_polap_data_csv}}"
	local _brg_species_tsv="${2:-csv}"

	local _data=$(
		cat <<HEREDOC
species,long,short
Anthoceros_agrestis,SRR10190639,SRR10250248
Arabidopsis_thaliana,ERR2173373,ERR2173372
Canavalia_ensiformis,SRR18714551,SRR18714547
Cinchona_pubescens,SRR20784020,SRR20784021
Codonopsis_lanceolata,SRR11585869,SRR11585868
Cucumis_sativus_var_hardwickii,SRR28091980,SRR28091977
Dioscorea_japonica,SRR16108312,SRR16108386
Dunaliella_tertiolecta,SRR22857204,SRR22857205
Eucalyptus_pauciflora,SRR7153095,SRR7161123
Euonymus_alatus,SRR16133411,SRR16122871
Gossypium_herbaceum,SRR17224483,SRR17211914
Juncus_effusus,SRR14298760,SRR14298746
Juncus_inflexus,SRR14298751,SRR14298745
Juncus_roemerianus,SRR21976090,SRR21976092
Juncus_validus,SRR21976089,SRR21976091
Leiosporoceros_dussii,SRR25387688,SRR25387689
Macadamia_jansenii,SRR11191910,SRR11191912
Musa_acuminata_subsp_malaccensis,ERR5455028,ERR3606950
Notothylas_orbicularis,SRR25405055,SRR25405056
Ophrys_lutea,ERR5167480,ERR5303530
Oryza_rufipogon,SRR12104676,SRR12102351
Phaeomegaceros_chiloensis,SRR25430413,SRR25430414
Populus_x_sibirica,SRR15146668,SRR12963707
Prunus_mandshurica,ERR4656977,ERR4656978
Solanum_lycopersicum,SRR11073833,SRR11205474
Spirodela_polyrhiza,SRR11472010,SRR11472009
Vaccinium_vitis-idaea,SRR25468450,SRR25477290
Vitis_vinifera,SRR26163227,SRR26163231
HEREDOC
	)

	local confirm="no"
	if [[ "${_brg_species_tsv}" == "csv" ]]; then
		if [[ -s "${_brg_data}" ]]; then
			read -p "Do you want to replace ${_brg_data}? (y/N): " confirm
		fi

		if [[ "${confirm,,}" == "yes" || "${confirm,,}" == "y" ]]; then
			# Write the output to CSV
			{
				# Print the header
				echo species,taxon,long,short,host,random,down,memory,p,n,r,alpha,delta,ptgaul,pmat,tippo,oatk,ref,dummy,status

				local seed=101
				# Skip the header and read each line
				while IFS=',' read -r species long short; do
					# Skip header
					if [[ "$species" == "species" ]]; then
						continue
					fi
					echo "$species,$species,$long,$short,hostname,$seed,10,16,10,10,5,1.0,0.25,160000,0.1,ont,30,NA,dummy,done"
					seed=$((seed + 2))
				done <<<"$_data"
			} >"${_brg_data}"
			_log_echo "A new CSV: ${_brg_data}"
		else
			echo "Canceled: A new CSV: ${_brg_data}"
		fi
	elif [[ "${_brg_species_tsv}" == "tsv" ]]; then
		{
			while IFS=',' read -r species long short; do
				# Skip header
				if [[ "$species" == "species" ]]; then
					continue
				fi
				printf "%s\t%s\t%s\n" "$species" "$long" "$short"
			done <<<"$_data"
		} >"${_brg_data}"
		_log_echo "A new TSV: ${_brg_data}"
	fi
}

################################################################################
# main command arguments used before a subcommand
#
print_help() {
	echo "${help_message}"
}

print_version() {
	_polap_lib_version
	echo "polap-data-hifi ${_polap_version}"
}

print_version_git_message() {
	# curl -s https://api.github.com/repos/goshng/polap/commits/${_polap_git_hash_version} |
	wget -qO- https://api.github.com/repos/goshng/polap/commits/${_polap_git_hash_version} |
		awk '
  /"date":/ && !seen++ { sub(/^[[:space:]]*"date": "/, ""); sub(/".*/, ""); date=$0 }
  /"message":/ && !msg++ { sub(/^[[:space:]]*"message": "/, ""); sub(/",?$/, ""); msg=$0 }
  END { print "Date: " date "\nMessage: " msg }
'
}

# Parse options
while [[ "${1-}" == -* ]]; do
	case "$1" in
	-c)
		shift
		if [[ -z "${1-}" || "${1-}" == -* ]]; then
			echo "Error: -c requires an argument"
			exit 1
		fi
		opt_c_arg="$1"
		;;
	-t)
		shift
		if [[ -z "${1-}" || "${1-}" == -* ]]; then
			echo "Error: -t requires an argument"
			exit 1
		fi
		opt_t_arg="$1"
		;;
	-m)
		shift
		if [[ -z "${1-}" || "${1-}" == -* ]]; then
			echo "Error: -t requires an argument"
			exit 1
		fi
		opt_m_arg="$1"
		;;
	-y)
		opt_y_flag=true
		;;
	-v)
		opt_v_flag=true
		;;
	-f)
		opt_f_flag=true
		;;
	-e)
		shift
		if [[ -z "${1-}" || "${1-}" == -* ]]; then
			echo "Error: -e requires an argument"
			exit 1
		fi
		opt_e_arg="$1"
		func_name="${opt_e_arg}_genus_species"
		if declare -f "$func_name" >/dev/null; then
			"$func_name"
			exit 0
		else
			echo "Error: function '$func_name' not found"
			exit 1
		fi
		;;
	--version)
		print_version
		print_version_git_message
		exit 0
		;;
	-h | --help)
		print_help
		exit 0
		;;
	--) # End of options
		shift
		break
		;;
	-*)
		echo "Unknown option: $1"
		exit 1
		;;
	esac
	shift || break
done

if [[ "${opt_m_arg}" != "off" ]]; then
	_brg_default_target_dir="${opt_m_arg}"
fi

if [[ "${opt_c_arg}" != "off" ]]; then
	csv_file="${opt_c_arg}"
fi

# Input parameter
subcmd1="${1:-help}"

if [[ "${subcmd1}" == "search" ]]; then
	subcmd1="list"
fi

# TODO: depending on _POLAP_RELEASE, we could use polap
# but then polap needs to be the current conda env, which is not.
_polap_cmd="${_polap_script_bin_dir}/polap.sh"
if [[ "${_POLAP_RELEASE}" == "1" ]]; then
	_polap_cmd="${_polap_script_bin_dir}/polap"
else
	_polap_cmd="${_polap_script_bin_dir}/polap.sh"
fi

_brg_adir="${opt_t_arg:-t5}"

################################################################################
# BEGIN: Help messages
x_help_message_example=$(
	cat <<HEREDOC

  polap-data-hifi run hifi-oga Lolium_perenne

  pl blast-pt -l DRR503528.fastq

  # pacbio hifi assembly - clr and raw are not working yet
  p4 download sra DRR503528
  pl init
  p4 sample-fastq DRR503528.fastq o 1

  pl fastq-inspect DRR503528.fastq DRR503528.fastq.txt
  pl total-length-long -l DRR503528.fastq
  pl find-genome-size-for-pacbio -l DRR503528.fastq
  pl reduce-data -l DRR503528.fastq
  pl flye1 --pacbio-hifi --blast --blast-mt 0.0001 --blast-pt 0.0001
  pl annotate
  pl seeds
  pl test-reads -s 3000,12000,10 --pacbio-hifi
  pl assemble2 --pacbio-hifi

  sequence type: --pacbio-hifi --pacbio-clr --nano-raw --nano-hq
  pl simulate hifi -g 10000000 -p plastid_ref.fasta -m mito_ref.fasta
  pl count --pacbio-hifi -l l.fq <- step 0 or no need to do it
  pl count --nano-raw -l SRR7153095.fastq -o Eucalyptus_pauciflora-5
  pl filter depth --pacbio-hifi -l o/reads.fq -c 50 (not workding for ONT: memory issue)
  pl filter pca -l o/reads.fq -k 2 <- step 1
  use interactive_select_points_singleiview.R
  pl filter name -l o/reads.fq selected.tsv

then, assemble1, assemble2, ...
or assemble

  p5 run-hifi-wga Glebionis_segetum

  p5 run-pca-count Glebionis_segetum 0 0 0 <- range default
  p5 run-pca-count-filter Glebionis_segetum 0 0 0 <- range default range1 x-start:x-end:x-cut
  p5 run-pca-kmer Glebionis_segetum 0 0 6 <- k default
  p5 run-pca-oga Glebionis_segetum
  p5 run-pca-wga Glebionis_segetum

  ONT case:
  p5 data-long Vitis_vinifera [0]
  copy short_expected_genme_size.txt
  p5 data-downsample-long Vitis_vinifera [0 [0.1]] <- 0.1x downsample
  p5 run-pca-ont-kmer Vitis_vinifera 0 knum:5
  p5 run-pca-ont-pt Vitis_vinifera 0 knum:5 umap

HEREDOC
)

help_message_example=$(
	cat <<HEREDOC
  local:
  p5 benchmark-copy Vitis_vinifera
  p5 sync Vitis_vinifera 0 --push
  remote:
  p5 benchmark-skip Vitis_vinifera
  p5 -f benchmark Vitis_vinifera
  local:
  p5 sync Vitis_vinifera 0 --pull
  man:
  p5 man table-benchmark some 0 
  p5 man figure-sheet some 0 mt bandage
HEREDOC
)

help_message_example_pca=$(
	cat <<HEREDOC
  polap-data-hifi run hifi-oga Lolium_perenne

  ONT case:
  p5 data-long Vitis_vinifera [0]
  copy short_expected_genme_size.txt
  p5 data-downsample-long Vitis_vinifera [0 [0.1]] <- 0.1x downsample
  p5 run-pca-ont-kmer Vitis_vinifera [index:0] <- index 0 => 0.1x, index 1 => 1x
  use RStudio to select reads
  p5 run-pca-ont-pt Vitis_vinifera 0 knum:5 umap
HEREDOC
)

help_message_example_mt=$(
	cat <<HEREDOC
  p5 data-downsample-long Vitis_vinifera 0 1000
  p5 run-annotate-ont-pt Vitis_vinifera [0]
  p5 run-assemble-ont-pt Vitis_vinifera [0]
HEREDOC
)

help_message_seeds=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

help_message_map=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

help_message_reads=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

help_message_dflye=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

help_message_directional=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

##### INSERT_HELP_HERE #####
help_message_main=$(
	cat <<HEREDOC

  main menu title
HEREDOC
)

help_message_man_init=$(
	cat <<HEREDOC

  Initialize the man folder.
  We use the man folder at the current directory to save tables and figures.
  Otherwise, they are save to $HOME/all/manuscript/polap-v0.4/figures
  Use -m option to change the figures folder.
HEREDOC
)

help_message_man_figure_benchmark=$(
	cat <<HEREDOC

  Create figures for benchmark results.
  outdir: some, test
  inum: number folder
  type: memory, time, time-nextdenovo
HEREDOC
)

help_message_man_pdf=$(
	cat <<HEREDOC

  Create a PDF report.
  outdir: test for Test_species
HEREDOC
)

help_message_man_figure_delta=$(
	cat <<HEREDOC

  Create a figure for the transient plot of alpha or the read coverage
  over a range of delta or the jump size.
HEREDOC
)

help_message_man_figure_alpha=$(
	cat <<HEREDOC

  Create a figure for the transient plot of alpha or the read coverage
  over a range of initial alpha values.
HEREDOC
)

help_message_man_table_data=$(
	cat <<HEREDOC

  Create a benchmark data table.
HEREDOC
)

help_message_man_figure_sheet_pmat=$(
	cat <<HEREDOC

  <outdir> [inum:0|N] [bandage|no-bandage] [csv:sheet_pmat.csv] [txt:sheet_pmat.txt]

  outdir: species folder, all, some, test
  inum: number 0 1 2 4
  bandage: bandage to draw figure files or no-bandage
  csv: output CSV file
  txt: description of the supporting material
HEREDOC
)

help_message_man_figure_sheet_tippo=$(
	cat <<HEREDOC

  <outdir> [inum:0|N] [bandage|no-bandage] [csv:sheet_pmat.csv] [txt:sheet_pmat.txt]

  outdir: species folder, all, some, test
  inum: number 0 1 2 4
  bandage: bandage to draw figure files or no-bandage
  csv: output CSV file
  txt: description of the supporting material
HEREDOC
)

help_message_man_figure_sheet_oatk=$(
	cat <<HEREDOC

  <outdir> [inum:0|N] [bandage|no-bandage] [csv:sheet_pmat.csv] [txt:sheet_pmat.txt]

  outdir: species folder, all, some, test
  inum: number 0 1 2 4
  bandage: bandage to draw figure files or no-bandage
  csv: output CSV file
  txt: description of the supporting material
HEREDOC
)

help_message_man_figure_sheet_polap=$(
	cat <<HEREDOC

  <outdir> [inum:0|N] [bandage|no-bandage] [csv:sheet_polap.csv] [txt:sheet_polap.txt]

  outdir: species folder, all, some, test
  inum: number 0 1 2 4
  bandage: bandage to draw figure files or no-bandage
  csv: output CSV file
  txt: description of the supporting material
HEREDOC
)

help_message_man_figure_sheet=$(
	cat <<HEREDOC

  outdir: all or species folder
  inum: number
  bandage: on or off
  csv: sheet_benchmark.csv
HEREDOC
)

help_message_man_table_polap_disassemble=$(
	cat <<HEREDOC

  outdir: all, some, species folder
  inum: number
HEREDOC
)

help_message_man_table_benchmark=$(
	cat <<HEREDOC

  outdir: some, test
  inum: number folder
  type: data, memory, time, polap
HEREDOC
)

help_message_kickstart=$(
	cat <<HEREDOC

Log in a terminal of a Linux computer:
  cd
  mkdir -p all/polap/hifi1
  cd all/polap/hifi1
  rm -rf polap
  git clone https://github.com/goshng/polap.git
  bash polap/src/polap-data-v5.sh install conda
Log out and back in the same terminal:
  cd
  cd all/polap/hifi1
  source ~/miniconda3/bin/activate
  bash polap/src/polap-data-v5.sh setup conda
  bash polap/src/polap-data-v5.sh -y install all
  bash polap/src/polap-data-v5.sh setup polap
  bash polap/src/polap-data-v5.sh setup pmat
Log out and back into the terminal:
  cd
  cd all/polap/hifi1
  source ~/miniconda3/bin/activate
  p5 -y mkdir-all
  p5 -y benchmark <outdir>
HEREDOC
)

help_message_setup_csv=$(
	cat <<HEREDOC

  To create a species.tsv
  e.g., setup csv species.tsv tsv

  Create a csv config file.
  csv: output file - default csv config file or tsv file
  tsv: csv for data.csv or tsv for species.tsv
HEREDOC
)

help_message_test=$(
	cat <<HEREDOC

  Test the code.
HEREDOC
)

_v1_help_message_get=$(
	cat <<HEREDOC

  Archive files are named in either one of these two forms:
  Eucalyptus_pauciflora-a.tar.gz or Eucalyptus_pauciflora-a-0.tar.gz
  If you confirm by responding with 'yes', this action will replace
  the existing folder named Eucalyptus_pauciflora with the extracted folder.
  If you respond with 'add', it will replace only the <inum> folder in the folder
  named Eucalyptus_pauciflora with the extracted folder's <inum> folder.
  If <inum> is -1, it will look for Eucalyptus_pauciflora-a.tar.gz.
  Ottherwise, it will use Eucalyptus_pauciflora-a-<inum>.tar.gz.
  So, using -1 of <inum>, you will replace the Eucalyptus_pauciflora folder.

  If option confirm is off, then it will get your response. You can skip the
  confirmation step by setting it to yes or add.
HEREDOC
)

help_message_benchmark=$(
	cat <<HEREDOC

  outdir1, outdir2, ...: some, test, or species_name 
  Option -y is always turned on.

  The main batch command does the followings.
  - get the data
  - fetch reference from NCBI
  - GetOrganelle assembly
  - msbwt short-read polishing
  - ptGAUL assembly
  - ptGAUL's polishing
  - NextDenovo long-read data error correction
  - Oatk assembly with the error-corrected long-read data
  - TIPPo assembly with the error-corrected long-read data
  - PMAT assembly with the error-corrected long-read data
  - Polap annotate and assembly

  See Also:
  benchmark-command
  mkdir-all
HEREDOC
)

help_message_benchmark_command=$(
	cat <<HEREDOC

  The main batch command does the following polap subcommands:
  polap-analysis-data <outdir>
  data-long <outdir>
  data-short <outdir>
  download ptdna <outdir>
  download mtdna <outdir>
  run getorganelle <outdir> [index]
  run msbwt <outdir> [index]
  run ptgaul <outdir> [index]
  run extract-ptdna-ptgaul <outdir> [index]
  run estimate-genomesize <outdir> [index]
  run nextdenovo-polish <outdir> [index]
  run oatk <outdir> [index]
  run tippo <outdir> [index]
  run pmat <outdir> [index]
  run polap-annotate-ont <outdir> <index>
  run polap-assemble-ont <outdir> <index>
HEREDOC
)

help_message_benchmark_copy=$(
	cat <<HEREDOC

  Copy cflye1/t1 to hifi1/t5
HEREDOC
)

help_message_archive=$(
	cat <<HEREDOC

  Archive the result.
  <inum>: -1 is default, meaning archiving it with the file name of -a.tar.gz
  <inum>: 0, meaning archiving it with the file name of -a-0.tar.gz
  <max-filesize>: 1M

  Note: t0 is not archived.
HEREDOC
)
#
# END: Help messages
################################################################################

################################################################################
# Read CSV config
read_csv_config_dynamic
# print_species_field_summary --add-field=fruit=banana --fields=short,fruit --values
# print_species_field_summary --add-field=fruit=banana --values

# Create all keys
keys_array=($(for key in "${!_long[@]}"; do echo "$key"; done | sort))
Skeys=("${keys_array[@]}")

# Command arguments
_arg1=${1:-arg1}
# Check if the species folder is provided
if [[ "${_arg1}" == "arg1" ]]; then
	echo "${help_message}"
	exit 1
fi

_arg2=${2:-arg2}
if [[ "${_arg2}" != "arg2" ]]; then
	_arg2="${2%/}"
fi

_arg3=${3:-arg3}
_arg4=${4:-arg4}
_arg5=${5:-arg5}
_arg6=${6:-arg6}
_arg7=${7:-arg7}
_arg8=${8:-arg8}
_arg9=${9:-arg9}
_arg10=${10:-arg10}

################################################################################
# Part of genus_species
#
test_genus_species_for() {
	local _brg_outdir="${1:-all}"
	local _brg_sindex="${2:-0}"
	local _brg_adir _brg_title _brg_target _brg_rundir _brg_outdir_i
	local _timing_txt _stdout_txt _memlog_file _summary_file

	brg_common_setup \
		_brg_outdir _brg_sindex _brg_adir _brg_title \
		_brg_target _brg_rundir _brg_outdir_i \
		_timing_txt _stdout_txt _memlog_file _summary_file

	if [[ -v _long["$_brg_target"] ]]; then
		local long_sra="${_long["$_brg_target"]}"
	else
		echo "Error: ${_brg_target} because it is not in the CSV."
		return
	fi
	local short_sra="${_short["$_brg_target"]}"

	echo "Key: $_brg_target"
	if [[ "${_POLAP_RELEASE}" == "0" ]]; then
		echo "  long_sra: ${long_sra}"
		echo "  short_sra: ${short_sra}"
	fi
}

test_genus_species() {
	local _brg_outdir="${1:-some}"
	local _brg_sindex="${2:-0}"
	local _brg_adir _brg_title _brg_target _brg_rundir _brg_outdir_i
	local _timing_txt _stdout_txt _memlog_file _summary_file

	brg_common_setup \
		_brg_outdir _brg_sindex _brg_adir _brg_title \
		_brg_target _brg_rundir _brg_outdir_i \
		_timing_txt _stdout_txt _memlog_file _summary_file

	if [[ "${_brg_outdir}" == "all" ]]; then
		for _v1 in "${Sall[@]}"; do
			test_genus_species_for "${_v1}" "${_brg_sindex}"
		done
	elif [[ "${_brg_outdir}" == "some" ]]; then
		for _v1 in "${Ssome[@]}"; do
			test_genus_species_for "${_v1}" "${_brg_sindex}"
		done
	elif [[ "${_brg_outdir}" == "test" ]]; then
		for _v1 in "${Stest[@]}"; do
			test_genus_species_for "${_v1}" "${_brg_sindex}"
		done
	elif [[ "${_brg_outdir}" == "each" ]]; then
		for key in "${Skeys[@]}"; do
			_brg_outdir="${key%-*}"
			_brg_inum="${key##*-}"
			test_genus_species_for "${_brg_outdir}" "${_brg_inum}"
		done
	else
		test_genus_species_for "$@"
	fi
}

##### INSERT_FUNCTION_HERE #####
main_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	if [[ "${_brg_outdir}" == "all" ]]; then
		for _v1 in "${Sall[@]}"; do
			echo main_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "each" ]]; then
		for _v1 in "${Sall[@]}"; do
			echo main_genus_species_for "${_v1}" "${@:2}"
		done
	else
		echo main_genus_species_for "$@"
	fi
}

# whole-genome assembly
# assemble1
# mt.contig.name-1
#
# The first two steps are from polap v0.3.7.3
# wga
# oga
# dga
#
# Lolium_perenne o/0 <- wga
# Lolium_perenne o/1 <- oga
# Lolium_perenne o/2 <- dga

# Step 1
# Create directional seed contigs:
# mt.contig.name has one contiguous sequence per line using direction as well
#
# /home/goshng/all/polap/dflye/Lolium_perenne/o/1/mt.contig.name-2
# edge_5-,edge_11+,edge_12+,edge_8+,edge_4+,edge_8-,edge_6-,edge_11-,edge_10+,edge_9-
# -> each line becomes contig_<number>
#
# /home/goshng/all/polap/dflye1/Lolium_perenne/o/2
# └── 01-contig
#     ├── contig1.fa
#     ├── contig1.name.txt
#     ├── contig2.fa
#     └── contig2.name.txt
#
# contig1.name.txt
# ----------------
# contig_1
#
# contig2.name.txt: edges with only one direction; edge_11 has +/- so it is excluded
# ----------------
# edge_9-
# edge_6-
# edge_5-
# edge_4+
# edge_12+
# edge_10+
#
seed_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	# mt.contig.name-1 with plus/minus signed edge_<number>[+-]
	${_polap_cmd} directional-prepare-seeds \
		-o ${_brg_outdir}/o \
		-i 1 -j 2
}

# Step 2
# Map the long-read data on the seed contigs
#
# input:
# o/lk.fq.gz
# o/nk.fq.gz
# seed contigs
#
# output:
# /home/goshng/all/polap/dflye1/Lolium_perenne/o/2
# └── 01-contig
#     ├── contig1.paf
#     ├── contig1.tab
#     ├── contig1_total_length.txt
#     ├── contig2.paf
#     └── contig2.tab
#
map_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	# o/lk.fq.gz
	# o/nk.fq.gz
	${_polap_cmd} directional-map-reads \
		-o ${_brg_outdir}/o \
		-i 1 -j 2
}

# Step 3
# Select reads mapped on the reference and subsample
# -s option for filtering long-read data? not sure.
#
# /home/goshng/all/polap/dflye1/Lolium_perenne/o/2
# └── 01-contig
#     ├── contig1_total_length.txt
#     ├── ptgaul.txt
# ├── 02-reads
# │   └── ptgaul
# │       ├── 0
# │       │   ├── ptgaul.contig1.forward.names.txt
# │       │   └── ptgaul.contig.forward.names.txt
# │       ├── 1
# │       │   ├── ptgaul.contig1.forward.names.txt
# │       │   └── ptgaul.contig.forward.names.txt
# │       └── 2
# │           ├── ptgaul.contig1.forward.names.txt
# │           └── ptgaul.contig.forward.names.txt
# ├── 03-seeds
# │   └── ptgaul
# │       ├── 0.fq.gz
# │       ├── 1.fq.gz
# │       └── 2.fq.gz
# ├── 04-subsample
# │   └── ptgaul
# │       ├── 0.fq.gz
# │       ├── 1.fq.gz
# │       └── 2.fq.gz
#
#
# contig1_total_length.txt <- length of sequences in 01-contig/contig1.fa
# ptgaul.txt <- values to use for read selection
# 02-reads
# 03-seeds
# 04-subsample
# 05-flye
# 06-summary
# 07-plot
#
# STOPPED HERE
select_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	# -s 3000,6000,2
	# -s 3000,27000,9
	# -s 30000,42000,5
	${_polap_cmd} directional-select-reads \
		-o ${_brg_outdir}/o \
		-i 1 -j 2 \
		-s 33000,45000,5
}

# Assembly using dflye
#
# The following produces a circular graph of size 677 kb.
# /home/goshng/all/polap/dflye1/Lolium_perenne/o/2/05-flye/ptgaul/2/30-contigger/graph_final.gfa
# -s 39k produces a circular graph.
#
# Two stages:
# 1. we need to assemble using flye without directional reads but across a range of reads.
# 2. we pick a seed and then using a similar size selection to build.
# Or, we had a candidate with 39k of -w option.
# The directional assembly was also done using 39k.
#
# NOTE: directional-flye-reads: used to be test-reads
# what is directional-select-reads? -> We have only select and subsample.
# directional-select-reads: still from test-reads.
# test-reads is very complicated function.
# directional-select-reads: only select and subsample
# directional-flye-reads: called after directional-select-reads.
# then
# runs dflye_genus_species.
#
# NOTE: test-reads -> directional-reads -> then 4 functions:
# directional-prepare-reads
# directional-map-reads
# directional-select-reads -> need range
# directional-flye-reads -> need range
# dflye_genus_species
#
# NOTE: assemble2 does not have -s option, which is used by test-reads.
# _run_polap_select-reads just calls _run_polap_test-reads with a range of a single value.
# we could have assemble-wrange instead of assemble3 or something like assemble2.
# directional is like assemble2 but with dflye.
# Conclusion:
# we need one just like assemble2 but with _run_polap_test-reads not _run_polap_select-reads.
flye_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	# -s 3000,6000,2
	# -s 3000,27000,9
	# -s 30000,42000,5
	${_polap_cmd} directional-flye-reads \
		-o ${_brg_outdir}/o \
		-i 1 -j 2
}

# assemble the directinoal reads using dflye
dflye_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"

	# mt_fastq=/home/goshng/all/polap/dflye1/Lolium_perenne/o/2/03-seeds/ptgaul/2.fq.gz
	# bin/dflye \
	#   --nano-raw
	#   ${mt_fastq} \
	#   --debug \
	#   --stop-after contigger \
	#   --asm-coverage 30 \
	#   --directional-reads \
	#   -g 800000 -o $out_dir -t 56 -m 10000

	# run-polap-function-dga -> _run_polap_dflye
	${_polap_cmd} dflye \
		-o ${_brg_outdir}/o \
		-i 1 -j 2
}

# two main source files:
# 1. run-polap-function-dga.sh <- act like oga
# 2. run-polap-function-directional.sh <- act like assemble2
#
# the first step is a typical polap-assemble1 and assemble2 with seed contig selection.
# now, we use the organelle genome assembly as a seed to apply this directional method.
#
# this is later step.
#
directional_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"
	local target_index="${_brg_outdir}-${_brg_inum}"

	# IFS=':' read -r -a extracted_array_n <<<"${_range["$target_index"]}"

	local extracted_range="${_range["$target_index"]//:/,}"
	local extracted_min_read="${_min_read["$target_index"]}"

	${_polap_cmd} directional \
		-v -v \
		--select-read-range "${extracted_range}" \
		-o ${_brg_outdir}/o \
		--directional-i 1 \
		--min-read-length "${extracted_min_read}" \
		-i 1 -j 3
}

################################################################################
# BEGIN: manuscript functions
#
#
# benchmark
# man init
# man figure-benchmark
#
# man-table
# man-figure
# man-latex
#
man-init_genus_species() {
	if [[ ! -d "man" ]]; then
		cp -pr "${_POLAPLIB_DIR}"/man .
	else
		if [[ "${opt_y_flag}" == false ]]; then
			read -p "Do you want to delete and initialize the man folder? (yes/no): " confirm
		else
			confirm="yes"
		fi

		if [[ "${confirm}" == "yes" ]]; then
			echo "deleting and creating man ... done!"
			rm -rf man
			cp -pr "${_POLAPLIB_DIR}"/man .
		else
			echo "you already have the man folder!"
		fi
	fi
	cp -p "${_POLAPLIB_DIR}"/man/v0.5/figures/na.png .
	cp -p "${_POLAPLIB_DIR}"/man/v0.5/figures/empty.png .
}

# Create PDF with assembly graph figures
man-figure-sheet-latex_genus_species() {
	local _brg_csv="${1}"
	local _brg_txt="${2}"
	local _brg_n="${3:-2}"
	local _brg_page="${4:-1}"

	bash ${_POLAPLIB_DIR}/polap-bash-figure-latex.sh \
		"${_brg_csv}" \
		"${_brg_txt}" \
		"${_brg_n}" \
		"${_brg_page}" \
		species >"${_brg_csv}.tex"

	if [[ "${opt_v_flag}" == "false" ]]; then
		if pdflatex "${_brg_csv}.tex" >/dev/null 2>&1; then
			echo "PDF built successfully"
		else
			echo "Error: pdflatex failed to compile"
			exit 1
		fi
	else
		pdflatex "${_brg_csv}.tex"
	fi

	# echo "use bash ${_POLAPLIB_DIR}/polap-bash-figure-latex.sh"
	echo "csv file: ${_brg_csv}"
	echo "tex file: ${_brg_csv}.tex"
	echo "pdf file: ${_brg_csv}.pdf"
}

man-figure-sheet_genus_species_for() {
	local _brg_outdir="${1}"
	local _brg_inum="${2:-0}"
	local _brg_type="${3:-pt}"
	local _brg_bandage="${4:-bandage}"
	local _brg_csv="${5}"
	# local _brg_csv="${4:-sheet_benchmark-${_brg_inum}.csv}"
	local _brg_inum_0="0"
	local _brg_polap_gfa_number="0"

	local _base_figure="."

	local _key="${_brg_outdir}-${_brg_inum}"

	# Species name
	local _species=${_taxon[$_key]}
	local _species="${_species//_/ }"
	local _genus=${_species%% *}
	local _order=$(grep "${_genus}" ${_POLAPLIB_DIR}/taxonomy_output.tsv | cut -f 6 | head -1)

	# Result folders
	local _brg_outdir_i="${_brg_outdir}/${opt_t_arg}/${_brg_inum}"
	local _brg_outdir_0="${_brg_outdir}/${opt_t_arg}/${_brg_inum_0}"

	# GetOrganelle
	if [[ "${_brg_type}" == "pt" ]]; then
		local _run_title="getorganelle"
		local _brg_rundir="${_brg_outdir_0}/${_run_title}"
		local _gfa_infer="${_brg_rundir}/embplant_pt.K115.complete.graph1.selected_graph.gfa"
		local _png_infer="${_brg_rundir}/embplant_pt.K115.complete.graph1.selected_graph.png"
		if [[ -s "${_gfa_infer}" ]]; then
			if [[ "${_brg_bandage}" == "bandage" ]]; then
				${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
			fi
			printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "GetOrganelle" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
		else
			printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "GetOrganelle" "${_base_figure}/na.png" >>"${_brg_csv}"
		fi
	fi

	# ptGAUL
	local _run_title="ptgaul"
	if [[ "${_brg_type}" != "pt" ]]; then
		local _run_title="mtgaul"
	fi

	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _gfa_infer="${_brg_rundir}/flye_cpONT/assembly_graph.gfa"
	local _png_infer="${_brg_rundir}/flye_cpONT/assembly_graph.png"
	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "ptGAUL" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "ptGAUL" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

	# Polap
	# need to figure out where the gfa is.
	_brg_polap_gfa_number=0
	local _run_title="polap-annotate"
	local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	local _gfa_infer="${_brg_rundir}/pt.${_brg_polap_gfa_number}.gfa"
	local _png_infer="${_brg_rundir}/pt.${_brg_polap_gfa_number}.png"
	if [[ "${_brg_type}" != "pt" ]]; then
		_gfa_infer="${_brg_rundir}/mt.${_brg_polap_gfa_number}.gfa"
		_png_infer="${_brg_rundir}/mt.${_brg_polap_gfa_number}.png"
	fi

	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Polap0" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Polap0" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

	# Polap
	# need to figure out where the gfa is.
	_brg_polap_gfa_number=1
	local _run_title="polap-annotate"
	local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	local _gfa_infer="${_brg_rundir}/pt.${_brg_polap_gfa_number}.gfa"
	local _png_infer="${_brg_rundir}/pt.${_brg_polap_gfa_number}.png"
	if [[ "${_brg_type}" != "pt" ]]; then
		_gfa_infer="${_brg_rundir}/mt.${_brg_polap_gfa_number}.gfa"
		_png_infer="${_brg_rundir}/mt.${_brg_polap_gfa_number}.png"
	fi

	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Polap1" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Polap1" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

	# PMAT
	local _run_title="pmat-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _fc="${_bench_pmat[$_key]}"
	local _gfa_infer="${_brg_rundir}/${_fc}/gfa_result/PMAT_pt_master.gfa"
	local _png_infer="${_brg_rundir}/${_fc}/gfa_result/PMAT_pt_master.png"
	if [[ "${_brg_type}" != "pt" ]]; then
		_gfa_infer="${_brg_rundir}/${_fc}/gfa_result/PMAT_mt_master.gfa"
		_png_infer="${_brg_rundir}/${_fc}/gfa_result/PMAT_mt_master.png"
	fi
	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "PMAT" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "PMAT" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

	# TIPPo
	local _run_title="tippo-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _fc="${_bench_tippo[$_key]}"
	local _gfa_infer="${_brg_rundir}/${_fc}/cns.fa.chloroplast.fasta.filter.800.round1.fasta.chloroplast.flye/assembly_graph.gfa"
	local _png_infer="${_brg_rundir}/${_fc}/cns.fa.chloroplast.fasta.filter.800.round1.fasta.chloroplast.flye/assembly_graph.png"

	# FIXME: MT not PT
	if [[ "${_brg_type}" != "pt" ]]; then
		_gfa_infer="${_brg_rundir}/${_fc}/cns.fa.mitochondrial.fasta.filter.fasta.flye/assembly_graph.gfa"
		_png_infer="${_brg_rundir}/${_fc}/cns.fa.mitochondrial.fasta.filter.fasta.flye/assembly_graph.png"
	fi

	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "TIPPo" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "TIPPo" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

	# oatk
	local _run_title="oatk-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _fc="${_bench_oatk[$_key]}"
	local formatted_fc=$(printf "%02d" "${_fc}")
	local _gfa_infer="${_brg_rundir}/oatk-nextdenovo-${formatted_fc}.pltd.gfa"
	local _png_infer="${_brg_rundir}/oatk-nextdenovo-${formatted_fc}.pltd.png"
	if [[ "${_brg_type}" != "pt" ]]; then
		_gfa_infer="${_brg_rundir}/oatk-nextdenovo-${formatted_fc}.mito.gfa"
		_png_infer="${_brg_rundir}/oatk-nextdenovo-${formatted_fc}.mito.png"
	fi

	if [[ -s "${_gfa_infer}" ]]; then
		if [[ "${_brg_bandage}" == "bandage" ]]; then
			${_polap_cmd} bandage png ${_gfa_infer} ${_png_infer}
		fi
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Oatk" "${_base_figure}/${_png_infer}" >>"${_brg_csv}"
	else
		printf "%s,%s,%s,%s\n" "${_run_title}" "${_species}" "Oatk" "${_base_figure}/na.png" >>"${_brg_csv}"
	fi

}

man-figure-sheet_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"
	local _brg_type="${3:-pt}"
	local _brg_bandage="${4:-bandage}"
	local _brg_csv="${5:-sheet_benchmark-${_brg_outdir}-${_brg_inum}-${_brg_type}.csv}"
	local _brg_txt="${6:-${_POLAPLIB_DIR}/polap_hifi_sheet_benchmark.txt}"

	rm -f "${_brg_csv}"

	# Compose common argument suffix (excluding _brg_outdir)
	local -a _args_suffix=(
		"${_brg_inum}"
		"${_brg_type}"
		"${_brg_bandage}"
		"${_brg_csv}"
		"${_brg_txt}"
	)

	local species_list=()

	case "${_brg_outdir}" in
	all | each) species_list=("${Sall[@]}") ;;
	some) species_list=("${Ssome[@]}") ;;
	test) species_list=("${Stest[@]}") ;;
	*) species_list=() ;;
	esac

	if [[ ${#species_list[@]} -gt 0 ]]; then
		for _v1 in "${species_list[@]}"; do
			man-figure-sheet_genus_species_for "${_v1}" "${_args_suffix[@]}" "${_brg_type}"
		done
	else
		local -a _args_full=(
			"${_brg_outdir}"
			"${_args_suffix[@]}"
		)
		man-figure-sheet_genus_species_for "${_args_full[@]}"
	fi

	# page number: 65
	if [[ -s "${_brg_csv}" ]]; then
		if [[ "${_brg_type}" == "pt" ]]; then
			man-figure-sheet-latex_genus_species "${_brg_csv}" "${_brg_txt}" 7 58
		else
			man-figure-sheet-latex_genus_species "${_brg_csv}" "${_brg_txt}" 6 58
		fi
	else
		echo "Error: no such file: ${_brg_csv}"
	fi

	if [[ -d "${_brg_default_target_dir}" ]]; then
		cp -p "${_brg_csv}.pdf" "${_brg_default_target_dir}/${_brg_csv%.csv}.pdf"
		echo copy "${_brg_csv%.csv}.pdf" to "${_brg_default_target_dir}"
	else
		echo "Error: no such target dir: ${_brg_default_target_dir}"
	fi
}

man-figure-benchmark_genus_species() {
	local _brg_outdir="${1:-all}"
	local _brg_inum="${2:-0}"
	local _brg_type="${3:-benchmark}"
	local _brg_view="${4:-off}"

	if [[ "${_brg_outdir}" == "-h" || "${_brg_outdir}" == "--help" ]]; then
		echo "${help_message_man_figure_benchmark}"
		return
	fi

	# NOTE: delete these
	local _brg_d_index="${3:-infer-1}"
	local _brg_table="${4:-1}"
	local _brg_format="${5:-1}"
	local _brg_t_dir="${6:-"${_brg_default_target_dir}"}"

	# Set the run title
	local full_name="${FUNCNAME[0]}"
	local middle_part="${full_name#man-}"
	local run_title="${middle_part%%_*}"
	local run_title="${run_title%-*}"
	local table_md="${run_title}-${_brg_type}-${_brg_outdir}-${_brg_inum}.md"
	local table_md_data="${run_title}-benchmark-data-${_brg_outdir}-${_brg_inum}.md"
	local table_md_memory="${run_title}-benchmark-memory-${_brg_outdir}-${_brg_inum}.md"
	local table_md_time="${run_title}-benchmark-time-${_brg_outdir}-${_brg_inum}.md"
	local table_md_polap="${run_title}-benchmark-polap-${_brg_outdir}-${_brg_inum}.md"
	local table_md_computer="${run_title}-benchmark-computer-${_brg_outdir}-${_brg_inum}.md"
	local table_md_hostname="${run_title}-benchmark-hostname-${_brg_outdir}-${_brg_inum}.md"
	local table_tsv="table-${_brg_outdir}-${_brg_inum}.tsv"
	local figure_pdf="${run_title}-${_brg_type}-${_brg_outdir}-${_brg_inum}.pdf"

	if [[ "${_brg_view}" == "on" || "${_brg_view}" == "view" ]]; then
		echo "Use TSV: ${table_tsv}"
		echo "Open PDF: ${figure_pdf}"
		return
	fi

	# echo "TSV: ${table_tsv}"
	# echo "Type: ${_brg_type}"
	# echo "PDF: ${figure_pdf}"

	_polap_lib_conda-ensure_conda_env polap

	# echo Rscript ${_POLAPLIB_DIR}/polap-r-disassemble-man-benchmark-boxplots.R \
	# 	--table "${table_tsv}" \
	# 	--type "${_brg_type}" \
	# 	-o "${figure_pdf}"
	Rscript ${_POLAPLIB_DIR}/polap-r-disassemble-man-benchmark-boxplots.R \
		--table "${table_tsv}" \
		--type "${_brg_type}" \
		-o "${figure_pdf}" 2>/dev/null

	conda deactivate

	cp -p ${figure_pdf} "${_brg_default_target_dir}"
	echo copy ${figure_pdf} to ${_brg_default_target_dir}
}

man-pdf_genus_species() {
	local _brg_outdir="${1}"

	if [[ "${_brg_outdir}" == "-h" || "${_brg_outdir}" == "--help" ]]; then
		echo "${help_message_man_pdf}"
		return
	fi

	cd "${_brg_default_target_dir}"/..

	_polap_lib_conda-ensure_conda_env polap-man

	make ${_brg_outdir}

	conda deactivate

	cd -
	if [[ -z "${_brg_outdir}" ]]; then
		cp -p "${_brg_default_target_dir}"/../manuscript.pdf .
	elif [[ "${_brg_outdir}" == "test" ]]; then
		cp -p "${_brg_default_target_dir}"/../manuscript-test.pdf .
	fi
}

# The main benchmark function for a species-index folder
benchmark-copy_genus_species_for() {
	local _brg_outdir="${1:-some}"
	local _brg_fromdir="${2:-cflye1}"
	local _brg_inum="${3:-0}"
	local _brg_inum_0=0

	local full_name="${FUNCNAME[0]}"
	local middle_part="${full_name#man-}"
	local run_title="${middle_part%%_*}"

	local target_index="${_brg_outdir}-${_brg_inum}"
	local species_name="$(echo ${_brg_outdir} | sed 's/_/ /')"
	local long_sra="${_long["$target_index"]}"
	local short_sra="${_short["$target_index"]}"
	local bench_oatk="${_bench_oatk["$target_index"]}"
	local random_seed="${_random_seed["$target_index"]}"
	local _brg_outdir_t="${_brg_outdir}/${opt_t_arg}"
	local _brg_outdir_i="${_brg_outdir_t}/${_brg_inum}"
	local _brg_outdir_0="${_brg_outdir_t}/0"

	if [[ "${opt_y_flag}" == false ]]; then
		echo "We will copy benchmarking using GetOrganelle, ptGAUL, PMAT, TIPPo, Oatk on ${_brg_outdir}/${opt_t_arg}/0 ..."
		read -p "Do you want to execute copy on ${_brg_outdir}/${opt_t_arg}/${_brg_inum}? (yes/no): " confirm
	else
		confirm="yes"
	fi

	if [[ "${confirm}" != "yes" ]]; then
		echo "copy processing with benchmarking analysis is canceled."
		return
	fi

	_log_echo "Copy (${_brg_outdir}): polap annotating and assembling for banchmarking analysis"

	# Prepare the input data
	# polap-analysis-data_genus_species "${_brg_outdir}"

	# main
	mkdir -p "${_brg_outdir_i}"

	local _brg_base="$HOME/all/polap/${_brg_fromdir}"
	local _brg_from="${_brg_base}/${_brg_outdir_0/t5/t1}"
	cp -p "${_brg_from}"/timing*.txt "${_brg_outdir_0}"
	cp -p "${_brg_from}"/summary*.txt "${_brg_outdir_0}"

	# for i in cns.fa ptdna-ptgaul.fa; do
	for i in ptdna-ptgaul.fa; do
		local src="${_brg_from}"/"$i"
		local dst="${_brg_outdir_0}"/"$i"
		[[ -e "$dst" ]] || cp -p "$src" "$dst"
	done

	# Execute GetOrganelle
	# check: getorganelle folder itself
	local _run_title="getorganelle"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/

	# Execute FMLRC's msbwt preparation
	# check: msbwt/comp_msbwt.npy
	local _run_title="msbwt"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	# rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/

	# Execute ptGAUL
	# check: ptgaul/flye_cpONT/assembly_graph.gfa
	local _run_title="ptgaul"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/

	# run-estimate-genomesize
	local _run_title="estimate-genomesize"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/

	# run-nextdenovo-polish
	local _run_title="nextdenovo-polish"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	if [[ -d "${_brg_from}" ]]; then
		rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/
	else
		echo "No such folder: ${_brg_from}"
	fi

	# run-oatk
	# check: oatk-nextdenovo/oatk-nextdenovo-30.utg.gfa
	local _run_title="oatk-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _check_file_for_finish="${_brg_rundir}/oatk-nextdenovo-30.utg.gfa"
	local _check_file_for_try="${_brg_rundir}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	if [[ -d "${_brg_from}" ]]; then
		rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/
	else
		echo "No such folder: ${_brg_from}"
	fi

	# run-tippo
	local _run_title="tippo-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local _check_file_for_finish="${_brg_rundir}/onthq/log_cns.fa.tiara.out"
	local _check_file_for_try="${_brg_rundir}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	if [[ -d "${_brg_from}" ]]; then
		rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/
	else
		echo "No such folder: ${_brg_from}"
	fi

	# run-pmat
	local _run_title="pmat-nextdenovo"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	# NOTE: PMAT run first try to run withouth time limit.
	# If it fails for some reason, then it crashes. If the run time is over 12 hours,
	# then we would use PMATContigGraph.txt to skip the run and just report the run time.
	local _check_file_for_finish="${_brg_rundir}/0.1/assembly_result/PMATContigGraph.txt"
	local _check_file_for_finish="${_brg_rundir}/0.1/PMAT_mt_blastn.txt"
	local _check_file_for_try="${_brg_rundir}"
	local _brg_from="${_brg_base}/${_brg_rundir/t5/t1}"
	rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/
	if [[ -d "${_brg_from}" ]]; then
		rsync -aqz "${_brg_from}"/ "${_brg_rundir}"/
	else
		echo "No such folder: ${_brg_from}"
	fi

	# debug local variables
	# for debugging: Inline local printing local var
	# while IFS= read -r line; do
	# 	if [[ $line =~ ^declare\ --\ ([^=]+)= ]]; then
	# 		var="${BASH_REMATCH[1]}"
	# 		printf "%s=%q\n" "$var" "${!var}"
	# 	fi
	# done < <(local -p 2>/dev/null)
	# return

	if [[ ! -s "${_brg_outdir_0}/cns.fa" ]]; then
		echo "No nextdenovo polished data: no ${_brg_outdir_0}/cns.fa"
		echo "  -> no pmat, tippo, oatk assembly"
	fi

	_log_echo "END (${_brg_outdir}): polap assembling using cflye with banchmarking analysis"
}

benchmark-copy_genus_species() {
	local _brg_outdir="${1:-some}"
	local _brg_fromdir="${2:-cflye1}"
	local _brg_inum="${3:-0}"

	if [[ "${_brg_outdir}" == "all" ]]; then
		for _v1 in "${Sall[@]}"; do
			benchmark-copy_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "some" ]]; then
		for _v1 in "${Ssome[@]}"; do
			benchmark-copy_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "test" ]]; then
		for _v1 in "${Stest[@]}"; do
			benchmark-copy_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "each" ]]; then
		for _v1 in "${Seach[@]}"; do
			benchmark-copy_genus_species_for "${_v1}" "${@:2}"
		done
	else
		benchmark-copy_genus_species_for "$@"
	fi
}

# The main benchmark function for a species-index folder
benchmark-command_genus_species_for() {
	local _brg_outdir="$1"
	local _brg_inum="${2:-0}"
	local _brg_inum_0=0

	local full_name="${FUNCNAME[0]}"
	local middle_part="${full_name#man-}"
	local run_title="${middle_part%%_*}"

	local target_index="${_brg_outdir}-${_brg_inum}"
	local species_name="$(echo ${_brg_outdir} | sed 's/_/ /')"
	local long_sra="${_long["$target_index"]}"
	local short_sra="${_short["$target_index"]}"
	local bench_oatk="${_bench_oatk["$target_index"]}"
	local random_seed="${_random_seed["$target_index"]}"
	local _brg_outdir_t="${_brg_outdir}/${opt_t_arg}"
	local _brg_outdir_i="${_brg_outdir_t}/${_brg_inum}"
	local _brg_outdir_0="${_brg_outdir_t}/0"

	local _brg_target="${target_index}"
	local platform="${_platform["$_brg_target"]}"

	if [[ "${opt_y_flag}" == false ]]; then
		echo "We will execute benchmarking using GetOrganelle, ptGAUL, PMAT, TIPPo, Oatk on ${_brg_outdir}/${opt_t_arg}/0 ..."
		read -p "Do you want to execute assemble on ${_brg_outdir}/${opt_t_arg}/${_brg_inum}? (yes/no): " confirm
	else
		confirm="yes"
	fi

	if [[ "${confirm}" != "yes" ]]; then
		echo "assemble processing with benchmarking analysis is canceled."
		return
	fi

	_log_echo "START (${_brg_outdir}): polap annotating and assembling for banchmarking analysis"

	# Prepare the input data
	polap-analysis-data_genus_species "${_brg_outdir}"

	# main
	mkdir -p "${_brg_outdir_i}"

	# Execute summary-data
	# check: summary-data/l.fq.stats
	local _run_title="summary-data"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}"/l.fq.stats ]]; then
		_log_echo "Found: the data summary"
	else
		run-summary-data_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_rundir}"/l.fq.stats ]]; then
			_log_echo "Success: the data summary"
		else
			_log_echo "Fail: the data summary"
			exit 1
		fi
	fi

	# Execute NCBI edirect download ptDNA
	# check: ncbi-ptdna/ptdna-reference.fa
	local _run_title="ncbi-ptdna"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}/ptdna-reference.fa" ]]; then
		_log_echo "Found: reference ptDNA"
	else
		download-ptdna_genus_species "${_brg_outdir}"
		if [[ -s "${_brg_rundir}/ptdna-reference.fa" ]]; then
			_log_echo "Success: reference ptDNA"
		else
			_log_echo "Fail: reference ptDNA"
			exit 1
		fi
	fi

	# Execute NCBI edirect download ptDNA
	# check: ncbi-ptdna/ptdna-reference.fa
	local _run_title="ncbi-mtdna"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}/mtdna-reference.fa" ]]; then
		_log_echo "Found: reference mtDNA"
	else
		download-mtdna_genus_species "${_brg_outdir}"
		if [[ -s "${_brg_rundir}/mtdna-reference.fa" ]]; then
			_log_echo "Success: reference mtDNA"
		else
			_log_echo "Fail: reference mtDNA"
			echo 0 >"${_brg_rundir}/mtdna-reference.fa"
		fi
	fi

	# Execute GetOrganelle
	# check: getorganelle folder itself
	local _run_title="getorganelle"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -d "${_brg_rundir}" ]] &&
		find "${_brg_rundir}" -maxdepth 1 -type f -name 'embplant_pt.*.gfa' -size +0c | grep -q .; then
		_log_echo "Found: GetOrganelle assembled ptDNA"
	else
		run-getorganelle_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if find "${_brg_rundir}" -maxdepth 1 -type f -name 'embplant_pt.*.gfa' -size +0c | grep -q .; then
			_log_echo "Success: GetOrganelle assembled ptDNA"
		else
			_log_echo "Fail: GetOrganelle assembled ptDNA"
			exit 1
		fi
	fi

	# Execute FMLRC's msbwt preparation
	# check: msbwt/comp_msbwt.npy
	local _run_title="msbwt"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}/comp_msbwt.npy" ]]; then
		_log_echo "Found: FMLRC msbwt"
	else
		run-msbwt_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_rundir}/comp_msbwt.npy" ]]; then
			_log_echo "Success: FMLRC msbwt"
		else
			_log_echo "Fail: FMLRC msbwt"
			exit 1
		fi
	fi

	# Execute ptGAUL
	# check: ptgaul/flye_cpONT/assembly_graph.gfa
	local _run_title="ptgaul"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}/flye_cpONT/assembly_graph.gfa" ]]; then
		_log_echo "Found: ptGAUL assembly"
	else
		run-ptgaul_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_rundir}/flye_cpONT/assembly_graph.gfa" ]]; then
			_log_echo "Success: ptGAUL assembly"
		else
			_log_echo "Fail: ptGAUL assembly"
			exit 1
		fi
	fi

	# Extract ptDNA from ptGAUL
	# check: ptgaul/flye_cpONT/ptdna/circular_path_1_concatenated.fa
	local _run_title="ptgaul"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}/flye_cpONT/ptdna"
	if [[ -s "${_brg_rundir}/circular_path_1_concatenated.fa" ]]; then
		_log_echo "Found: ptGAUL extracted ptDNA"
	else
		run-extract-ptdna-ptgaul_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_rundir}/circular_path_1_concatenated.fa" ]]; then
			_log_echo "Success: ptGAUL extracted ptDNA"
		else
			_log_echo "Fail: ptGAUL extracted ptDNA"
			_log_echo "${help_message_extract_ptdna_ptgaul}"
			exit 1
		fi
	fi

	# Polish ptDNA from ptGAUL
	local _run_title="ptgaul"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_outdir_0}/ptdna-ptgaul.fa" ]]; then
		_log_echo "Found: ptGAUL polished genome"
	else
		run-polish-ptdna-ptgaul_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_outdir_0}/ptdna-ptgaul.fa" ]]; then
			_log_echo "Success: ptGAUL polished genome"
		else
			_log_echo "Fail: ptGAUL polished genome"
			_log_echo "${help_message_polish_ptdna_ptgaul}"
			exit 1
		fi
	fi

	# Execute ptGAUL for mtDNA
	# check: mtgaul/flye_cpONT/assembly_graph.gfa
	local _run_title="mtgaul"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	local mtdna_reference="${_brg_outdir_0}/ncbi-mtdna/mtdna-reference.fa"
	if [[ $(stat -c%s "$mtdna_reference") -gt 100 && $(<"$mtdna_reference") != "0" ]]; then
		if [[ -s "${_brg_rundir}/flye_cpONT/assembly_graph.gfa" ]]; then
			_log_echo "Found: ptGAUL's mtDNA assembly"
		else
			run-mtgaul_genus_species "${_brg_outdir}" "${_brg_inum_0}"
			if [[ -s "${_brg_rundir}/flye_cpONT/assembly_graph.gfa" ]]; then
				_log_echo "Success: ptGAUL's mtDNA assembly"
			else
				_log_echo "Fail: ptGAUL's mtDNA assembly"
				echo "No such file: ${_brg_rundir}/flye_cpONT/assembly_graph.gfa"
				echo 0 >"${_brg_rundir}/flye_cpONT/assembly_graph.gfa"
			fi
		fi
	else
		_log_echo "Fail: mtDNA reference is not proper."
	fi

	# run-estimate-genomesize
	local _run_title="estimate-genomesize"
	local _brg_rundir="${_brg_outdir_0}/${_run_title}"
	if [[ -s "${_brg_rundir}/short_expected_genome_size.txt" ]]; then
		_log_echo "Found: the genome size estimate"
	else
		if [[ "${platform}" != "ONT" ]]; then
			_log_echo "No genome size estimate for ${platform}"
			exit 1
		fi
		run-estimate-genomesize_genus_species "${_brg_outdir}" "${_brg_inum_0}"
		if [[ -s "${_brg_rundir}/short_expected_genome_size.txt" ]]; then
			_log_echo "Success: the genome size estimate"
		else
			_log_echo "Fail: the genome size estimate"
			exit 1
		fi
	fi

	# run-nextdenovo-polish
	if [[ "${bench_oatk}" != "0" ]]; then

		local _run_title="nextdenovo-polish"
		local _brg_rundir="${_brg_outdir_0}/${_run_title}"
		if [[ -s "${_brg_outdir_0}/cns.fa" ]]; then
			_log_echo "Found: the long-read NextDenovo polished data"
		else
			run-nextdenovo-polish_genus_species "${_brg_outdir}" "${_brg_inum_0}"
			if [[ -s "${_brg_outdir_0}/cns.fa" ]]; then
				_log_echo "Success: the long-read NextDenovo polished data"
			else
				_log_echo "Fail: the long-read NextDenovo polished data"
			fi
		fi

		if [[ -s "${_brg_outdir_0}/cns.fa" ]]; then

			# run-oatk
			# check: oatk-nextdenovo/oatk-nextdenovo-30.utg.gfa
			local _run_title="oatk-nextdenovo"
			local _brg_rundir="${_brg_outdir_0}/${_run_title}"
			local _check_file_for_finish="${_brg_rundir}/oatk-nextdenovo-30.utg.gfa"
			local _check_file_for_try="${_brg_rundir}"
			if [[ -d "${_check_file_for_try}" ]]; then
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Found: the oatk result"
				else
					_log_echo "Not Found: no oatk result because of potential time limit"
				fi
			else
				run-oatk_genus_species "${_brg_outdir}" "${_brg_inum_0}"
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Success: the oatk result"
				else
					_log_echo "Fail: the oatk result"
				fi
			fi

			# run-tippo
			local _run_title="tippo-nextdenovo"
			local _brg_rundir="${_brg_outdir_0}/${_run_title}"
			local _check_file_for_finish="${_brg_rundir}/onthq/log_cns.fa.tiara.out"
			local _check_file_for_try="${_brg_rundir}"
			if [[ -d "${_check_file_for_try}" ]]; then
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Found: the tippo result"
				else
					_log_echo "Not Found: no tippo result because of potential time limit"
				fi
			else
				run-tippo_genus_species "${_brg_outdir}" "${_brg_inum_0}"
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Success: the tippo result"
				else
					_log_echo "Fail: the tippo result"
				fi
			fi

			# run-pmat
			local _run_title="pmat-nextdenovo"
			local _brg_rundir="${_brg_outdir_0}/${_run_title}"
			# NOTE: PMAT run first try to run withouth time limit.
			# If it fails for some reason, then it crashes. If the run time is over 12 hours,
			# then we would use PMATContigGraph.txt to skip the run and just report the run time.
			local _check_file_for_finish="${_brg_rundir}/0.1/assembly_result/PMATContigGraph.txt"
			local _check_file_for_finish="${_brg_rundir}/0.1/PMAT_mt_blastn.txt"
			local _check_file_for_try="${_brg_rundir}"
			if [[ -d "${_check_file_for_try}" ]]; then
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Found: the pmat result"
				else
					_log_echo "Not Found: no pmat result because of potential time limit"
				fi
			else
				run-pmat_genus_species "${_brg_outdir}" "${_brg_inum_0}"
				if [[ -s "${_check_file_for_finish}" ]]; then
					_log_echo "Success: the pmat result"
				else
					_log_echo "Fail: the pmat result"
				fi
			fi
		else
			echo "No nextdenovo polished data: no ${_brg_outdir_0}/cns.fa"
			echo "  -> no pmat, tippo, oatk assembly"
		fi
	fi

	# run-polap-readassemble-pt
	local _run_title="polap-readassemble-pt"
	local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
		_log_echo "Found: polap-readassemble-pt pt assembly"
	else
		run-polap-readassemble-pt_genus_species "${_brg_outdir}" "${_brg_inum}"
		if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
			_log_echo "Success: polap-readassemble-pt pt assembly"
		else
			_log_echo "Fail: polap-readassemble-pt pt assembly"
			return 1
		fi
	fi

	# run-polap-readassemble-mt
	# local _run_title="polap-readassemble-mt"
	# local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	# if [[ -s "${_brg_rundir}/mt1/assembly_graph.gfa" ]]; then
	# 	_log_echo "Found: polap-readassemble-mt mt assembly"
	# else
	# 	run-polap-readassemble-mt_genus_species "${_brg_outdir}" "${_brg_inum}"
	# 	if [[ -s "${_brg_rundir}/mt1/assembly_graph.gfa" ]]; then
	# 		_log_echo "Success: polap-readassemble-mt mt assembly"
	# 	else
	# 		_log_echo "Fail: polap-readassemble-mt mt assembly"
	# 		return 1
	# 	fi
	# fi

	# run-polap
	# local _run_title="polap-annotate"
	# local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	# if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
	# 	_log_echo "Found: polap-annotate pt assembly"
	# else
	# 	run-polap-annotate_genus_species "${_brg_outdir}" "${_brg_inum}"
	# 	if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
	# 		_log_echo "Success: polap-annotate pt assembly"
	# 	else
	# 		_log_echo "Fail: polap-annotate pt assembly"
	# 		return 1
	# 	fi
	# fi

	# Compare the results
	# if [[ -s "${_brg_outdir_0}/ptdna-ptgaul.fa" ]]; then
	#
	# 	if [[ "${_brg_outdir_0}" != "${_brg_outdir_i}" ]]; then
	# 		cp -p "${_brg_outdir_0}/ptdna-ptgaul.fa" "${_brg_outdir_i}"
	# 	fi
	#
	# 	local _run_title="polap-annotate"
	# 	local _brg_rundir="${_brg_outdir_i}/${_run_title}"
	#
	# 	if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
	# 		_log_echo "Found: polap-annotate pt check assembly"
	# 	else
	# 		run-polap-annotate-check_genus_species "${_brg_outdir}" "${_brg_inum}"
	# 		if [[ -s "${_brg_rundir}/pt1/assembly_graph.gfa" ]]; then
	# 			_log_echo "Success: polap-annotate pt check assembly"
	# 		else
	# 			_log_echo "Fail: polap-annotate pt check assembly"
	# 			return 1
	# 		fi
	# 	fi
	# fi

	# debug local variables
	# for debugging: Inline local printing local var
	# while IFS= read -r line; do
	# 	if [[ $line =~ ^declare\ --\ ([^=]+)= ]]; then
	# 		var="${BASH_REMATCH[1]}"
	# 		printf "%s=%q\n" "$var" "${!var}"
	# 	fi
	# done < <(local -p 2>/dev/null)
	# return

	_log_echo "END (${_brg_outdir}): polap annotating and assembling with banchmarking analysis"
}

benchmark-command_genus_species() {
	local _brg_outdir="${1:-some}"
	local _brg_inum="${2:-0}"

	if [[ "${_brg_outdir}" == "all" ]]; then
		for _v1 in "${Sall[@]}"; do
			benchmark-command_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "some" ]]; then
		for _v1 in "${Ssome[@]}"; do
			benchmark-command_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "test" ]]; then
		for _v1 in "${Stest[@]}"; do
			benchmark-command_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "each" ]]; then
		for _v1 in "${Seach[@]}"; do
			benchmark-command_genus_species_for "${_v1}" "${@:2}"
		done
	else
		benchmark-command_genus_species_for "$@"
	fi
}

benchmark_genus_species_for() {
	local _brg_outdir="${1}"

	_brg_outdir="${_brg_outdir%/}"
	for i in 0 1 2; do
		benchmark-command_genus_species "${_brg_outdir}" $i
	done
}

benchmark_genus_species() {
	local args=("$@")

	for item in "$@"; do
		benchmark_genus_species_for "${item}"
	done
}

benchmark-skip_genus_species() {
	local _brg_outdir="$1"
	local _brg_sindex="${2:-0}"

	local _brg_inum=0
	local _brg_adir _brg_title _brg_target _brg_rundir _brg_outdir_i
	local _timing_txt _stdout_txt _memlog_file _summary_file

	brg_common_setup \
		_brg_outdir _brg_sindex _brg_adir _brg_title \
		_brg_target _brg_rundir _brg_outdir_i \
		_timing_txt _stdout_txt _memlog_file _summary_file

	# Extra folders
	local _brg_outdir_t="${_brg_outdir}/${opt_t_arg}"
	local _brg_titledir="${_brg_outdir_i}/${_brg_title}"
	local _brg_runtitledir="${_brg_rundir}-${_brg_title}"

	if [[ -v _long["$_brg_target"] ]]; then
		local long_sra="${_long["$_brg_target"]}"
	else
		echo "Error: ${_brg_target} because it is not in the CSV."
		return
	fi

	local _brg_outdir_t="${_brg_outdir}/${opt_t_arg}"
	local _brg_outdir_0="${_brg_outdir_t}/0"

	echo 0 >"${_brg_outdir_0}/cns.fa"
	mkdir -p "${_brg_outdir_0}/msbwt"
	echo 0 >"${_brg_outdir_0}/msbwt/comp_msbwt.npy"
}

man-table-benchmark_genus_species_header() {
	local _brg_table="${1:-1}"

	local _items=(
		_species
		_species_italic
		_genus
		_order
		_family
		_l_sra
		_l_sra_size_gb
		_long_coverage
		_s_sra
		_s_sra_size_gb
		_short_coverage
		_genome_size
		_memory_gb_genomesize
		_total_hours_genomesize
		_memory_gb_getorganelle
		_total_hours_getorganelle
		_memory_gb_msbwt
		_total_hours_msbwt
		_memory_gb_msbwt_polish
		_total_hours_msbwt_polish
		_memory_gb_ptgaul
		_total_hours_ptgaul
		_memory_gb_mtgaul   # new
		_total_hours_mtgaul # new
		_memory_gb_nextdenovo_polish
		_total_hours_nextdenovo_polish
		_memory_gb_polap_annotate_ont_pt   # new
		_total_hours_polap_annotate_ont_pt # new
		_memory_gb_polap_assemble_ont_pt   # new
		_total_hours_polap_assemble_ont_pt # new
		_known_ptdna                       # new
		_known_mtdna
		_ptdna_seq_length_ptgaul   # new
		_ptdna_num_seq_ptgaul      # new
		_mtdna_seq_length_ptgaul   # new
		_mtdna_num_seq_ptgaul      # new
		_ptdna_seq_length_annotate # new
		_ptdna_num_seq_annotate    # new
		_mtdna_seq_length_annotate # new
		_mtdna_num_seq_annotate    # new
		_config_hostname
		_system_hostname
		_system_os_version
		_system_cpu_model
		_system_cpu_cores
		_system_total_memory
		_system_storage_type
		_system_disk_size
	)

	printf "%s\t" "${_items[@]::${#_items[@]}}"
	# printf "%s\t" "${_items[@]::${#_items[@]}-1}"
	# printf "%s\n" "${_items[-1]}"

	for _fc in "${_polap_oatk_options[@]}"; do
		printf "_memory_gb_oatk_nextdenovo_%s\t" "${_fc}"
		printf "_total_hours_oatk_nextdenovo_%s\t" "${_fc}"
	done

	for _fc in "${_polap_tippo_options[@]}"; do
		printf "_memory_gb_tippo_nextdenovo_%s\t" "${_fc}"
		printf "_total_hours_tippo_nextdenovo_%s\t" "${_fc}"
	done

	for _fc in "${_polap_pmat_options[@]}"; do
		printf "_memory_gb_pmat_nextdenovo_%s\t" "${_fc}"
		printf "_total_hours_pmat_nextdenovo_%s\t" "${_fc}"
	done

	printf "dummy\n"
}

# Table 1's row for a given outdir and inum.
#
# arg1: outdir
# arg2: inum
# arg3: disassemble-i
# arg4: 1 or 2
# arg5: target directory to copy the result
#
# outdir-inum is used as the key as well.
#
# return:
#
man-table-benchmark_genus_species_for() {
	local _brg_outdir="${1}"
	local _brg_inum="${2:-0}"
	local _brg_type="${3:-benchmark}"

	local _brg_d_index="${3:-infer-1}"
	local _brg_table="${4:-1}"
	local _brg_t_dir="${5:-"${_brg_default_target_dir}"}"
	local _key="${_brg_outdir}-${_brg_inum}"

	# Used the upper bound of the memory
	local _v1="${_brg_outdir}"
	local _polap_log=${_v1}/polap.log

	# Folders
	local _brg_outdir_t="${_brg_outdir}/${opt_t_arg}"
	local _brg_outdir_i="${_brg_outdir_t}/${_brg_inum}"
	local _brg_outdir_0="${_brg_outdir_t}/0"

	local _config_hostname=${_host[$_key]}

	# Taxon names: species, genus, family, and order
	local _species=${_taxon[$_key]}
	local _species="${_species//_/ }"
	local _species_italic="_${_species}_"
	local _genus=${_species%% *}
	local _order=$(grep "${_genus}" ${_POLAPLIB_DIR}/taxonomy_output.tsv | cut -f 6 | head -1)
	local _family=$(grep "${_genus}" ${_POLAPLIB_DIR}/taxonomy_output.tsv | cut -f 7 | head -1)

	# Extract long-read SRA ID
	local _l_fq_stats="${_brg_outdir_0}/summary-data/l.fq.stats"
	local _l_sra=$(_polap_lib_extract-seqkit_stats "${_l_fq_stats}")
	local _l_sra_size=$(_polap_lib_extract-seqkit_stats_sum_len "${_l_fq_stats}")
	local _l_sra_size_gb=$(_polap_lib_unit-convert_bp "${_l_sra_size}")

	# Extract short-read SRA ID
	local _s1_fq_stats="${_brg_outdir_0}/summary-data/s1.fq.stats"
	local _s1_sra=$(_polap_lib_extract-seqkit_stats "${_s1_fq_stats}")
	local _s_sra="${_s1_sra%%_*}"
	local _s1_sra_size=$(_polap_lib_extract-seqkit_stats_sum_len "${_s1_fq_stats}")
	local _s1_sra_size_gb=$(_polap_lib_unit-convert_bp "${_s1_sra_size}")
	local _s2_fq_stats="${_brg_outdir_0}/summary-data/s2.fq.stats"
	local _s2_sra=$(_polap_lib_extract-seqkit_stats "${_s2_fq_stats}")
	local _s2_sra_size=$(_polap_lib_extract-seqkit_stats_sum_len "${_s2_fq_stats}")
	local _s2_sra_size_gb=$(_polap_lib_unit-convert_bp "${_s2_sra_size}")
	if [[ "${_s1_sra}" == "NA" ]]; then
		local _s_sra_size="NA"
	else
		local _s_sra_size=$((_s1_sra_size + _s2_sra_size))
	fi
	local _s_sra_size_gb=$(_polap_lib_unit-convert_bp "${_s_sra_size}")

	# Extract the genome size estimate
	local _genome_size_dir="${_brg_outdir_0}/estimate-genomesize"
	local _genome_size=$(_polap_lib_extract-genome_size "${_genome_size_dir}")
	local _genome_size_gb=$(_polap_lib_unit-convert_bp "${_genome_size}")

	# sequencing data coverage
	if [[ "${_genome_size}" == "NA" ]]; then
		local _long_coverage="NA"
		local _short_coverage="NA"
	else
		local _long_coverage=$(echo "scale=2; ${_l_sra_size} / ${_genome_size}" | bc)
		local _short_coverage=$(echo "scale=2; ${_s_sra_size} / ${_genome_size}" | bc)
	fi

	# Extract the timing for the corresponing coverage x case
	local _timing_dir="${_brg_outdir_0}"

	# Extract the time and memory for genome size estimate
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-estimate-genomesize.txt"
	local _memory_gb_genomesize=$_memory_gb
	local _total_hours_genomesize=$_total_hours

	# Extract the time and memory for GetOrganelle
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-getorganelle.txt"
	local _memory_gb_getorganelle=$_memory_gb
	local _total_hours_getorganelle=$_total_hours

	# Extract the time and memory for FMLRC's msbwt
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-msbwt.txt"
	local _memory_gb_msbwt=$_memory_gb
	local _total_hours_msbwt=$_total_hours

	# Polishing time and memory for FMLRC's msbwt
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-polish-ptdna-ptgaul.txt"
	local _memory_gb_msbwt_polish=$_memory_gb
	local _total_hours_msbwt_polish=$_total_hours

	# Extract the time and memory for ptgaul
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-ptgaul.txt"
	local _memory_gb_ptgaul=$_memory_gb
	local _total_hours_ptgaul=$_total_hours

	# Extract the time and memory for mtgaul
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-mtgaul.txt"
	local _memory_gb_mtgaul=$_memory_gb
	local _total_hours_mtgaul=$_total_hours

	# Extract the time and memory for nextdenovo-polish
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-nextdenovo-polish.txt"
	local _memory_gb_nextdenovo_polish=$_memory_gb
	local _total_hours_nextdenovo_polish=$_total_hours
	if (($(echo "$_memory_gb_nextdenovo_polish < 0.1" | bc -l))); then
		_memory_gb_nextdenovo_polish="NA"
		_total_hours_nextdenovo_polish="NA"
	fi

	# Extract the time and memory for oatk-nextdenovo
	local -A memory_gb_oatk_nextdenovo
	local -A total_hours_oatk_nextdenovo
	for _fc in "${_polap_oatk_options[@]}"; do
		_polap_lib_extract-time_memory_timing_summary_file \
			"${_timing_dir}/summary-oatk-nextdenovo-${_fc}.txt"
		memory_gb_oatk_nextdenovo["$_fc"]=$_memory_gb
		total_hours_oatk_nextdenovo["$_fc"]=$_total_hours
	done

	# Extract the time and memory for tippo-nextdenovo
	local -A memory_gb_tippo_nextdenovo
	local -A total_hours_tippo_nextdenovo
	for _fc in "${_polap_tippo_options[@]}"; do
		_polap_lib_extract-time_memory_timing_summary_file \
			"${_timing_dir}/summary-tippo-nextdenovo-${_fc}.txt"
		memory_gb_tippo_nextdenovo["$_fc"]=$_memory_gb
		total_hours_tippo_nextdenovo["$_fc"]=$_total_hours
	done

	# Extract the time and memory for pmat-nextdenovo
	local -A memory_gb_pmat_nextdenovo
	local -A total_hours_pmat_nextdenovo
	for _fc in "${_polap_pmat_options[@]}"; do
		_polap_lib_extract-time_memory_timing_summary_file \
			"${_timing_dir}/summary-pmat-nextdenovo-${_fc}.txt"
		memory_gb_pmat_nextdenovo["$_fc"]=$_memory_gb
		total_hours_pmat_nextdenovo["$_fc"]=$_total_hours
	done

	local _timing_dir="${_brg_outdir_i}"

	# Extract the time and memory for polap-annotate-ont
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-annotate-ont-pt.txt"
	local _memory_gb_polap_annotate_ont_pt=$_memory_gb
	local _total_hours_polap_annotate_ont_pt=$_total_hours

	# Extract the time and memory for polap-assemble-ont
	_polap_lib_extract-time_memory_timing_summary_file \
		"${_timing_dir}/summary-assemble-ont-pt.txt"
	local _memory_gb_polap_assemble_ont_pt=$_memory_gb
	local _total_hours_polap_assemble_ont_pt=$_total_hours

	# Known ptDNA NCBI accession
	local _known_ptdna=$(
		_polap_lib_extract-content \
			"${_brg_outdir_0}/ncbi-ptdna/00-bioproject/2-mtdna.accession"
	)

	# Known ptDNA NCBI accession
	local _known_mtdna=$(
		_polap_lib_extract-content \
			"${_brg_outdir_0}/ncbi-mtdna/00-bioproject/2-mtdna.accession"
	)

	local _ptdna_ptgaul="${_brg_outdir_0}/ptgaul/flye_cpONT/assembly_graph.gfa"
	# local _ptdna_ptgaul="${_brg_outdir_0}/ptdna-ptgaul.gfa"
	local _ptdna_seq_length_ptgaul=$(_polap_lib_extract-gfa_seqlen "${_ptdna_ptgaul}")
	local _ptdna_num_seq_ptgaul=$(_polap_lib_extract-gfa_numseq "${_ptdna_ptgaul}")

	# gfa not fasta
	local _mtdna_ptgaul="${_brg_outdir_0}/mtgaul/flye_cpONT/assembly_graph.gfa"
	# local _mtdna_ptgaul="${_brg_outdir_0}/mtdna-ptgaul.gfa"
	local _mtdna_seq_length_ptgaul=$(_polap_lib_extract-gfa_seqlen "${_mtdna_ptgaul}")
	local _mtdna_num_seq_ptgaul=$(_polap_lib_extract-gfa_numseq "${_mtdna_ptgaul}")

	local _ptdna_annotate="${_brg_outdir_i}/polap-readassemble-pt/pt.1.gfa"
	local _ptdna_seq_length_annotate=$(_polap_lib_extract-gfa_seqlen "${_ptdna_annotate}")
	local _ptdna_num_seq_annotate=$(_polap_lib_extract-gfa_numseq "${_ptdna_annotate}")

	local _mtdna_annotate="${_brg_outdir_i}/polap-readassemble-mt/mt.1.gfa"
	local _mtdna_seq_length_annotate=$(_polap_lib_extract-gfa_seqlen "${_mtdna_annotate}")
	local _mtdna_num_seq_annotate=$(_polap_lib_extract-gfa_numseq "${_mtdna_annotate}")

	# Get system info
	local _timing_summary_data_txt="${_brg_outdir_0}/timing-summary-data.txt"
	local -A sysinfo # Local associative array
	_polap_lib_extract-system_info "${_timing_summary_data_txt}" sysinfo
	# DEBUG: sysinfo
	if [[ "${_POLAP_DEBUG}" == "1" ]]; then
		for key in $(printf "%s\n" "${!sysinfo[@]}" | sort); do
			printf "sysinfo: %-20s %s\n" "$key" "${sysinfo[$key]}" >&2
		done
	fi

	local _items=(
		"${_species}"
		"${_species_italic}"
		"${_genus}"
		"${_order}"
		"${_family}"
		"${_l_sra}"
		"${_l_sra_size_gb}"
		"${_long_coverage}"
		"${_s_sra}"
		"${_s_sra_size_gb}"
		"${_short_coverage}"
		"${_genome_size}"
		"${_memory_gb_genomesize}"
		"${_total_hours_genomesize}"
		"${_memory_gb_getorganelle}"
		"${_total_hours_getorganelle}"
		"${_memory_gb_msbwt}"
		"${_total_hours_msbwt}"
		"${_memory_gb_msbwt_polish}"
		"${_total_hours_msbwt_polish}"
		"${_memory_gb_ptgaul}"
		"${_total_hours_ptgaul}"
		"${_memory_gb_mtgaul}"
		"${_total_hours_mtgaul}"
		"${_memory_gb_nextdenovo_polish}"
		"${_total_hours_nextdenovo_polish}"
		"${_memory_gb_polap_annotate_ont_pt}"
		"${_total_hours_polap_annotate_ont_pt}"
		"${_memory_gb_polap_assemble_ont_pt}"
		"${_total_hours_polap_assemble_ont_pt}"
		"${_known_ptdna}"
		"${_known_mtdna}"
		"${_ptdna_seq_length_ptgaul}"
		"${_ptdna_num_seq_ptgaul}"
		"${_mtdna_seq_length_ptgaul}"
		"${_mtdna_num_seq_ptgaul}"
		"${_ptdna_seq_length_annotate}"
		"${_ptdna_num_seq_annotate}"
		"${_mtdna_seq_length_annotate}"
		"${_mtdna_num_seq_annotate}"
		"${_config_hostname}"
		"${sysinfo[hostname]}"
		"${sysinfo[os_version]}"
		"${sysinfo[cpu_model]}"
		"${sysinfo[cpu_cores]}"
		"${sysinfo[total_memory]}"
		"${sysinfo[storage_type]}"
		"${sysinfo[disk_size]}"
	)

	printf "%s\t" "${_items[@]::${#_items[@]}}"
	# printf "%s\t" "${_items[@]::${#_items[@]}-1}"
	# printf "%s\n" "${_items[-1]}"

	for _fc in "${_polap_oatk_options[@]}"; do
		printf "%s\t" "${memory_gb_oatk_nextdenovo[$_fc]}"
		printf "%s\t" "${total_hours_oatk_nextdenovo[$_fc]}"
	done

	for _fc in "${_polap_tippo_options[@]}"; do
		printf "%s\t" "${memory_gb_tippo_nextdenovo[$_fc]}"
		printf "%s\t" "${total_hours_tippo_nextdenovo[$_fc]}"
	done

	for _fc in "${_polap_pmat_options[@]}"; do
		printf "%s\t" "${memory_gb_pmat_nextdenovo[$_fc]}"
		printf "%s\t" "${total_hours_pmat_nextdenovo[$_fc]}"
	done

	printf "dummy\n"
}

# Table 1's row for a given outdir and inum.
#
# arg1: outdir
# arg2: inum
# arg3: disassemble-i
# arg4: 1 or 2
# arg5: target directory to copy the result
#
man-table-benchmark_genus_species() {
	local _brg_outdir="${1:-some}"
	local _brg_inum="${2:-0}"
	local _brg_type="${3:-benchmark}"
	local _brg_view="${4:-off}"

	# NOTE: delete these
	local _brg_d_index="${3:-infer-1}"
	local _brg_table="${4:-1}"
	local _brg_format="${5:-1}"
	local _brg_t_dir="${6:-"${_brg_default_target_dir}"}"

	# Set the run title
	local full_name="${FUNCNAME[0]}"
	local middle_part="${full_name#man-}"
	local run_title="${middle_part%%_*}"
	local run_title="md/${run_title%-*}"
	local table_md="${run_title}-${_brg_type}-${_brg_outdir}-${_brg_inum}.md"
	local table_md_data="${run_title}-benchmark-data-${_brg_outdir}-${_brg_inum}.md"
	local table_md_memory="${run_title}-benchmark-memory-${_brg_outdir}-${_brg_inum}.md"
	local table_md_time="${run_title}-benchmark-time-${_brg_outdir}-${_brg_inum}.md"
	local table_md_polap="${run_title}-benchmark-polap-${_brg_outdir}-${_brg_inum}.md"
	local table_md_computer="${run_title}-benchmark-computer-${_brg_outdir}-${_brg_inum}.md"
	local table_md_hostname="${run_title}-benchmark-hostname-${_brg_outdir}-${_brg_inum}.md"
	local table_tsv="${run_title}-${_brg_outdir}-${_brg_inum}.tsv"

	mkdir -p md

	if [[ "${_brg_view}" == "on" || "${_brg_view}" == "view" ]]; then
		if [[ "${_brg_type}" == "memory" ]]; then
			cat "${table_md_memory}"
		fi
		if [[ "${_brg_type}" == "time" ]]; then
			cat "${table_md_time}"
		fi
		if [[ "${_brg_type}" == "polap" ]]; then
			cat "${table_md_polap}"
		fi
		if [[ "${_brg_type}" == "computer" ]]; then
			cat "${table_md_computer}"
		fi
		if [[ "${_brg_type}" == "hostname" ]]; then
			cat "${table_md_hostname}"
		fi

		if [[ "${_brg_type}" == "data" ]]; then
			cat "${table_md_data}"
		fi
		return
	fi

	if [[ "$_POLAP_DEBUG" == "0" ]]; then
		man-table-benchmark_genus_species_header >"${table_tsv}"
	else
		man-table-benchmark_genus_species_header
	fi

	_polap_lib_conda-ensure_conda_env polap || exit 1

	if [[ "${_brg_outdir}" == "all" ]]; then
		for key in "${Sall[@]}"; do
			man-table-benchmark_genus_species_for "$key" "${@:2}" >>"${table_tsv}"
			# echo man-table-benchmark_genus_species_for "$key" "${@:2}" ">>${table_tsv}"
		done
	elif [[ "${_brg_outdir}" == "test" ]]; then
		for key in "${Stest[@]}"; do
			man-table-benchmark_genus_species_for "$key" "${@:2}" >>"${table_tsv}"
		done
	elif [[ "${_brg_outdir}" == "some" ]]; then
		for key in "${Ssome[@]}"; do
			man-table-benchmark_genus_species_for "$key" "${@:2}" >>"${table_tsv}"
		done
	elif [[ "${_brg_outdir}" == "each" ]]; then
		for key in "${Skeys[@]}"; do
			man-table-benchmark_genus_species_for "$key" "${@:2}" >>"${table_tsv}"
		done
	else
		if [[ "$_POLAP_DEBUG" == "0" ]]; then
			man-table-benchmark_genus_species_for "$@" >>"${table_tsv}"
		else
			man-table-benchmark_genus_species_for "$@"
		fi
	fi

	# Table S1. data table
	if [[ "${_brg_type}" == "data" || "${_brg_type}" == "benchmark" ]]; then
		csvtk -t cut -f _species_italic,_order,_family,_l_sra,_l_sra_size_gb,_long_coverage,_s_sra,_s_sra_size_gb,_short_coverage "${table_tsv}" |
			csvtk -t rename -f 1-9 -n Species,Order,Family,"Long SRA","Long Size","Long Coverage","Short SRA","Short Size","Short Coverage" |
			csvtk -t csv2md -a right -o "${table_md_data}"

		echo "Data: ${table_md_data}"
		cp -p "${table_md_data}" "${_brg_t_dir}"
	fi

	# Table S2. banchmarking table comparing with other tools
	if [[ "${_brg_type}" == "memory" || "${_brg_type}" == "benchmark" ]]; then
		# 2025-06-06
		# csvtk -t rename -f 1-13 -n Species,GetOrganelle,ptGAUL,MSBWT,FMLRC,NextDenovo,PMAT-0.1,PMAT-1.0,TIPPo-onthq,TIPPo-ont,Oatk-30,Oatk-20,Polap |
		csvtk -t cut -f _species_italic,_memory_gb_getorganelle,_memory_gb_ptgaul,_memory_gb_msbwt,_memory_gb_msbwt_polish,_memory_gb_nextdenovo_polish,_memory_gb_pmat_nextdenovo_0.1,_memory_gb_pmat_nextdenovo_1.0,_memory_gb_tippo_nextdenovo_onthq,_memory_gb_tippo_nextdenovo_ont,_memory_gb_oatk_nextdenovo_30,_memory_gb_oatk_nextdenovo_20,_memory_gb_polap_annotate_ont_pt,_memory_gb_polap_assemble_ont_pt "${table_tsv}" |
			csvtk -t rename -f 1-14 -n Species,GO,ptG,MSBWT,FMLRC,ND,P0.1,P1.0,Thq,Tont,O30,O20,Polap1,Polap2 |
			csvtk -t csv2md -a right -o "${table_md_memory}"

		echo "Memory: ${table_md_memory}"
		cp -p "${table_md_memory}" "${_brg_t_dir}"
	fi

	# Table S2. banchmarking table comparing with other tools
	if [[ "${_brg_type}" == "time" || "${_brg_type}" == "benchmark" ]]; then
		# 2025-06-06
		# csvtk -t rename -f 1-13 -n Species,GetOrganelle,ptGAUL,MSBWT,FMLRC,NextDenovo,PMAT-0.1,PMAT-1.0,TIPPo-onthq,TIPPo-ont,Oatk-30,Oatk-20,Polap |
		csvtk -t cut -f _species_italic,_total_hours_getorganelle,_total_hours_ptgaul,_total_hours_msbwt,_total_hours_msbwt_polish,_total_hours_nextdenovo_polish,_total_hours_pmat_nextdenovo_0.1,_total_hours_pmat_nextdenovo_1.0,_total_hours_tippo_nextdenovo_onthq,_total_hours_tippo_nextdenovo_ont,_total_hours_oatk_nextdenovo_30,_total_hours_oatk_nextdenovo_20,_total_hours_polap_annotate_ont_pt,_total_hours_polap_assemble_ont_pt "${table_tsv}" |
			csvtk -t rename -f 1-14 -n Species,GO,ptG,MSBWT,FMLRC,ND,P0.1,P1.0,Thq,Tont,O30,O20,Polap1,Polap2 |
			csvtk -t csv2md -a right -o "${table_md_time}"

		echo "Time: ${table_md_time}"
		cp -p "${table_md_time}" "${_brg_t_dir}"
	fi

	# Table S3. table for polap disassemble 5 % - n=r=5
	if [[ "${_brg_type}" == "polap" || "${_brg_type}" == "benchmark" ]]; then
		# csvtk -t cut -f _species_italic,_long_coverage,_short_coverage,_target_coverage,_P,_N,_R,_Alpha,_seq_length_ptgaul,_seq_length_subsample,_mafft_pident "${table_tsv}" |
		#   csvtk -t rename -f 1-11 -n Species,"Long Coverage","Short Coverage","Downsample Depth",P,N,R,Alpha,"Length ptGAUL","Length Polap","Percent identity" |
		#   csvtk -t csv2md -a right -o "${table_md_polap}"

		csvtk -t cut -f _species_italic,_ptdna_seq_length_ptgaul,_ptdna_seq_length_annotate,_mtdna_num_seq_ptgaul,_mtdna_seq_length_annotate "${table_tsv}" |
			csvtk -t rename -f 1-5 -n Species,"Length (ptGAUL ptDNA)","Length (Polap ptDNA)","Length (ptGAUL mtDNA)","Length (Polap mtDNA)" |
			csvtk -t csv2md -a right -o "${table_md_polap}"

		echo "Polap vs. ptGAUL: ${table_md_polap}"
		cp -p "${table_md_polap}" "${_brg_t_dir}"
	fi

	if [[ "${_brg_type}" == "computer" || "${_brg_type}" == "hostname" || "${_brg_type}" == "benchmark" ]]; then
		csvtk -t cut -f _species_italic,_config_hostname,_system_hostname,_system_os_version,_system_cpu_model,_system_cpu_cores,_system_total_memory,_system_storage_type,_system_disk_size "${table_tsv}" |
			csvtk -t rename -f 1-9 -n Species,"Config","Hostname","OS","CPU",Cores,Memory,"Storage Type","Disk Size" |
			csvtk -t csv2md -a right -o "${table_md_hostname}"
		echo "Hostname: ${table_md_hostname}"

		csvtk -t cut -f _species_italic,_system_cpu_model,_system_cpu_cores,_system_total_memory,_system_storage_type "${table_tsv}" |
			csvtk -t rename -f 1-5 -n Species,"CPU",Cores,Memory,"Storage Type" |
			csvtk -t csv2md -a right -o "${table_md_computer}"

		echo "Computer: ${table_md_computer}"
		cp -p "${table_md_computer}" "${_brg_t_dir}"
	fi

	conda deactivate

	echo "type: ${_brg_type}"
	echo "TSV: ${table_tsv}"
}

archive_genus_species_for() {
	local _brg_outdir="$1"
	local _brg_inum="${2:--1}"
	local _brg_max_filesize="${3:-1M}"

	if [[ -d "${_brg_outdir}"/t0 ]]; then
		mkdir -p Temp-t
		mv "${_brg_outdir}"/t0 Temp-t/
	fi

	rm -rf "${_brg_outdir}-a"
	rm -f "${_brg_outdir}-a.tar.gz"

	if [[ "${_brg_inum}" != "-1" ]]; then
		_log_echo "create ${_brg_outdir}-a-${_brg_inum}.tar.gz by archiving upto ${_brg_max_filesize}"
	else
		_log_echo "create ${_brg_outdir}-a.tar.gz by archiving upto ${_brg_max_filesize}"
	fi

	${_polap_cmd} disassemble archive \
		--max-filesize "${_brg_max_filesize}" \
		-o ${_brg_outdir}

	if [[ "${_brg_inum}" != "-1" ]]; then
		mv "${_brg_outdir}-a.tar.gz" "${_brg_outdir}-a-${_brg_inum}.tar.gz"
	fi

	rm -rf "${_brg_outdir}-a"

	if [[ -d "Temp-t/t0" ]]; then
		mv Temp-t/t0 "${_brg_outdir}"/
	fi
}

archive_genus_species() {
	local _brg_outdir="${1:-some}"
	local _brg_inum="${2:--1}"
	local _brg_max_filesize="${3:-1M}"

	if [[ "${_brg_outdir}" == "all" ]]; then
		for _v1 in "${Sall[@]}"; do
			archive_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "some" ]]; then
		for _v1 in "${Ssome[@]}"; do
			archive_genus_species_for "${_v1}" "${@:2}"
		done
	elif [[ "${_brg_outdir}" == "test" ]]; then
		for _v1 in "${Stest[@]}"; do
			archive_genus_species_for "${_v1}" "${@:2}"
		done
	else
		archive_genus_species_for "$@"
	fi
}

# END: manuscript
################################################################################

################################################################################
# main cases
#
# if [[ "${subcmd1}" == "help" ]]; then
#   if [[ "${_arg2}" == "arg2" ]]; then
#     subcmd1="help"
#   else
#     subcmd1="${_arg2}"
#     _arg2="arg2"
#   fi
# fi

if [[ "$_POLAP_DEBUG" == "1" ]]; then
	echo "option -y: ${opt_y_flag}"
	echo "option -c: ${opt_c_arg}"
	echo "option -t: ${opt_t_arg}"
	for item in "$@"; do
		echo "A: $item"
	done
fi

all_args=("$@") # Save all arguments to an array
# Remove the trailing slash from the first three elements of the all_args array
# the 2nd and 3rd can be species folder with a tailing slash.
# Lolium_perenne/ -> Lolium_perenne
for i in {0..2}; do
	if [[ -v all_args[i] ]]; then       # check if element is set
		if [[ -n "${all_args[i]}" ]]; then # check if it's not empty
			all_args[i]="${all_args[i]%/}"    # remove trailing slash
		fi
	fi
done
cmd_args=("${all_args[@]:1}") # Slice from index 1 onward

# Call common case first
common_handled=1
# _polap_lib_data-execute-common-subcommand "$subcmd1" "${_arg2}" "${_arg3}" "$opt_y_flag"
_polap_lib_data-execute-common-subcommand "$subcmd1" "$opt_y_flag" cmd_args
common_handled=$?

# Main case statement
case "$subcmd1" in
##### INSERT_CASE_HERE #####
main)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} <outdir> [inum:0|N]"
		echo "  $(basename ${0}) ${subcmd1} Arabidopsis_thaliana"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
test)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir:some> [index:0|N]"
		echo "  $(basename $0) ${subcmd1} some"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
example-data)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <data:${_polap_data_data}>"
		echo "  $(basename $0) ${subcmd1} 1.data"
		exit 0
	fi
	_polap_lib_data-${subcmd1} "${_arg2}"
	;;
seed)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
map)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
select)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
flye)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
dflye)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
directional)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir|all> <inum:N>"
		echo "  $(basename $0) ${subcmd1} all"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
	################################################################################
	# BEGIN: manuscript
	#
man-figure-sheet)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} <outdir> [inum:0|N] [bandage|no-bandage] [csv:sheet_benchmark.csv]"
		echo "  ${0} ${subcmd1} Arabidopsis_thaliana"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
man-figure-benchmark)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} <all|some|test|outdir> [inum:0|N] [type:memory|time|data] [view]"
		echo "  $(basename ${0}) ${subcmd1} some 2 time"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
man-pdf)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} [test|pdf]"
		echo "  $(basename ${0}) ${subcmd1}"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
archive)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <some|outdir|all|test> [inum:-1|N] [max-filesize:1M]"
		echo "  polap-data-v2.sh ${subcmd1} some -1 1M"
		echo "  polap-data-v2.sh ${subcmd1} Arabidopsis_thaliana"
		echo "  polap-data-v2.sh ${subcmd1} Arabidopsis_thaliana 0"
		echo "${help_message_archive}"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
benchmark-copy)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir:some|test> [index:0|N]"
		echo "  $(basename $0) ${subcmd1} Arabidopsis_thaliana"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
benchmark-skip)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir:some|test> [index:0|N]"
		echo "  $(basename $0) ${subcmd1} Arabidopsis_thaliana"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
benchmark-command)
	if [[ "${_arg2}" == arg2 ]]; then
		echo "Help: ${subcmd1} <outdir:some|test> [index:0|N]"
		echo "  $(basename $0) ${subcmd1} Arabidopsis_thaliana"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	[[ "${_arg3}" == arg3 ]] && _arg3=""
	${subcmd1}_genus_species "${_arg2}" "${_arg3}"
	;;
man-table-benchmark)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} <all|outdir> [inum:0|N] [benchmark|data]"
		echo "  $(basename $0) ${subcmd1}"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
benchmark)
	if [[ -z "${_arg2}" || "${_arg2}" == arg2 || "${_arg2}" == "-h" || "${_arg2}" == "--help" ]]; then
		echo "Help: ${subcmd1} <outdir1> [outdir2 ...]"
		echo "  $(basename $0) ${subcmd1} some"
		_subcmd1_clean="${subcmd1//-/_}"
		declare -n ref="help_message_${_subcmd1_clean}"
		echo "$ref"
		exit 0
	fi
	opt_y_flag=true
	${subcmd1}_genus_species "${cmd_args[@]}"
	;;
	#
	# END: manuscript
	################################################################################
"menu")
	_run_polap_menu
	;;
"delete-links")
	find . -type l -delete
	;;
*)
	# only print usage if common_case didn't handle it
	if [[ $common_handled -ne 0 ]]; then
		echo "Usage: $0 <subcommand> [species_folder]"
		echo "${help_message}"
		echo "subcommand '$subcmd1' is not recognized."
		exit 1
	fi
	;;
esac
