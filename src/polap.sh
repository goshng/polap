#!/usr/bin/env bash

# Created by argbash-init v2.10.0
# DEFINE_SCRIPT_DIR([])
# INCLUDE_PARSING_CODE([polap-parsing.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}
. "$script_dir/polap-parsing.sh" # '.' means 'source'

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# vvv  PLACE YOUR CODE HERE  vvv

################################################################################
# utilities
################################################################################

# Function to check if commands are available, taking an array as argument
function check_commands() {
	local cmd_array=("$@") # Capture all the passed arguments into an array
	for cmd in "${cmd_array[@]}"; do
		command -v "$cmd" >/dev/null 2>&1 || {
			echo >&2 "$cmd: not installed"
			return $RETURN_FAIL
		}
	done
	return $RETURN_SUCCESS
}

###############################################################################
# Checks if required main commands are available.
# called early in the code such as reset menu.
###############################################################################
# Original function that defines the array and calls check_commands
function run_check1() {
	local commands=(
		"bc"
		"seqkit"
		"minimap2"
		"flye"
		"makeblastdb"
		"tblastn"
		"bedtools"
		"prefetch"
		"jellyfish"
		"csvtk"
	)

	# Pass the array elements to the check_commands function
	check_commands "${commands[@]}"

	return $RETURN_SUCCESS
}

###############################################################################
# Checks if FMLRC related commands are available.
# called by prepare-polishing menu.
###############################################################################
function run_check2() {
	local commands=(
		"msbwt"
		"ropebwt2"
		"fmlrc"
	)

	# Pass the array elements to the check_commands function
	check_commands "${commands[@]}"

	return $RETURN_SUCCESS
}

###############################################################################
# Checks if ncbitools related commands are available.
# called by fetch
###############################################################################
function run_check3() {
	local commands=(
		"prefetch"
		"vdb-validate"
		"fasterq-dump"
	)

	# Pass the array elements to the check_commands function
	check_commands "${commands[@]}"

	return $RETURN_SUCCESS
}

###############################################################################
# You could use this function template to create a new menu.
# Rename template and delete x in the name. You could execute such menu
# but such menus are not created as empty files by make-menus menu.
###############################################################################
function _x_run_polap_template() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echoall "$0"
	echoall "$FUNCNAME"
	echoall "$1"
	echoall "$2"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

###############################################################################
# Feteches SRA data file.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   SRR10190639.fastq
###############################################################################
function _run_polap_x-ncbi-fetch-sra() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Feteches SRA data file.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   SRR10190639.fastq
Example: $(basename $0) ${_arg_menu[0]} --sra <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if ! run_check1; then
		echoerr "ERROR: change your conda environment to polap-dev."
		echoerr "INFO: (base) $ conda env create -f src/environment.yaml"
		echoerr "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi

	if [ -z "$_arg_sra" ]; then
		echoerr "ERROR: no --sra option is used."
		exit $EXIT_SUCCESS
	fi

	SRA=$_arg_sra
	"$script_dir"/run-polap-ncbitools fetch sra "$SRA"

	echoerr You have a file called "$SRA".fastq and a folder named "$SRA"
	echoerr if your download try is successful. Then, you would want to delete
	echoerr the folder because we need only the fastq file.

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Makes menu commands as empty files.
################################################################################
function _run_polap_make-menus() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	grep "^function _run_polap" "$WDIR"/polap.sh |
		grep run_polap | grep -v run_polap_x |
		sed 's/function _run_polap_//' | sed 's/() {//' |
		parallel touch {}

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Makes menu commands as empty files.
# Creates menus prefixed with x.
################################################################################
function _run_polap_make-menus-all() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	grep "^function _run_polap" "$WDIR"/polap.sh | grep run_polap | sed 's/function _run_polap_//' | sed 's/() {//' | parallel touch {}

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Deletes menu commands.
# Leaves make-menus command.
################################################################################
function _run_polap_clean-menus() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	grep "^function _run_polap" "$WDIR"/polap.sh | grep run_polap | sed 's/function _run_polap_//' | sed 's/() {//' | parallel rm -f {}
	touch make-menus

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Lists menu of POLAP.
# You need to execute make-menus menu if nothing is displayed.
################################################################################
function _run_polap_list() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Lists menu of POLAP.
# You need to execute make-menus menu if nothing is displayed.
Example: $(basename "$0") make-menus
         $(basename "$0") ${_arg_menu[0]} [all|main|assemble1|annotate|assemble2|polish]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [[ ${_arg_menu[1]} == "all" ]]; then
		find . -maxdepth 1 -type f -empty -exec basename {} \; |
			sort >&2
	elif [[ ${_arg_menu[1]} == "main" ]]; then
		echoerr assemble1
		echoerr annotate
		echoerr assemble2
		echoerr flye-polishing
		echoerr prepare-polishing
		echoerr polish
	elif [[ ${_arg_menu[1]} == "assemble1" ]]; then
		echoerr reset
		echoerr total-length-long
		echoerr find-genome-size
		echoerr reduce-data
		echoerr flye1
	elif [[ ${_arg_menu[1]} == "annotate" ]]; then
		echoerr blast-genome
		echoerr count-gene
	elif [[ ${_arg_menu[1]} == "assemble2" ]]; then
		echoerr select-reads
		echoerr flye2
	elif [[ ${_arg_menu[1]} == "polish" ]]; then
		echoerr flye-polishing
		echoerr prepare-polishing
		echoerr polish
	else
		echoerr "${help_message}"
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Runs the whole-genome assembly.
################################################################################

################################################################################
# Initializes polap analysis in a starting folder, creating an output folder.
# Arguments:
#   -o $ODIR
# Inputs: nothing
# Outputs:
#   $ODIR
################################################################################
function _run_polap_reset() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Initializes polap analysis in a starting folder, creating an output folder.
# Arguments:
#   -o $ODIR
# Inputs: nothing
# Outputs:
#   $ODIR
Example: $(basename "$0") ${_arg_menu[0]} [-o|--outdir <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if ! run_check1; then
		echoerr "ERROR: change your conda environment to polap-dev."
		echoerr "INFO: (base) $ conda env create -f src/environment.yaml"
		echoerr "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi

	if [ -d "$ODIR" -a "${_arg_yes}" = "off" ]; then
		while true; do
			read -p "Folder [$ODIR] already exists. Do you want to delete it? [y/n] " yn
			case $yn in
			[Yy]*)
				rm -rf "$ODIR"
				break
				;;
			[Nn]*)
				exit $EXIT_FAIL
				;;
			*) echo "Please answer yes or no." ;;
			esac
		done
	else
		rm -rf "$ODIR"
	fi

	mkdir -p "$ODIR"
	echoall "DATA: Your output folder [$ODIR] is created."
	if [ "$ODIR" != "o" ]; then
		echoall "Use -o $ODIR option in all subsequent analysis"
		echoall "  because your output folder is not the default of 'o'."
	fi
	_run_polap_make-menus

	echoerr NEXT: $(basename "$0") total-length-long -o "$ODIR" -l ${_arg_long_reads}
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Computes the total number of nucleotides of long-read data.
# Arguments:
#   -l $LR: a long-read fastq data file
# Inputs:
#   $LR: a long-read fastq data file
#   $ODIR
# Outputs:
#   $ODIR/long_total_length.txt
################################################################################
function _run_polap_total-length-long() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Computes the total number of nucleotides of long-read data.
# Arguments:
#   -l $LR: a long-read fastq data file
# Inputs:
#   $LR: a long-read fastq data file
#   $ODIR
# Outputs:
#   $ODIR/long_total_length.txt
Example: $(basename "$0") ${_arg_menu[0]} [-l|--long-reads <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -d "$ODIR" ]; then
		echoall "ERROR: no such output directory [$ODIR]"
		echoerr "SUGGESTION: reset"
		exit $EXIT_ERROR
	fi

	if [ ! -s "$LR" ]; then
		echoall "ERROR: no long-read data file [$LR]"
		exit $EXIT_ERROR
	fi

	echoerr "counting the total number of bases in your long-read data [$LR] ... please, wait ..."
	seqkit stats -Ta "$LR" | csvtk cut -t -f "sum_len" | csvtk del-header >"$ODIR"/long_total_length.txt
	LONG_TOTAL_LENGTH=$(cat "$ODIR"/long_total_length.txt)
	echoall "DATA: total length of your long-read data (bases): $LONG_TOTAL_LENGTH bp"

	echoerr NEXT: $(basename "$0") find-genome-size -o "$ODIR" -a "${_arg_short_read1}" -b "${_arg_short_read2}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Estimates the whole genome size using short-read data.
# Arguments:
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Outputs:
#   $ODIR/jellyfish_out.histo
#   $ODIR/short_expected_genome_size.txt
################################################################################
function _run_polap_find-genome-size() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Estimates the whole genome size using short-read data.
# Arguments:
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Inputs:
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
# Outputs:
#   $ODIR/short_expected_genome_size.txt
Example: $(basename "$0") ${_arg_menu[0]} [-a|--short-read1 <arg>] [-b|--short-read2 <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$ODIR" ]; then
		echoall "ERROR: no such output directory [$ODIR]"
		echoerr "SUGGESTION: reset"
		exit $EXIT_ERROR
	fi

	echoerr "estimating the genome size using your short-read data [$SR1] and [$SR2] ... please, wait ..."
	# See https://bioinformatics.uconn.edu/genome-size-estimation-tutorial/
	if [ -s "$SR1" ]; then
		if [ -s "$SR2" ]; then
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1" "$SR2"
		else
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1"
		fi
	else
		echoerr "ERROR: no short-read data: $SR1"
		exit $EXIT_ERROR
	fi
	jellyfish histo -o "$ODIR"/jellyfish_out.histo "$ODIR"/jellyfish_out
	"$WDIR"/run-polap-jellyfish.R \
		"$ODIR"/jellyfish_out.histo \
		"$ODIR"/short_expected_genome_size.txt

	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	echoall "DATA: expected genome size using short-read data (bases): $EXPECTED_GENOME_SIZE bp"

	echoerr NEXT: $(basename "$0") reduce-data -o "$ODIR" -l "${_arg_long_reads}" [-m "${_arg_min_read_length}"]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Checks if the long-read coverage is less than $COV.
# If so, keep the long read data.
# If not, sample long reads upto that coverage.
# Deletes long reads shorter than a sequence length threshold e.g., 3 kb.
# Arguments:
#   -l $LR: a long-read fastq data file
#   -m $MR: the long-read sequence length threshold
#   --reduction-reads (default) or --no-reduction-reads
# Inputs:
#   $ODIR/short_expected_genome_size.txt
#   $ODIR/long_total_length.txt
#   $LR
# Outputs:
#   $LRNK
################################################################################
function _run_polap_reduce-data() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Checks if the long-read coverage is less than $COV.
# If so, keep the long read data.
# If not, sample long reads upto that coverage.
# Deletes long reads shorter than a sequence length threshold e.g., 3 kb.
# Arguments:
#   -l $LR: a long-read fastq data file
#   -m $MR: the long-read sequence length threshold
#   --reduction-reads (default) or --no-reduction-reads
# Inputs:
#   $ODIR/short_expected_genome_size.txt
#   $ODIR/long_total_length.txt
#   $LR
# Outputs:
#   $LRNK
Example: $(basename $0) ${_arg_menu[0]} [-l|--long-reads <arg>] [-m|--min-read-length <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -d "$ODIR" ]; then
		echoall "ERROR: no such output directory [$ODIR]"
		echoerr "SUGGESTION: reset"
		exit $EXIT_ERROR
	fi

	if [ ! -s "$LR" ]; then
		echoall "ERROR: no long-read data file [$LR]"
		exit $EXIT_ERROR
	fi

	if [ ! -s "$ODIR"/short_expected_genome_size.txt ]; then
		echoall "ERROR: no genome size estimate [$ODIR/short_expected_genome_size.txt]"
		echoerr "SUGGESTION: find-genome-size"
		exit $EXIT_ERROR
	fi

	if [ ! -s "$ODIR"/long_total_length.txt ]; then
		echoall "ERROR: no long read total length [$ODIR/long_total_length.txt]"
		echoerr "SUGGESTION: total-length-long"
		exit $EXIT_ERROR
	fi

	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	LONG_TOTAL_LENGTH=$(cat "$ODIR"/long_total_length.txt)

	EXPECTED_LONG_COVERAGE=$(echo "scale=3; $LONG_TOTAL_LENGTH/$EXPECTED_GENOME_SIZE" | bc)
	EXPECTED_LONG_COVERAGE=${EXPECTED_LONG_COVERAGE%.*}

	echoerr "reducing your long-read data [$LR] ... please, wait ..."
	nfq_file="$ODIR"/n.fq
	rm -f $nfq_file
	if [[ ${_arg_test} == "on" ]]; then
		echoall "OPTION: --test : No reduction of the test long-read data"
		ln -s $(realpath "$LR") "$nfq_file"
	elif [[ ${_arg_reduction_reads} == "off" ]]; then
		echoall "OPTION: --no-reduction-reads : No reduction of the long-read data"
		ln -s $(realpath "$LR") "$nfq_file"
	else
		if [ "$EXPECTED_LONG_COVERAGE " -lt $COV ]; then
			echoall "LOG: No reduction of the long-read data because $EXPECTED_LONG_COVERAGE < $COV"
			ln -s $(realpath "$LR") "$nfq_file"
		else
			echoall "SUGGESTION: you might want to increase the minimum read lengths because you have enough long-read data."
			RATE=$(echo "scale=3; $COV/$EXPECTED_LONG_COVERAGE" | bc)
			echoall "LOG: long-read data reduction by rate of $RATE <= COV[$COV] / long-read coverage[$EXPECTED_LONG_COVERAGE]"
			echoall "sampling long-read data by $RATE ... wait ..."
			seqkit sample -p "$RATE" "$LR" -o "$nfq_file" >/dev/null 2>&1
			echoall "DATA: a reduced long-read data $nfq_file is created"
		fi
	fi
	LR=$nfq_file

	# step1
	echoall "LOG: keeps long reads of length being at least $MR bp ..."
	echo "LOG: deletes $LRNK"
	rm -f "$LRNK"
	# seqkit seq --quiet -m "$MR" --threads 4 "$LR" -o "$LRNK"
	seqkit seq --quiet -m "$MR" --threads 4 "$LR" -o "$LRNK" >/dev/null 2>&1
	rm "$nfq_file"
	echoall "DATA: long-read minimum $MR reads data $LRNK is created"

	echoerr "NEXT (for testing purpose only): $(basename "$0") flye1 -g 150000"
	echoerr "NEXT (for testing purpose only): $(basename "$0") flye1 --test"
	echoerr NEXT: $(basename "$0") flye1 -o "$ODIR" [-t $NT] [-c $COV]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Executes Flye for a whole-genome assembly upto the contigger stage
# Arguments:
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $ODIR/short_expected_genome_size.txt (ignored with -g option)
#   $LRNK
# Outputs:
#   $FDIR/30-contigger/contigs.fasta
#   $FDIR/30-contigger/contigs_stats.txt
#   $FDIR/30-contigger/graph_final.fasta
#   $FDIR/30-contigger/graph_final.gfa
################################################################################
function _run_polap_flye1() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Executes Flye for a whole-genome assembly upto the contigger stage
# Arguments:
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $ODIR/short_expected_genome_size.txt (ignored with -g option)
#   $LRNK
# Outputs:
#   $FDIR/30-contigger/contigs.fasta
#   $FDIR/30-contigger/contigs_stats.txt
#   $FDIR/30-contigger/graph_final.fasta
#   $FDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-t|--threads <arg>] [-c|--coverage <arg>] [-g|--genomesize <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$ODIR"/short_expected_genome_size.txt ]; then
		echoall "ERROR: no genome size file [$ODIR/short_expected_genome_size.txt]"
		echoerr "SUGGESTION: find-genome-size"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$LRNK" ]; then
		echoall "ERROR: no reduced long-read file [$LRNK]"
		echoerr "SUGGESTION: reduce-data"
		exit $EXIT_SUCCESS
	fi

	FDIR="$ODIR"/0
	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	echoall "DATA: the expected genome size based on short-read data (bases): $EXPECTED_GENOME_SIZE bp"
	if [[ ${_arg_test} == "on" ]]; then
		_arg_genomesize=150000
	fi
	if [ ! -z "$_arg_genomesize" ]; then
		EXPECTED_GENOME_SIZE=$_arg_genomesize
		echoall "OPTION: short reads expected genome size (bases) we use instead: $EXPECTED_GENOME_SIZE bp"
	fi

	echoall "INFO: executing the whole-genome assembly using flye ... be patient!"
	flye --nano-raw "$LRNK" \
		--out-dir "$FDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$EXPECTED_GENOME_SIZE" \
		--stop-after contigger \
		>/dev/null 2>&1

	echo "INFO: assembly graph in the flye contigger stage: $PWD/$FDIR/30-contigger/graph_final.gfa"
	echoerr "NEXT: $(basename $0) blast-genome -o $ODIR [-i 0]"
	echoerr "NEXT: $(basename $0) annotate -o $ODIR [-i 0]"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_blast-genome() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		INUM=0
	elif [ $# -eq 1 ]; then
		INUM=$1
	fi

	_run_polap_blast-genome

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Blasts the genome assembly of a Flye run.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $assembly_contigs_fasta
# Outputs:
#   $CONTIGNAME
#   $MTGENECOUNT
#   $PTGENECOUNT
#   $ADIR/mtaa.blast
#   $ADIR/mtaa.blast.bed
#   $MTAABLAST.sorted.bed
#   $ADIR/mtaa.bed
#   $ADIR/ptaa.blast
#   $ADIR/ptaa.blast.bed
#   $PTAABLAST.sorted.bed
#   $ADIR/ptaa.bed
################################################################################
function _run_polap_blast-genome() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	ANUM=$INUM
	MTAA="$WDIR"/polap-mt.1.c70.3.faa
	PTAA="$WDIR"/polap-pt.2.c70.3.faa
	FDIR="$ODIR"/$ANUM
	assembly_contigs_stats="$FDIR"/30-contigger/contigs_stats.txt
	assembly_contigs_fasta="$FDIR"/30-contigger/contigs.fasta
	ADIR="$FDIR"/50-annotation
	CONTIGFILE="$ADIR"/contig.fasta
	CONTIGDB="$ADIR"/contig
	MTAABLAST="$ADIR"/mtaa.blast
	MTAABED="$ADIR"/mtaa.bed
	MTGENECOUNT="$ADIR"/mt.gene.count
	PTAABLAST="$ADIR"/ptaa.blast
	PTAABED="$ADIR"/ptaa.bed
	PTGENECOUNT="$ADIR"/pt.gene.count
	CONTIGNAME="$ADIR"/contig.name

	help_message=$(
		cat <<HEREDOC
# Blasts the genome assembly of a Flye run.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $assembly_contigs_fasta
# Outputs:
#   $CONTIGNAME
#   $MTGENECOUNT
#   $PTGENECOUNT
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	echoall "please, wait for contig annotation with mitochondrial and plastid genes on $ANUM"

	if [ ! -s "$assembly_contigs_fasta" ]; then
		echoall "ERROR: no assembly file [$assembly_contigs_fasta]"
		exit $EXIT_ERROR
	fi

	if [ -d "$ADIR" ]; then
		rm -rf "$ADIR"
		echo "INFO: $ADIR is deleted."
	fi
	mkdir -p "$ADIR"
	echo "INFO: $ADIR is created."

	#src/run-polap-select.R o/30-contigger/contigs_stats.txt o/50-annotation/contig.name
	grep -v "#" "${assembly_contigs_stats}" | cut -f 1 >"$CONTIGNAME"
	echo "INFO: contig sequence names in file: $CONTIGNAME"

	# seqkit grep --threads $NT -f "$CONTIGNAME" \
	# 	"$assembly_contigs_fasta" \
	# 	-o "$ADIR"/contig.fasta \
	# 	>/dev/null 2>&1
	cp "$assembly_contigs_fasta" "$ADIR"/contig.fasta
	echo "INFO: contig sequence file: $ADIR/contig.fasta"

	makeblastdb -dbtype nucl \
		-in "$assembly_contigs_fasta" \
		-out "$ADIR"/contig \
		>/dev/null 2>&1
	echo "INFO: BLASTDB of the contig sequences: $ADIR/contig"

	# mtDNA gene annotation and counts
	echo "INFO: BLAST of the mitochondrial proteins againt $ADIR/contig"
	echo "INFO: executing the tblastn ... be patient!"
	tblastn -query "$MTAA" \
		-db "$ADIR"/contig \
		-out "$ADIR"/mtaa.blast \
		-evalue 1e-30 \
		-outfmt '6 qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle salltitles' \
		-num_threads "$NT" \
		>/dev/null 2>&1
	"$WDIR"/run-polap-genes.R "$ADIR"/mtaa.blast \
		"$ADIR"/mtaa.blast.bed \
		>/dev/null 2>&1
	sort -k1,1 -k2,2n "$ADIR"/mtaa.blast.bed >"$MTAABLAST".sorted.bed
	mkdir "$ADIR"/mtaa.bed

	echo "INFO: counting mitochondrial genes in the contigs"
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
	while IFS= read -r contig; do
		grep -w "$contig" "$MTAABLAST".sorted.bed >"$MTAABED"/"$contig".bed
		bedtools merge -i "$MTAABED"/$contig.bed >"$MTAABED"/"$contig".bed.txt
		printf "%s\t%d\n" "$contig" $(wc -l <"$MTAABED"/$contig.bed.txt)
	done <"$CONTIGNAME" | sort -k2 -rn >"$MTGENECOUNT"
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: compressing the BLAST results of mitochondrial gene annotation"
	tar zcf "$ADIR"/mtaa.bed.tar.gz "$ADIR"/mtaa.bed
	rm -rf "$ADIR"/mtaa.bed

	# Plastid gene annotation and counts
	echo "INFO: BLAST of the plastid proteins againt $ADIR/contig"
	echo "INFO: executing the tblastn ... be patient!"
	tblastn -query "$PTAA" \
		-db "$ADIR"/contig \
		-out "$ADIR"/ptaa.blast \
		-evalue 1e-30 -outfmt '6 qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle salltitles' \
		-num_threads $NT \
		>/dev/null 2>&1
	"$WDIR"/run-polap-genes.R "$ADIR"/ptaa.blast \
		"$ADIR"/ptaa.blast.bed \
		>/dev/null 2>&1
	sort -k1,1 -k2,2n "$ADIR"/ptaa.blast.bed >"$PTAABLAST".sorted.bed
	mkdir "$ADIR"/ptaa.bed

	echo "INFO: counting plastid genes in the contigs"
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
	while IFS= read -r contig; do
		grep -w "$contig" "$PTAABLAST".sorted.bed >"$PTAABED"/$contig.bed
		bedtools merge -i "$PTAABED"/$contig.bed >"$PTAABED"/$contig.bed.txt
		printf "%s\t%d\n" "$contig" $(wc -l <"$PTAABED"/$contig.bed.txt)
	done <"$CONTIGNAME" | sort -k2 -rn >"$PTGENECOUNT"
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: compressing the BLAST results of plastid gene annotation"
	tar zcf "$ADIR"/ptaa.bed.tar.gz "$ADIR"/ptaa.bed
	rm -rf "$ADIR"/ptaa.bed

	echoerr "NEXT (for testing purpose only): $(basename "$0") count-gene --test"
	echoerr "NEXT: $(basename $0) count-gene -o $ODIR [-i $INUM]"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_count-gene() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		INUM=0
	elif [ $# -eq 1 ]; then
		INUM=$1
	fi

	_run_polap_count-gene

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Counts genes annotated on a genome assembly.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $FDIR/30-contigger/contigs_stats.txt
#   $MTGENECOUNT
#   $PTGENECOUNT
# Outputs:
#   $FDIR/mt.contig.name-1
#   $FDIR/mt.contig.name-2
#   $FDIR/assembly_info_organelle_annotation_count.txt
#   $FDIR/assembly_info_organelle_annotation_count-all.txt
#   $FDIR/contig-annotation-table.txt
################################################################################
function _run_polap_count-gene() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	ANUM=$INUM
	FDIR="$ODIR"/$ANUM
	ADIR="$FDIR"/50-annotation
	MTGENECOUNT="$ADIR"/mt.gene.count
	PTGENECOUNT="$ADIR"/pt.gene.count

	help_message=$(
		cat <<HEREDOC
# Counts genes annotated on a genome assembly.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $FDIR/30-contigger/contigs_stats.txt
#   $MTGENECOUNT
#   $PTGENECOUNT
# Outputs:
#   $FDIR/mt.contig.name-1
#   $FDIR/mt.contig.name-2
#   $FDIR/assembly_info_organelle_annotation_count.txt
#   $FDIR/assembly_info_organelle_annotation_count-all.txt
#   $FDIR/contig-annotation-table.txt 
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	echoall "INFO: count mitochondrial and plastid genes on $ANUM"

	"$WDIR"/run-polap-mtcontig.R "$FDIR" \
		"$FDIR"/mt.contig.name \
		"$FDIR"/assembly_info_organelle_annotation_count.txt \
		"$FDIR"/assembly_info_organelle_annotation_count-all.txt \
		--contigger \
		>/dev/null 2>&1

	echoall "USE: assembly graph: "$PWD"/"$FDIR"/30-contigger/graph_final.gfa"
	echoall "USE: the following three count tables"
	echoall "column -t "$FDIR"/assembly_info_organelle_annotation_count-all.txt | less -S"
	echoall "column -t "$FDIR"/assembly_info_organelle_annotation_count.txt | less -S"
	echoall "column -t "$FDIR"/contig-annotation-table.txt | less -S"
	if [[ ${_arg_test} == "on" ]]; then
		echoall "LOG: creating $FDIR/mt.contig.name-1 for testing purpose"
		echoall "LOG: you would have to edit it for a real data-set."
		echo edge_1 >"$FDIR"/mt.contig.name-1
		echo edge_2 >>"$FDIR"/mt.contig.name-1
		echo edge_3 >>"$FDIR"/mt.contig.name-1
	fi
	echoerr "Example file: $FDIR/mt.contig.name-1"
	echoerr "edge_1"
	echoerr "edge_2"
	echoerr "edge_3"
	echoall "INFO: edit $FDIR/mt.contig.name-1 for mtDNA contig candidates"
	echo "INFO: edit $FDIR/mt.contig.name-<destination flye number> for mtDNA contig candidates"

	ANUMNEXT=$((ANUM + 1))
	echoerr NEXT: $(basename "$0") select-reads -o "$ODIR" [-i $ANUM] [-j $ANUMNEXT]
	echoerr NEXT: $(basename "$0") assemble2 -o "$ODIR" [-i $ANUM] [-j $ANUMNEXT]
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_select-reads() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		INUM=0
		JNUM=1
	elif [ $# -eq 1 ]; then
		INUM=0
		JNUM=$1
	elif [ $# -eq 2 ]; then
		INUM=$1
		JNUM=$2
	fi

	_run_polap_select-reads

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects reads mapped on a genome assembly.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTSEEDSDIR
#   $MTDIR/contig.fa
#   $MTDIR/contig_total_length.txt
#   $MTDIR/contig.paf
#   $MTDIR/contig.tab
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/1.fq.gz
#   $MTSEEDSDIR/2.fq.gz
################################################################################
function _run_polap_select-reads() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	ADIR="$FDIR"/50-annotation
	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	MTCONTIGNAME="$FDIR"/mt.contig.name-$JNUM

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta

	help_message=$(
		cat <<HEREDOC
# Selects reads mapped on a genome assembly.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/2.fq.gz
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>] [-r|--pair-min <arg>] [-x|--bridge-min <arg>] [-w|--single-min <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTCONTIGNAME" ]; then
		echoall "ERROR: no such mt.contig.name file: $MTCONTIGNAME"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${assembly_graph_final_fasta}" ]; then
		echoall "ERROR: no assembly fasta file: ${assembly_graph_final_fasta}"
		exit $EXIT_ERROR
	fi

	if [ -d "$MTDIR" ] && [ "${_arg_yes}" = "off" ]; then
		while true; do
			read -r -p "Folder [$MTDIR] already exists. Do you want to replace it? [y/n] " yn
			case $yn in
			[Yy]*)
				rm -rf "$MTDIR"
				echo "INFO: $MTDIR is deleted."
				break
				;;
			[Nn]*)
				echoall "INFO: [$MTDIR] is not replaced."
				echoerr "you might want a new mt.contig.name file for flye2 step."
				exit $EXIT_FAIL
				;;
			*) echo "Please answer yes or no." ;;
			esac
		done
	else
		rm -rf "$MTDIR"
		echo "INFO: $MTDIR is deleted if there is one."
	fi

	echo "$CMD" >"$ODIR"/organelle-assembly_"${INUM}"-"${JNUM}"

	mkdir -p "$MTSEEDSDIR"
	ln -s "$PWD"/"$ODIR"/nk.fq.gz -t "$MTDIR"
	echoall "INFO: extracts contigs from the assembly ${assembly_graph_final_fasta}"
	echo "INFO: uses mt.contig.name at $MTCONTIGNAME"
	echoerr "FILE: reading contigs in $MTCONTIGNAME"
	cat "$MTCONTIGNAME" >&2
	echoerr "please, wait for a long-read data selection ... $INUM -> $JNUM ... bridge=$MBRIDGE p_mapping=$MPAIR s_mapping=$MSINGLE min_len_read=$MR"
	seqkit grep --threads "$NT" -f "$MTCONTIGNAME" "${assembly_graph_final_fasta}" -o "$MTDIR"/contig.fa >/dev/null 2>&1

	contig_count=$(wc -l <"$MTCONTIGNAME")
	if [[ $CIRCULARIZE == "on" ]]; then
		if [ "$contig_count" -eq 1 ]; then
			seqkit fx2tab --length --name "$MTDIR"/contig.fa -o "$MTDIR"/contig.fa.len >/dev/null 2>&1
			A=$(cut -f2 "$MTDIR"/contig.fa.len)
			B=$(echo "scale=0; $A/2" | bc)
			C=$((B + 1))
			seqkit subseq -r 1:"$B" "$MTDIR"/contig.fa -o "$MTDIR"/c1.fa >/dev/null 2>&1
			seqkit subseq -r "$C":"$A" "$MTDIR"/contig.fa -o "$MTDIR"/c2.fa >/dev/null 2>&1
			cat "$MTDIR"/c?.fa | seqkit replace -p '.+' -r 'edge_{nr}' -o "$MTDIR"/contig.fa >/dev/null 2>&1
			cp "$MTCONTIGNAME" "$MTCONTIGNAME"-backup
			echo -e "edge_1\nedge_2" >"$MTCONTIGNAME"
			echo "INFO: creates new $MTDIR/contig.fa and $MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit $EXIT_ERROR
			# "$WDIR"/run-polap-single.R "$MTSEEDSDIR"/contig.tab "$MTSEEDSDIR" "$MSINGLE" >/dev/null 2>&1
			# cat "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
			# echo "INFO: creates long read single name in $MTSEEDSDIR/1.names"
		fi
	fi
	echo "DATA: $MTDIR/contig.fa is created."

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	if [[ -s "$MTDIR"/contig.paf ]]; then
		echo "DATA: previously created $MTDIR/contig.paf is used without executing minimap2."
	else
		minimap2 -cx map-ont "$MTDIR"/contig.fa "$LRNK" -t "$NT" -o "$MTDIR"/contig.paf >/dev/null 2>&1
		echo "DATA: $LRNK is used to select reads."
		echo "DATA: $MTDIR/contig.paf is created."
	fi

	cut -f1-11 "$MTDIR"/contig.paf | awk -v minlength="$MR" '{if ($2>=minlength) {print}}' >"$MTDIR"/contig.tab
	echo "DATA: minimum length of long reads in the read selection: $MR"
	echo "DATA: $MTDIR/contig.tab is created."

	# MT: MPAIR=3000 MBRIDGE=3000 MSINGLE=3000
	# PT: MPAIR=1000 MBRIDGE=5000 MSINGLE=0
	Rscript --vanilla "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" "$MTDIR"/contig.tab "$MTSEEDSDIR" "$MPAIR" "$MBRIDGE" "$MSINGLE" >/dev/null 2>&1
	# "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" $MTDIR/contig.tab $MTSEEDSDIR $MPAIR $MBRIDGE $MSINGLE >/dev/null 2>&1
	echo "OPTION polap pairs alignment minimum: $MPAIR"
	echo "OPTION polap pairs bridge minimum: $MBRIDGE"
	echo "DATA: pair contig names in $MTSEEDSDIR are created."
	echo "DATA: single contig name in $MTSEEDSDIR is created."

	# cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	cat "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	echo "INFO: creates long read names and the single name in $MTSEEDSDIR/1.names"

	# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names $LRNK -o "$MTSEEDSDIR"/1.fq.gz >/dev/null 2>&1
	seqtk subseq "$LRNK" "$MTSEEDSDIR"/1.names | gzip >"$MTSEEDSDIR"/1.fq.gz
	echo "DATA: organelle reads in $MTSEEDSDIR/1.fq.gz"

	TOTAL_LENGTH=$(seqkit stats -Ta "$MTSEEDSDIR"/1.fq.gz | csvtk cut -t -f "sum_len" | csvtk del-header)
	EXPECTED_ORGANELLE_COVERAGE=$((TOTAL_LENGTH / CONTIG_LENGTH))
	echo "INFO: expected coverage: ${EXPECTED_ORGANELLE_COVERAGE}x"

	if [[ "${_arg_test}" == "on" ]]; then
		echoall "OPTION: --test : No reduction of the test long-read data"
		ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
	elif [[ "${_arg_coverage_check}" == "off" ]]; then
		echoall "OPTION: --no-coverage-check : No reduction of the long-read data"
		ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
	else
		if [ "$EXPECTED_ORGANELLE_COVERAGE" -lt "$COV" ]; then
			echoall "LOG: No reduction of the long-read data because $EXPECTED_ORGANELLE_COVERAGE < $COV"
			ln -s "$(realpath "$MTSEEDSDIR"/1.fq.gz)" "$MTSEEDSDIR"/2.fq.gz
		else
			echoall "SUGGESTION: you might want to increase the minimum read lengths because you have enough long-read data."
			RATE=$(echo "scale=10; $COV/$EXPECTED_ORGANELLE_COVERAGE" | bc)
			echoall "LOG: long-read data reduction by rate of $RATE <= COV[$COV] / long-read organelle coverage[$EXPECTED_ORGANELLE_COVERAGE]"
			echoall "sampling long-read data by $RATE ... wait ..."
			seqkit sample -p "$RATE" "$MTSEEDSDIR/1.fq.gz" -o "$MTSEEDSDIR/2.fq.gz" >/dev/null 2>&1
			echoall "DATA: a reduced long-read data $MTSEEDSDIR/2.fq.gz is created"
		fi
	fi

	C=$(ls -1 "$MTSEEDSDIR/"*".name" 2>/dev/null | wc -l)
	if [ "$C" != 0 ]; then
		echo "INFO: bridging reads exist: combinations of $C."
		seqkit seq -n -i "$MTSEEDSDIR"/2.fq.gz >"$MTSEEDSDIR"/single.names.2
		cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names.2 | sort | uniq >"$MTSEEDSDIR"/1.names.2
		# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names.2 $LRNK -o "$MTSEEDSDIR"/2.fq.gz >/dev/null 2>&1
		seqtk subseq "$LRNK" "$MTSEEDSDIR"/1.names.2 | gzip >"$MTSEEDSDIR"/2.fq.gz
	fi
	echoall "DATA: organelle reads in $MTSEEDSDIR/2.fq.gz"

	# put the backup to the original
	if [[ $CIRCULARIZE == "on" ]]; then
		if [[ -s "$MTCONTIGNAME"-backup ]]; then
			mv "$MTCONTIGNAME"-backup "$MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit $EXIT_ERROR
		fi
	fi

	echoerr NEXT: "$(basename "$0")" flye2 -o "$ODIR" -j "$JNUM" -t "$NT" -c "$COV"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Called in the script not by users.
# -i or --inum option is ignored.
################################################################################
function _func_polap_flye2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		JNUM=1
	else
		JNUM=$1
	fi

	_run_polap_flye2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Executes Flye for an organelle-genome assembly
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
# Outputs:
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
################################################################################
function _run_polap_flye2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: organelle-genome assembly on $JNUM"

	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	help_message=$(
		cat <<HEREDOC
# Executes Flye for an organelle-genome assembly
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
# Outputs:
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-j|--jnum <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTDIR/contig.fa" ]; then
		echoall "ERROR: no selected-contig file [$MTDIR/contig.fa]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTSEEDSDIR/2.fq.gz" ]; then
		echoall "ERROR: no long-read file [$MTSEEDSDIR/2.fq.gz]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: executing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for an organelle-genome assembly on $JNUM ..."
	flye --nano-raw "$MTSEEDSDIR"/2.fq.gz \
		--out-dir "$MTDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$CONTIG_LENGTH" \
		--stop-after contigger \
		>/dev/null 2>&1
	echoall "CHECK: assembly graph "$PWD/$MTDIR"/30-contigger/graph_final.gfa"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"

	jnum_next=$((JNUM + 1))
	echoall Create and edit $ODIR/$JNUM/mt.contig.name-${jnum_next}
	echoall NEXT: "$(basename "$0")" assemble2 -o "$ODIR" -j ${jnum_next}
	echoall or you could finish with Flye organelle-genome assembly with its polishing stage.
	echoall NEXT: "$(basename "$0")" flye-polishing -o "$ODIR" -j "$JNUM"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Finishes the Flye organelle-genome assembly.
# Polishes an organelle-genome assembly using long-reads.
# Note: use the same options as flye2 menu.
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/30-contigger
# Outputs:
#   $MTDIR/assembly_graph.gfa
################################################################################
function _run_polap_flye-polishing() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: polishing organelle-genome assembly on $JNUM"

	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	help_message=$(
		cat <<HEREDOC
# Finishes the Flye organelle-genome assembly.
# Polishes an organelle-genome assembly using long-reads.
# Note: use the same options as flye2 menu.
# Arguments:
#   -j $JNUM: destination Flye organelle assembly number
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/30-contigger
# Outputs:
#   $MTDIR/assembly_graph.gfa
Example: $(basename "$0") ${_arg_menu[0]} [-j|--jnum <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTDIR/contig.fa" ]; then
		echoall "ERROR: no selected-contig file [$MTDIR/contig.fa]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTSEEDSDIR/2.fq.gz" ]; then
		echoall "ERROR: no long-read file [$MTSEEDSDIR/2.fq.gz]"
		echoerr "SUGGESTION: select-reads"
		exit $EXIT_SUCCESS
	fi

	CONTIG_LENGTH=$(seqkit stats -Ta "$MTDIR"/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: polishing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for Flye long-read polishing the organelle-genome assembly on $JNUM ..."
	flye --nano-raw "$MTSEEDSDIR"/2.fq.gz \
		--out-dir "$MTDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$CONTIG_LENGTH" \
		--resume \
		>/dev/null 2>&1
	echoall "CHECK: the long-read polished assembly graph $PWD/$MTDIR/assembly_graph.gfa"
	echoerr "DO: extract a draft organelle genome sequence (mt.0.fasta) from the polished assembly graph"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"
	# echoall NEXT: $(basename $0) check-coverage [-p $PA]
	echoall NEXT: "$(basename "$0")" prepare-polishing -a "$SR1" -b "$SR2"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --sra SRR10190639
################################################################################
function _run_polap_x-ncbi-fetch-sra-runinfo() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --sra SRR10190639
# Outputs:
#   bases
Example: $(basename $0) ${_arg_menu[0]} --sra <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_sra" ]; then
		echoerr "ERROR: no --sra option is used."
		exit $EXIT_SUCCESS
	fi

	echoerr "counting bases in SRA database and its downloaded FASTQ files of SRA [${_arg_sra}] ..."
	bases=$(esearch -db sra -query "${_arg_sra}" |
		efetch -format runinfo |
		csvtk cut -f "bases" |
		csvtk del-header)
	echoall "SRA: ${_arg_sra}: ${bases} (bp)"

	bases2=$(seqkit stats -T "${_arg_sra}"*.fastq 2>/dev/null | csvtk cut -t -f "sum_len" | paste -s -d+ - | bc)
	echoall "FASTQ: ${_arg_sra}*.fastq: ${bases2} (bp)"

	if [ "${bases}" -eq "${bases2}" ]; then
		echoall "LOG: SRA ${_arg_sra} and its FASTQ files: total bases match."
	else
		echoall "ERROR: SRA ${_arg_sra} and its FASTQ files: total bases do not match."
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --species
################################################################################
function _run_polap_x-ncbi-fetch-mtdna-genbank() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --species species-name
# Inputs:
#   species-name
# Outputs:
#   species-name.mt.gb
Example: $(basename "$0") ${_arg_menu[0]} --species <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_species" ]; then
		echoerr "ERROR: no --species option is used."
	else
		S="${_arg_species// /-}"
		esearch -db nuccore -query "(mitochondrion[Title] AND complete[Title] AND genome[Title]) AND ${_arg_species}[Organism]" |
			efetch -format gb >"${S}".mt.gb
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Fetches mtDNA genome sequence by accession.
# Arguments:
#   --accession
# Inputs:
#   accession ID
# Outputs:
#   <accession>.fa
################################################################################
function _run_polap_x-ncbi-fetch-mtdna-nucleotide() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Fetches mtDNA genome sequence by species name.
# Arguments:
#   --accession <arg>
# Inputs:
#   accession ID
# Outputs:
#   <accession>.fa
Example: $(basename "$0") ${_arg_menu[0]} --accession <arg>
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_accession" ]; then
		echoerr "ERROR: no --accession option is used."
	else
		esearch -db nuccore -query "${_arg_accession}[ACCN]" </dev/null |
			efetch -format fasta >"${_arg_accession}".fa
		echoall "NEXT: $(basename "$0") align-two-dna-sequences --query mt.1.fa --subject ${_arg_accession}.fa"
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Uses BLAST to align two very similar DNA sequences.
# Before align the two sequences, rearrange the assembled query sequences
# so that they are alignable using multiple sequence alignment tools
# like ClustalW.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
# Outputs:
#   pairwise-alignment.txt
################################################################################
function _run_polap_x-align-two-dna-sequences() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Uses BLAST to align two very similar DNA sequences.
# Before align the two sequences, rearrange the assembled query sequences
# so that they are alignable using multiple sequence alignment tools
# like ClustalW.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
# Outputs:
#   pairwise-alignment.txt
Example: $(basename "$0") ${_arg_menu[0]} [--query <arg>] [--subject <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$_arg_query" -a -z "$_arg_subject" ]; then
		echoerr "ERROR: no --query and --subject option are used."
		echoerr "INFO: --query mt.1.fa --subject NCBI.fa"
		echoerr "INFO: seqkit seq -p -r mt.1.fa -o mt.1r.fa"
		echoerr "INFO: seqkit restart -i <POS> mt.1.fa -o mt.2.fa"
	else
		blastn -query "$_arg_query" -subject "$_arg_subject" >pairwise-alignment.txt
		echoerr "INFO: seqkit seq -p -r mt.1.fa -o mt.1r.fa"
		echoerr "INFO: seqkit restart -i <POS> mt.1.fa -o mt.2.fa"
		echoerr "INFO: $(basename "$0") clustal --query mt.2.fa --subject NCBI-ACC.fa"
		echoerr see pairwise-alignment.txt
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Uses clustalw to align two DNA sequences.
# After rearranging parts of a query assembled sequence,
# we use clustalw to align the two to check how similar they are.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
################################################################################
function _run_polap_x-clustal() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Uses clustalw to align two DNA sequences.
# After rearranging parts of a query assembled sequence,
# we use clustalw to align the two to check how similar they are.
# Arguments:
#   --query ${_arg_query}
#   --subject ${_arg_subject}
# Inputs:
#   query: mt.1.fa or the assembled sequence
#   subject: a known mtDNA sequence
Example: $(basename "$0") ${_arg_menu[0]} [--query <arg>] [--subject <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [[ -s x.aln ]]; then
		echoall "INFO: clustalw alignemnt is found."
	else
		local MT1=$_arg_query
		shift
		local MT2=$_arg_subject
		shift
		command -v clustalw2 >/dev/null 2>&1 || {
			echo >&2 "clustalw2: not installed"
			exit 1
		}
		cat "$MT1" "$MT2" >x.fa
		clustalw2 x.fa
	fi
	# TODO: works for only Linux.
	GAP1=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	GAP2=$(sed -n '5~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	MATCH=$(sed -n '6~4p' x.aln | tr -dc '*' | wc -c)
	TOTAL=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | wc -c)
	GAP=$((GAP1 + GAP2))
	MISMATCH=$((TOTAL - MATCH - GAP))
	echoall "INFO: pairwise alignment:   length: $TOTAL"
	echoall "INFO: pairwise alignment:    match: $MATCH"
	echoall "INFO: pairwise alignment: mismatch: $MISMATCH"
	echoall "INFO: pairwise alignment:     gaps: $GAP"
	LENGTH1=$(seqkit stats -Ta "$_arg_subject" | csvtk cut -t -f "sum_len" | csvtk del-header)
	LENGTH2=$(seqkit stats -Ta "$_arg_query" | csvtk cut -t -f "sum_len" | csvtk del-header)
	NAME1=$(seqkit seq -n -i "$_arg_subject")
	NAME2=$(seqkit seq -n -i "$_arg_query")
	echoall "INFO: Sequence1: $NAME1"
	echoall "INFO: SequenceLen1: $LENGTH1"
	echoall "INFO: Sequence2: $NAME2"
	echoall "INFO: SequenceLen2: $LENGTH2"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Checks the coverage using samtools.
# Arguments:
#   -p mt.0.fasta
# Inputs:
#   $LRNK
#   $PA
# Outputs:
#   $FA
################################################################################
function _run_polap_x-check-coverage() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# NOT IMPLEMENTED YET
# Checks the coverage on a draft genome using samtools.
# Arguments:
#   -p $PA: a draft genome
# Inputs:
#   $LRNK
#   $PA
# Outputs:
Example: $(basename "$0") ${_arg_menu[0]} [-p|--unpolished-fasta <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ -z "$PA" ] && [ -z "$LRNK" ]; then
		echoerr "ERROR: no -p option are used."
		echoerr "INFO: --p mt.0.fasta"
	else
		echo "INFO: executing minimap2 and samtools for checking the long reads coverage on the $PA ... be patient!"
		if [[ ! -s "$PA" ]]; then
			echoall "ERROR: no such file $PA"
			exit $EXIT_ERROR
		fi

		if [[ ! -s "$LRNK" ]]; then
			echoall "ERROR: no such file $LRNK"
			exit $EXIT_ERROR
		fi

		minimap2 -t "$NT" -ax map-ont "$PA" "$LRNK" 2>/dev/null |
			samtools view -u 2>/dev/null |
			samtools sort -o "$ODIR"/1.bam \
				>/dev/null 2>&1
		samtools coverage -A -w 32 "$ODIR"/1.bam 1>&2

		echoerr INFO: conda env create -f "$WDIR"/environment-fmlrc.yaml
		echoerr INFO: conda activate polap-fmlrc
		echoerr "NEXT: $(basename "$0") prepare-polishing [-a s1.fq] [-b s2.fq]"
	fi

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Prepares the polishing using FMLRC.
# Arguments:
#   -a s1.fq
#   -b s2.fq
# Inputs:
#   s1.fq
#   s2.fq
# Outputs:
#   $$ODIR/msbwt
################################################################################
function _run_polap_prepare-polishing() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Prepares the polishing using FMLRC.
# Arguments:
#   -a $SR1
#   -b $SR2
# Inputs:
#   $SR1
#   $SR2
# Outputs:
#   $ODIR/msbwt/comp_msbwt.npy
Example: $(basename "$0") ${_arg_menu[0]} [-a|--short-read1 <arg>] [-b|--short-read2 <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	source $HOME/miniconda3/bin/activate polap-fmlrc

	if ! run_check2; then
		echoerr "ERROR: change your conda environment to polap-fmlrc."
		echoerr "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		echoerr "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	if [[ ! -s $SR1 ]]; then
		echo "ERROR: no short-read data file found: $SR1"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR2 ]]; then
		echo "ERROR: no short read-data file found: $SR2"
		exit $EXIT_ERROR
	fi

	echo "INFO: excuting ropebwt2 and msbwt on the short reads ... be patient!"
	if [[ $SR1 = *.fastq || $SR1 = *.fq ]]; then
		cat "$SR1" "$SR2" |
			awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN |
			msbwt convert "$ODIR"/msbwt \
				>/dev/null 2>&1
	elif [[ $SR1 = *.fq.gz ]] || [[ $SR1 = *.fastq.gz ]]; then
		zcat "$SR1" "$SR2" |
			awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN |
			msbwt convert "$ODIR"/msbwt \
				>/dev/null 2>&1
	fi

	echoerr "NEXT: $(basename $0) polish [-p mt.0.fasta] [-f mt.1.fa]"

	conda deactivate

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Polishes using FMLRC.
# Arguments:
#   -p mt.0.fasta
#   -f mt.1.fa
# Inputs:
#   $ODIR/msbwt/comp_msbwt.npy
#   $PA
# Outputs:
#   $FA
################################################################################
function _run_polap_polish() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Polishes using FMLRC.
# Arguments:
#   -p $PA: a long-read draft genome assembly
#   -f $FA: a final genome assembly sequence name
# Inputs:
#   $ODIR/msbwt/comp_msbwt.npy
#   $PA
# Outputs:
#   $FA
Example: $(basename "$0") ${_arg_menu[0]} [-p|--unpolished-fasta <arg>] [-f|--final-assembly <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	source $HOME/miniconda3/bin/activate polap-fmlrc

	if ! run_check2; then
		echoerr "ERROR: change your conda environment to polap-fmlrc."
		echoerr "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		echoerr "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	if [[ ! -s "$ODIR/msbwt/comp_msbwt.npy" ]]; then
		echoall "ERROR: no msbwt at $ODIR/msbwt/comp_msbwt.npy"
		echoall "HINT: $0 prepare-polishing [-a s1.fq] [-b s2.fq]"
		exit $EXIT_ERROR
	fi

	echo "INFO: executing fmlrc on the draft sequence $PA ... be patient!"
	if [[ -s $PA ]]; then
		fmlrc -p "$NT" "$ODIR"/msbwt/comp_msbwt.npy "$PA" "$FA" >/dev/null 2>&1
	else
		echo "ERROR: no unpolished fasta file: [$PA]"
		exit $EXIT_ERROR
	fi

	conda deactivate

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Runs the whole-genome assembly.
# Defaults:
#   l.fq
#   s1.fq
#   s2.fq
#   number of threads: $NT
#   assembly coverage: $COV
# Outputs:
#   $ODIR/long_total_length.txt
#   $ODIR/jellyfish_out.histo
#   $ODIR/short_expected_genome_size.txt
#   $LRNK
#   $FDIR
################################################################################
function _run_polap_assemble1() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	help_message=$(
		cat <<HEREDOC
# Runs the whole-genome assembly.
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
#   -m $MR: the long-read sequence length threshold
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $LR: a long-read fastq 
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
ta file
# Outputs:
#   $ODIR/long_total_length.txt
#   $ODIR/short_expected_genome_size.txt
#   $LRNK
#   $FDIR/30-contigger/contigs.fasta
#   $FDIR/30-contigger/contigs_stats.txt
#   $FDIR/30-contigger/graph_final.fasta
#   $FDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-o|--outdir <arg>] [-l|--long-reads <arg>] [-a|--short-read1 <arg>] [-b|--short-read2 <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [[ ! -s $LR ]]; then
		echoerr "ERROR: no long-read data file found: $LR"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR1 ]]; then
		echoerr "ERROR: no short-read data file found: $SR1"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR2 ]]; then
		echoerr "ERROR: no short read-data file found: $SR2"
		exit $EXIT_ERROR
	fi

	echoerr "NEXT: $(basename $0) reset -o $ODIR"
	_run_polap_reset
	_run_polap_total-length-long
	_run_polap_find-genome-size
	_run_polap_reduce-data
	_run_polap_flye1

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Called in the script not by users.
################################################################################
function _func_polap_annotate() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		ANUM=0
	else
		ANUM=$1
	fi

	_func_polap_blast-genome "$ANUM"
	_func_polap_count-gene "$ANUM"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Annotates the genome assembly.
# Defaults:
# Outputs:
################################################################################
function _run_polap_annotate() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	ANUM=$INUM
	FDIR="$ODIR"/$ANUM
	assembly_contigs_stats="$FDIR"/30-contigger/contigs_stats.txt
	assembly_contigs_fasta="$FDIR"/30-contigger/contigs.fasta
	ADIR="$FDIR"/50-annotation
	MTGENECOUNT="$ADIR"/mt.gene.count
	PTGENECOUNT="$ADIR"/pt.gene.count
	CONTIGNAME="$ADIR"/contig.name

	help_message=$(
		cat <<HEREDOC
# Annotates the genome assembly.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $assembly_contigs_stats
#   $assembly_contigs_fasta
# Outputs:
#   $CONTIGNAME
#   $MTGENECOUNT
#   $PTGENECOUNT
#   $FDIR/mt.contig.name-1
#   $FDIR/mt.contig.name-2
#   $FDIR/assembly_info_organelle_annotation_count.txt
#   $FDIR/assembly_info_organelle_annotation_count-all.txt
#   $FDIR"/contig-annotation-table.txt 
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	echoerr "NEXT: $(basename "$0") blast-genome -i $INUM"
	_run_polap_blast-genome
	_run_polap_count-gene

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects contigs for an organelle-genome assembly.
#
# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
# 3. For a given gfa of a genome assembly graph, subset the graph for selecting graph elements in the range.
# 4. Determine connected components in the subset.
# 5. Choose connected components with candidate edges.
#
# We need to read GFA files to manipulate.
# We need to determine connected components.
################################################################################
function _run_polap_select-contigs() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	MTCONTIGNAME="$FDIR"/mt.contig.name-"$JNUM"
	_polap_var_mtcontigs="$FDIR"/"$JNUM"/mtcontigs

	# ADIR="$FDIR"/50-annotation
	# MTDIR="$ODIR"/$JNUM
	# MTSEEDSDIR="$MTDIR"/seeds

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	_polap_var_assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta
	_polap_var_assembly_graph_final_gfa="$FDIR"/30-contigger/graph_final.gfa
	_polap_var_annonation_table="$FDIR"/assembly_info_organelle_annotation_count-all.txt

	_polap_var_mtcontig_annotated=${_polap_var_mtcontigs}/1-mtcontig.annotated.txt
	_polap_var_mtcontigs_stats=${_polap_var_mtcontigs}/1-mtcontig.stats.txt
	_polap_var_gfa_all=${_polap_var_mtcontigs}/2-gfa.all.gfa
	_polap_var_gfa_seq_part=${_polap_var_mtcontigs}/2-gfa.seq.part.tsv
	_polap_var_gfa_seq_filtered=${_polap_var_mtcontigs}/2-gfa.seq.filtered.txt
	_polap_var_gfa_seq_filtered_range=${_polap_var_mtcontigs}/2-gfa.seq.filtered.range.txt
	_polap_var_gfa_seq_filtered_edge=${_polap_var_mtcontigs}/2-gfa.seq.filtered.edge.txt
	_polap_var_gfa_link_part=${_polap_var_mtcontigs}/gfa.link.part.tsv
	_polap_var_gfa_seq_filtered_link_added=${_polap_var_mtcontigs}/gfa.seq.filtered.link.added.txt
	_polap_var_gfa_filtered=${_polap_var_mtcontigs}/2-gfa.filtered.gfa
	_polap_var_gfa_links=${_polap_var_mtcontigs}/3-gfa.links.tsv
	_polap_var_gfa_links_number=${_polap_var_mtcontigs}/3-gfa.links.number.txt
	_polap_var_gfa_links_order=${_polap_var_mtcontigs}/3-gfa.links.order.txt
	_polap_var_gfa_links_contig=${_polap_var_mtcontigs}/3-gfa.links.contig.txt
	_polap_var_gfa_links_contig_na=${_polap_var_mtcontigs}/3-gfa.links.contig.na.txt
	_polap_var_gfa_links_seed=${_polap_var_mtcontigs}/4-gfa.links.seed.txt
	_polap_var_gfa_links_mtcontig=${_polap_var_mtcontigs}/5-gfa.links.mtcontig.txt
	_polap_var_gfa_links_mtcontig_depth=${_polap_var_mtcontigs}/gfa.links.mtcontig.depth.txt

	help_message=$(
		cat <<HEREDOC
# Selects contigs using three features.
#
# To identify seed contigs of mitochondrial origin, 
# a whole-genome assembly is evaluated for three criteria: 
# 1) the presence of mitochondrial or plastid genes, 
# 2) the number of read coverage, and
# 3) the connectivity of contigs in the genome assembly graph. 
#
# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
# 3. For a given gfa of a genome assembly graph, subset the graph for selecting graph elements in the range.
# 4. Determine connected components in the subset.
# 5. Choose connected components with candidate edges.
#
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#
# Inputs:
#   ${_polap_var_assembly_graph_final_gfa}
#   ${_polap_var_annonation_table}
#
# Outputs:
#   $MTCONTIGNAME
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "${_polap_var_assembly_graph_final_gfa}" ]; then
		echoall "ERROR: no assembly graph file: ${assembly_graph_final_gfa}"
		exit $EXIT_ERROR
	fi

	rm -rf "${_polap_var_mtcontigs}"
	mkdir -p "${_polap_var_mtcontigs}"

	echoerr "FILE: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "FILE: ${_polap_var_annonation_table}"
	echoerr "FILE: $MTCONTIGNAME"
	# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
	# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
	"$WDIR"/run-polap-select-contigs-1-start.R \
		${_polap_var_assembly_graph_final_gfa} \
		${_polap_var_annonation_table} \
		${_polap_var_mtcontig_annotated} \
		${_polap_var_mtcontigs_stats}

	echoerr "FILE: ${_polap_var_mtcontig_annotated}"
	echoerr "FILE: ${_polap_var_mtcontigs_stats}"

	_polap_var_number_mtcontig=$(cat ${_polap_var_mtcontig_annotated} | wc -l)
	if [ "${_polap_var_number_mtcontig}" -eq 1 ]; then
		cut -f1 ${_polap_var_mtcontig_annotated} >${MTCONTIGNAME}
		echoerr "LOG: a single starting contig - done."
		echoerr "FILE: ${MTCONTIGNAME}"
		return
	fi

	# 3. For a given gfa of a genome assembly graph, subset the graph for selecting graph elements in the range.
	gfatools view -S ${_polap_var_assembly_graph_final_gfa} >${_polap_var_gfa_all}

	echoerr "FILE: ${_polap_var_gfa_all}"

	gfatools view -S ${_polap_var_assembly_graph_final_gfa} |
		grep "^S" >${_polap_var_gfa_seq_part}

	echoerr "FILE: ${_polap_var_gfa_seq_part}"

	# FIXME: the depth range needs to be adjusted case-by-case.
	#
	"$WDIR"/run-polap-select-contigs-2-gfa-filter.R \
		${_polap_var_gfa_seq_part} \
		${_polap_var_mtcontig_annotated} \
		${_polap_var_gfa_seq_filtered} \
		${_polap_var_gfa_seq_filtered_range}

	echoerr "FILE: ${_polap_var_gfa_seq_filtered}"

	# FIXME: link joint?
	# one edge linked to another that is not part of our candidate
	# then, the first edge will be removed. It may be suitable for gfatools
	# but it may not be for polap mtcontig selection.
	# So, we grab the second edge that is not part of the candidate.
	# -> not working, similar to the result of gfatools -r 1 option.
	# we may go back to the first strategy but add those missing (NA)
	# mt.contig back to the final list.

	# version: adding those linked to the first filtered edges -> not working
	#
	# gfatools view -S ${_polap_var_assembly_graph_final_gfa} |
	# 	grep "^L" | cut -f2,4 >${_polap_var_gfa_link_part}
	#
	# echoerr "FILE: ${_polap_var_gfa_link_part}"
	#
	# "$WDIR"/run-polap-select-contigs-x-gfa-counter.R \
	# 	${_polap_var_gfa_seq_filtered} \
	# 	${_polap_var_gfa_link_part} \
	# 	${_polap_var_gfa_seq_filtered_link_added}

	# return

	#
	# -r 1 \
	cut -f1 ${_polap_var_gfa_seq_filtered} >${_polap_var_gfa_seq_filtered_edge}
	gfatools view -S \
		-l @${_polap_var_gfa_seq_filtered_edge} \
		${_polap_var_assembly_graph_final_gfa} >${_polap_var_gfa_filtered}

	echoerr "FILE: ${_polap_var_gfa_filtered}"

	# 4. Determine connected components in the subset.
	cat ${_polap_var_gfa_filtered} | grep "^L" | cut -f2,4 >${_polap_var_gfa_links}

	echoerr "FILE: ${_polap_var_gfa_links}"

	"$WDIR"/run-polap-select-contigs-3-gfa-links.R \
		${_polap_var_mtcontig_annotated} \
		${_polap_var_gfa_links} \
		${_polap_var_gfa_links_number} \
		${_polap_var_gfa_links_order} \
		${_polap_var_gfa_links_contig} \
		${_polap_var_gfa_links_contig_na}

	echoerr "FILE: ${_polap_var_gfa_links_number}"
	echoerr "FILE: ${_polap_var_gfa_links_order}"
	echoerr "FILE: ${_polap_var_gfa_links_contig}"
	echoerr "FILE: ${_polap_var_gfa_links_contig_na}"

	python "$WDIR"/run-polap-select-contigs-4-find-connected-components.py \
		${_polap_var_gfa_links_number} \
		${_polap_var_gfa_links_contig} \
		${_polap_var_gfa_links_seed}

	echoerr "FILE: ${_polap_var_gfa_links_seed}"

	# 5. Choose connected components with candidate edges.
	"$WDIR"/run-polap-select-contigs-5-gfa-mtcontig.R \
		${_polap_var_gfa_links_seed} \
		${_polap_var_gfa_links_order} \
		${_polap_var_gfa_links_mtcontig}

	echoerr "FILE: ${_polap_var_gfa_links_mtcontig}"

	cat ${_polap_var_gfa_links_mtcontig} \
		${_polap_var_gfa_links_contig_na} \
		>${MTCONTIGNAME}

	# FIXME: gfatools view -S -r 1 -> leads too many linked edges.
	# we may evaluate seed candidate using depths and gene annotation one more.
	#
	# "$WDIR"/run-polap-select-contigs-6-end.R \
	# 	${_polap_var_gfa_seq_part} \
	# 	${_polap_var_mtcontigs_stats} \
	# 	${_polap_var_gfa_links_mtcontig} \
	# 	${_polap_var_gfa_links_mtcontig_depth}
	#
	# cp ${_polap_var_gfa_links_mtcontig_depth} ${MTCONTIGNAME}

	echoerr "FILE: ${MTCONTIGNAME}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects contigs for an organelle-genome assembly based on an organelle-genome.
#
# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
# 3. For a given gfa of a genome assembly graph, subset the graph for selecting graph elements in the range.
# 4. Determine connected components in the subset.
# 5. Choose connected components with candidate edges.
#
# We need to read GFA files to manipulate.
# We need to determine connected components.
################################################################################
function _run_polap_select-contigs-organelle() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	MTCONTIGNAME="$FDIR"/mt.contig.name-"$JNUM"
	_polap_var_mtcontigs="$FDIR"/"$JNUM"/mtcontigs

	# ADIR="$FDIR"/50-annotation
	# MTDIR="$ODIR"/$JNUM
	# MTSEEDSDIR="$MTDIR"/seeds

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	_polap_var_assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta
	_polap_var_assembly_graph_final_gfa="$FDIR"/30-contigger/graph_final.gfa
	_polap_var_annonation_table="$FDIR"/assembly_info_organelle_annotation_count-all.txt

	_polap_var_mtcontig_annotated=${_polap_var_mtcontigs}/1-mtcontig.annotated.txt
	_polap_var_mtcontigs_stats=${_polap_var_mtcontigs}/1-mtcontig.stats.txt
	_polap_var_gfa_all=${_polap_var_mtcontigs}/2-gfa.all.gfa
	_polap_var_gfa_seq_part=${_polap_var_mtcontigs}/2-gfa.seq.part.tsv
	_polap_var_gfa_seq_filtered=${_polap_var_mtcontigs}/2-gfa.seq.filtered.txt
	_polap_var_gfa_seq_filtered_range=${_polap_var_mtcontigs}/2-gfa.seq.filtered.range.txt
	_polap_var_gfa_seq_filtered_edge=${_polap_var_mtcontigs}/2-gfa.seq.filtered.edge.txt
	_polap_var_gfa_link_part=${_polap_var_mtcontigs}/gfa.link.part.tsv
	_polap_var_gfa_seq_filtered_link_added=${_polap_var_mtcontigs}/gfa.seq.filtered.link.added.txt
	_polap_var_gfa_filtered=${_polap_var_mtcontigs}/2-gfa.filtered.gfa
	_polap_var_gfa_links=${_polap_var_mtcontigs}/3-gfa.links.tsv
	_polap_var_gfa_links_number=${_polap_var_mtcontigs}/3-gfa.links.number.txt
	_polap_var_gfa_links_order=${_polap_var_mtcontigs}/3-gfa.links.order.txt
	_polap_var_gfa_links_contig=${_polap_var_mtcontigs}/3-gfa.links.contig.txt
	_polap_var_gfa_links_contig_na=${_polap_var_mtcontigs}/3-gfa.links.contig.na.txt
	_polap_var_gfa_links_seed=${_polap_var_mtcontigs}/4-gfa.links.seed.txt
	_polap_var_gfa_links_mtcontig=${_polap_var_mtcontigs}/5-gfa.links.mtcontig.txt
	_polap_var_gfa_links_mtcontig_depth=${_polap_var_mtcontigs}/gfa.links.mtcontig.depth.txt

	help_message=$(
		cat <<HEREDOC
# Selects contigs for an organelle-genome assembly based on an organelle-genome.
#
# 1. collect all edges with MT > PT.
#
# Arguments:
#   -i $INUM: source Flye (usually organelle-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#
# Inputs:
#   ${_polap_var_assembly_graph_final_gfa}
#   ${_polap_var_annonation_table}
#
# Outputs:
#   $MTCONTIGNAME
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "${_polap_var_assembly_graph_final_gfa}" ]; then
		echoall "ERROR: no assembly graph file: ${assembly_graph_final_gfa}"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${_polap_var_annonation_table}" ]; then
		echoall "ERROR: no annotation table: ${_polap_var_annonation_table}"
		exit $EXIT_ERROR
	fi

	# if [ "$INUM" -eq 0 ]; then
	# 	echoall "ERROR: -i must be positive because it should be based on an organelle-genome assembly."
	# 	exit $EXIT_ERROR
	# fi

	rm -rf "${_polap_var_mtcontigs}"
	mkdir -p "${_polap_var_mtcontigs}"

	echoerr "FILE: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "FILE: ${_polap_var_annonation_table}"
	echoerr "FILE: $MTCONTIGNAME"

	# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
	# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
	"$WDIR"/run-polap-select-contigs-organelle-1-start.R \
		${_polap_var_assembly_graph_final_gfa} \
		${_polap_var_annonation_table} \
		${_polap_var_mtcontig_annotated} \
		${_polap_var_mtcontigs_stats}

	echoerr "FILE: ${_polap_var_mtcontig_annotated}"

	cut -f1 ${_polap_var_mtcontig_annotated} >${MTCONTIGNAME}

	echoerr "FILE: ${MTCONTIGNAME}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_select-contigs-by-gene-density() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	MTCONTIGNAME="$FDIR"/mt.contig.name-"$JNUM"
	_polap_var_mtcontigs="$FDIR"/"$JNUM"/mtcontigs

	# ADIR="$FDIR"/50-annotation
	# MTDIR="$ODIR"/$JNUM
	# MTSEEDSDIR="$MTDIR"/seeds

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	_polap_var_assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta
	_polap_var_assembly_graph_final_gfa="$FDIR"/30-contigger/graph_final.gfa
	_polap_var_annonation_table="$FDIR"/assembly_info_organelle_annotation_count-all.txt

	_polap_var_mtcontig_annotated=${_polap_var_mtcontigs}/1-mtcontig.annotated.txt
	_polap_var_mtcontigs_stats=${_polap_var_mtcontigs}/1-mtcontig.stats.txt
	_polap_var_gfa_all=${_polap_var_mtcontigs}/2-gfa.all.gfa
	_polap_var_gfa_seq_part=${_polap_var_mtcontigs}/2-gfa.seq.part.tsv
	_polap_var_gfa_seq_filtered=${_polap_var_mtcontigs}/2-gfa.seq.filtered.txt
	_polap_var_gfa_seq_filtered_range=${_polap_var_mtcontigs}/2-gfa.seq.filtered.range.txt
	_polap_var_gfa_seq_filtered_edge=${_polap_var_mtcontigs}/2-gfa.seq.filtered.edge.txt
	_polap_var_gfa_link_part=${_polap_var_mtcontigs}/gfa.link.part.tsv
	_polap_var_gfa_seq_filtered_link_added=${_polap_var_mtcontigs}/gfa.seq.filtered.link.added.txt
	_polap_var_gfa_filtered=${_polap_var_mtcontigs}/2-gfa.filtered.gfa
	_polap_var_gfa_links=${_polap_var_mtcontigs}/3-gfa.links.tsv
	_polap_var_gfa_links_number=${_polap_var_mtcontigs}/3-gfa.links.number.txt
	_polap_var_gfa_links_order=${_polap_var_mtcontigs}/3-gfa.links.order.txt
	_polap_var_gfa_links_contig=${_polap_var_mtcontigs}/3-gfa.links.contig.txt
	_polap_var_gfa_links_contig_na=${_polap_var_mtcontigs}/3-gfa.links.contig.na.txt
	_polap_var_gfa_links_seed=${_polap_var_mtcontigs}/4-gfa.links.seed.txt
	_polap_var_gfa_links_mtcontig=${_polap_var_mtcontigs}/5-gfa.links.mtcontig.txt
	_polap_var_gfa_links_mtcontig_depth=${_polap_var_mtcontigs}/gfa.links.mtcontig.depth.txt

	help_message=$(
		cat <<HEREDOC
# Selects contigs for an organelle-genome assembly based on an organelle-genome.
#
# 1. collect all edges with MT > PT.
#
# Arguments:
#   -i $INUM: source Flye (usually organelle-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#
# Inputs:
#   ${_polap_var_assembly_graph_final_gfa}
#   ${_polap_var_annonation_table}
#
# Outputs:
#   $MTCONTIGNAME
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "${_polap_var_assembly_graph_final_gfa}" ]; then
		echoall "ERROR: no assembly graph file: ${assembly_graph_final_gfa}"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${_polap_var_annonation_table}" ]; then
		echoall "ERROR: no annotation table: ${_polap_var_annonation_table}"
		exit $EXIT_ERROR
	fi

	rm -rf "${_polap_var_mtcontigs}"
	mkdir -p "${_polap_var_mtcontigs}"

	echoerr "FILE: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "FILE: ${_polap_var_annonation_table}"
	echoerr "FILE: $MTCONTIGNAME"

	# 1. We could select mitochondrial- or plastid-derived contigs using a contig annotation table.
	# 2. We determine the range of sequencing depths for those candidate contigs: mean +/- sd \* 3.
	"$WDIR"/run-polap-select-contigs-by-gene-density-1-start.R \
		${_polap_var_assembly_graph_final_gfa} \
		${_polap_var_annonation_table} \
		${_polap_var_mtcontig_annotated} \
		${_polap_var_mtcontigs_stats}

	echoerr "FILE: ${_polap_var_mtcontig_annotated}"

	cut -f1 ${_polap_var_mtcontig_annotated} >${MTCONTIGNAME}

	echoerr "FILE: ${MTCONTIGNAME}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects mtDNA sequences from a GFA.
#
# annotation: uses 30-contigger/graph_final.gfa
#
# FIXME: need to check because assembly_graph.gfa and graph_final.gfa are different.
# extraction: uses assembly_graph.gfa
################################################################################
function _run_polap_select-mtdna() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	_polap_var_mtdna="$FDIR"/mtdna

	# _polap_var_assembly_graph_final_gfa="$FDIR"/30-contigger/graph_final.gfa
	_polap_var_assembly_graph_final_gfa="$FDIR"/assembly_graph.gfa
	_polap_var_annonation_table="$FDIR"/assembly_info_organelle_annotation_count-all.txt
	_polap_var_mt_fasta="$FDIR"/mt.0.fasta
	_polap_var_mt_edges="$FDIR"/mt.0.edges

	_polap_var_gfa_all=${_polap_var_mtdna}/1-gfa.all.gfa
	_polap_var_gfa_links=${_polap_var_mtdna}/1-gfa.links.tsv
	_polap_var_gfa_links_edges=${_polap_var_mtdna}/1-gfa.links.edges.txt
	_polap_var_gfa_links_circular_path=${_polap_var_mtdna}/2-gfa.links.circular.path.txt
	_polap_var_circular_path=${_polap_var_mtdna}/3-circular.path.txt
	_polap_var_edge_fasta=${_polap_var_mtdna}/5-edge.fasta

	_polap_var_gfa_links_order=${_polap_var_mtdna}/1-gfa.links.order.txt

	_polap_var_gfa_links_seed=${_polap_var_mtdna}/2-gfa.links.seed.txt

	_polap_var_annotated_edge=${_polap_var_mtdna}/3-annotated.edge.txt

	# _polap_var_mtcontig_annotated=${_polap_var_mtdna}/1-mtcontig.annotated.txt
	# _polap_var_mtdna_stats=${_polap_var_mtdna}/1-mtcontig.stats.txt
	#
	# _polap_var_gfa_seq_part=${_polap_var_mtdna}/2-gfa.seq.part.tsv
	# _polap_var_gfa_seq_filtered=${_polap_var_mtdna}/2-gfa.seq.filtered.txt
	# _polap_var_gfa_seq_filtered_range=${_polap_var_mtdna}/2-gfa.seq.filtered.range.txt
	# _polap_var_gfa_seq_filtered_edge=${_polap_var_mtdna}/2-gfa.seq.filtered.edge.txt
	# _polap_var_gfa_link_part=${_polap_var_mtdna}/gfa.link.part.tsv
	# _polap_var_gfa_seq_filtered_link_added=${_polap_var_mtdna}/gfa.seq.filtered.link.added.txt
	# _polap_var_gfa_filtered=${_polap_var_mtdna}/2-gfa.filtered.gfa

	# _polap_var_gfa_links_contig=${_polap_var_mtdna}/1-gfa.links.contig.txt
	# _polap_var_gfa_links_contig_na=${_polap_var_mtdna}/1-gfa.links.contig.na.txt

	# _polap_var_gfa_links_mtcontig=${_polap_var_mtdna}/5-gfa.links.mtcontig.txt
	# _polap_var_gfa_links_mtcontig_depth=${_polap_var_mtdna}/gfa.links.mtcontig.depth.txt

	help_message=$(
		cat <<HEREDOC
# Selects mtDNA sequences from a GFA.
#
# Arguments:
#   -i $INUM: organelle assembly number
#
# Inputs:
#   ${_polap_var_assembly_graph_final_gfa}
#   ${_polap_var_annonation_table}
#
# Outputs:
#   ${_polap_var_mt_fasta}
#
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "${_polap_var_assembly_graph_final_gfa}" ]; then
		echoall "ERROR: no assembly graph file: ${assembly_graph_final_gfa}"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${_polap_var_annonation_table}" ]; then
		echoall "ERROR: no annotation table: ${_polap_var_annonation_table}"
		exit $EXIT_ERROR
	fi

	rm -rf "${_polap_var_mtdna}"
	mkdir -p "${_polap_var_mtdna}"

	echoerr "Inputs: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "Inputs: ${_polap_var_annonation_table}"
	echoerr "Output: ${_polap_var_mt_fasta}"

	# 1. List connected components: steps 1 and 2
	gfatools view -S ${_polap_var_assembly_graph_final_gfa} >${_polap_var_gfa_all}

	echoerr "FILE: ${_polap_var_gfa_all}"

	cat ${_polap_var_gfa_all} | grep "^L" >${_polap_var_gfa_links}

	_polap_var_number_links_gfa=$(cat ${_polap_var_gfa_links} | wc -l)
	if [ "${_polap_var_number_links_gfa}" -eq 0 ]; then
		echoerr "LOG: no circular sequences are found."
		return
	fi

	echoerr "FILE: ${_polap_var_gfa_links}"

	"$WDIR"/run-polap-select-mtdna-1-nx-gfa-links.R \
		${_polap_var_gfa_links} \
		${_polap_var_gfa_links_edges}

	echoerr "FILE: ${_polap_var_gfa_links_edges}"

	python "$WDIR"/run-polap-select-mtdna-2-nx-find-circular-path.py \
		${_polap_var_gfa_links_edges} \
		${_polap_var_gfa_links_circular_path}

	echoerr "FILE: ${_polap_var_gfa_links_circular_path}"

	tail -n +2 "${_polap_var_gfa_links_circular_path}" |
		while IFS=$'\t' read -r col1 col2; do
			# Extract number and sign from the first column
			number1=$(echo "$col1" | grep -o '^[0-9]*')
			sign1=$(echo "$col1" | grep -o '[+-]$')

			# Append 'edge_' to the number and reattach the sign
			new_col1="edge_${number1}\t${sign1}"

			# Print the modified row
			echo -e "$new_col1"

		done >"${_polap_var_circular_path}"

	echoerr "FILE: ${_polap_var_circular_path}"

	_polap_var_fasta=${_polap_var_mtdna}/4-gfa.fasta

	gfatools gfa2fa ${_polap_var_assembly_graph_final_gfa} \
		>${_polap_var_fasta}

	echoerr "FILE: ${_polap_var_fasta}"

	# Create an empty file for the final concatenated sequence
	>${_polap_var_edge_fasta}

	# Loop through the list of IDs and their strand orientation
	while read id strand; do
		echoerr "$id"
		echoerr "$strand"
		if [[ "$strand" == "+" ]]; then
			# If strand is +, just append the sequence to the final file
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq >>${_polap_var_edge_fasta}
		elif [[ "$strand" == "-" ]]; then
			# If strand is -, reverse complement the sequence before appending
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq -r -p >>${_polap_var_edge_fasta}
		fi
	done <${_polap_var_circular_path}

	echo ">concatenated_sequence" >${_polap_var_mt_fasta}

	seqkit fx2tab ${_polap_var_edge_fasta} |
		cut -f2 |
		tr -d '\n' >>${_polap_var_mt_fasta}

	cp ${_polap_var_circular_path} ${_polap_var_mt_edges}

	echoerr "Inputs: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "FILE: ${_polap_var_mt_edges}"
	echoerr "FILE: ${_polap_var_mt_fasta}"

	return

	##########################################################

	# 2. Choose the edge with the most MT genes.
	"$WDIR"/run-polap-select-mtdna-3-annotated-edge.R \
		${_polap_var_annonation_table} \
		${_polap_var_gfa_links_order} \
		${_polap_var_gfa_links_seed} \
		${_polap_var_annotated_edge}

	echoerr "FILE: ${_polap_var_annotated_edge}"

	# 3. Find the shortest path for the connected component
	#    that has the edge.
	_polap_var_component_edge=${_polap_var_mtdna}/3-component.edge.txt

	cp ${_polap_var_annotated_edge} ${_polap_var_component_edge}

	_polap_var_gfa_component=${_polap_var_mtdna}/3-gfa.component.txt
	_polap_var_gfa_component_graph=${_polap_var_mtdna}/3-gfa.component.graph.csv
	_polap_var_gfa_cycle_component=${_polap_var_mtdna}/3-gfa.cycle.component.txt
	_polap_var_gfa_cycle_edge=${_polap_var_mtdna}/3-gfa.cycle.edge.txt
	_polap_var_gfa_cycle_edge_fasta=${_polap_var_mtdna}/3-gfa.cycle.edge.fasta
	_polap_var_gfa_cycle_fasta=${_polap_var_mtdna}/3-gfa.cycle.fasta
	_polap_var_fasta=${_polap_var_mtdna}/5-gfa.fasta

	gfatools gfa2fa ${_polap_var_assembly_graph_final_gfa} \
		>${_polap_var_fasta}

	echoerr "FILE: ${_polap_var_fasta}"

	gfatools view -S \
		-l @${_polap_var_component_edge} \
		${_polap_var_gfa_all} |
		grep "^L" \
			>${_polap_var_gfa_component}

	echoerr "FILE: ${_polap_var_gfa_component}"

	_polap_var_number_edge_component=$(cat ${_polap_var_gfa_component} | wc -l)
	if [ "${_polap_var_number_edge_component}" -eq 1 ]; then
		echo ">concatenated_sequence" >${_polap_var_gfa_cycle_fasta}
		seqkit grep -f ${_polap_var_component_edge} ${_polap_var_fasta} |
			seqkit seq -s >>${_polap_var_gfa_cycle_fasta}
		echoerr "LOG: a single starting contig - done."
		echoerr "FILE: ${_polap_var_gfa_cycle_fasta}"
		return
	fi

	# step 4
	"$WDIR"/run-polap-select-mtdna-3-graph-component.R \
		${_polap_var_gfa_component} \
		${_polap_var_gfa_component_graph}

	echoerr "FILE: ${_polap_var_gfa_component_graph}"

	# return

	# FIXME: Macadamia case does not work.
	# (polap) goshng@thorne:~/all/polap/figshare/Macadamia_tetraphylla/o/2/mtdna$ cat 3-gfa.component.graph.csv
	# node1,node2,distance
	# 1+,3-,1
	# 1-,2-,1
	# 2+,3+,1
	# 2-,3-,1
	# 1+,1-,1
	# 3+,3-,1
	# 2+,2-,1
	# (polap) goshng@thorne:~/all/polap/figshare/Macadamia_tetraphylla/o/2/mtdna$ cat 3-gfa.cycle.component.txt
	# 1+,1-
	# 1-,2- <---
	# 2-,2+
	# 2+,3+ <---
	# 3+,3-
	# 3-,2- <---
	# 2-,3- <---
	# 3-,1+ <---
	# FIXME: not working, 2 is repeated. Edge with different vertices should not exist.
	# sometimes it works and not working some other. So, this is not working code.
	# (polap) goshng@thorne:~/all/polap/figshare/Taraxacum_mongolicum/o/1/mtdna$ cat 3-gfa.cycle.component.txt
	# 1+,1-
	# 1-,2+ <---
	# 2+,2-
	# 2-,2+
	# 2+,3+ <---
	# 3+,3-
	# 3-,2+ <---
	# 2+,1+ <---
	# (polap) goshng@thorne:~/all/polap/figshare/Taraxacum_mongolicum/o/1/mtdna$ cat 3-gfa.cycle.edge.txt
	# edge_1  +
	# edge_2  +
	# edge_2  -
	# edge_3  +

	source $HOME/miniconda3/bin/activate p36

	python "$WDIR"/run-polap-select-mtdna-4-find-cycle-component.py \
		${_polap_var_gfa_component_graph} \
		${_polap_var_gfa_cycle_component}

	echoerr "FILE: ${_polap_var_gfa_cycle_component}"

	conda deactivate

	# return

	# step 4
	# FIXME: Macadamia case does not work: check o/2/mtdna.
	"$WDIR"/run-polap-select-mtdna-5-cycle-edge.R \
		${_polap_var_gfa_cycle_component} \
		${_polap_var_gfa_cycle_edge}

	echoerr "FILE: ${_polap_var_gfa_cycle_edge}"

	# return

	# Create an empty file for the final concatenated sequence
	>${_polap_var_gfa_cycle_edge_fasta}

	# Loop through the list of IDs and their strand orientation
	while read id strand; do
		if [[ "$strand" == "+" ]]; then
			# If strand is +, just append the sequence to the final file
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq >>${_polap_var_gfa_cycle_edge_fasta}
		elif [[ "$strand" == "-" ]]; then
			# If strand is -, reverse complement the sequence before appending
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq -r -p >>${_polap_var_gfa_cycle_edge_fasta}
		fi
	done <${_polap_var_gfa_cycle_edge}

	echoerr "FILE: ${_polap_var_gfa_cycle_edge_fasta}"

	seqkit fx2tab ${_polap_var_gfa_cycle_edge_fasta} |
		cut -f2 |
		tr -d '\n' >concatenated_sequence.txt

	echo ">concatenated_sequence" >${_polap_var_gfa_cycle_fasta}
	cat concatenated_sequence.txt >>${_polap_var_gfa_cycle_fasta}

	# seqkit concat ${_polap_var_gfa_cycle_edge_fasta} >${_polap_var_gfa_cycle_fasta}

	echoerr "FILE: ${_polap_var_gfa_cycle_fasta}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_select-mtdna-old-two-vertices() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	_polap_var_mtdna="$FDIR"/mtdna

	_polap_var_assembly_graph_final_gfa="$FDIR"/30-contigger/graph_final.gfa
	_polap_var_annonation_table="$FDIR"/assembly_info_organelle_annotation_count-all.txt
	_polap_var_mt_fasta="$FDIR"/mt.0.fasta

	_polap_var_gfa_all=${_polap_var_mtdna}/1-gfa.all.gfa
	_polap_var_gfa_links=${_polap_var_mtdna}/1-gfa.links.tsv
	_polap_var_gfa_links_number=${_polap_var_mtdna}/1-gfa.links.number.txt
	_polap_var_gfa_links_order=${_polap_var_mtdna}/1-gfa.links.order.txt

	_polap_var_gfa_links_seed=${_polap_var_mtdna}/2-gfa.links.seed.txt

	_polap_var_annotated_edge=${_polap_var_mtdna}/3-annotated.edge.txt

	# _polap_var_mtcontig_annotated=${_polap_var_mtdna}/1-mtcontig.annotated.txt
	# _polap_var_mtdna_stats=${_polap_var_mtdna}/1-mtcontig.stats.txt
	#
	# _polap_var_gfa_seq_part=${_polap_var_mtdna}/2-gfa.seq.part.tsv
	# _polap_var_gfa_seq_filtered=${_polap_var_mtdna}/2-gfa.seq.filtered.txt
	# _polap_var_gfa_seq_filtered_range=${_polap_var_mtdna}/2-gfa.seq.filtered.range.txt
	# _polap_var_gfa_seq_filtered_edge=${_polap_var_mtdna}/2-gfa.seq.filtered.edge.txt
	# _polap_var_gfa_link_part=${_polap_var_mtdna}/gfa.link.part.tsv
	# _polap_var_gfa_seq_filtered_link_added=${_polap_var_mtdna}/gfa.seq.filtered.link.added.txt
	# _polap_var_gfa_filtered=${_polap_var_mtdna}/2-gfa.filtered.gfa

	# _polap_var_gfa_links_contig=${_polap_var_mtdna}/1-gfa.links.contig.txt
	# _polap_var_gfa_links_contig_na=${_polap_var_mtdna}/1-gfa.links.contig.na.txt

	# _polap_var_gfa_links_mtcontig=${_polap_var_mtdna}/5-gfa.links.mtcontig.txt
	# _polap_var_gfa_links_mtcontig_depth=${_polap_var_mtdna}/gfa.links.mtcontig.depth.txt

	help_message=$(
		cat <<HEREDOC
# Selects mtDNA sequences from a GFA.
#
# To identify mitochondrial DNAs:
#
# 1. List connected components: steps 1 and 2
# 2. Choose the edge with the most MT genes.
# 3. Find the shortest path for the connected component
#    that has the edge.
#
# Arguments:
#   -i $INUM: organelle assembly number
#
# Inputs:
#   ${_polap_var_assembly_graph_final_gfa}
#   ${_polap_var_annonation_table}
#
# Outputs:
#   ${_polap_var_mt_fasta}
#
	# FIXME: we could have a little different graph for extracting mtDNA.
	# First, edges have two sides or plus and minus. An implicit edge for an edge
	# sequence is + to -: 3+,3- for edge 3. Then we need to use the strandness
	# for a link row in a GFA file.
	# For example,
	# L       edge_1  +       edge_2  -       0M      L1:i:1799       L2:i:48402      RC:i:142
	# L       edge_1  +       edge_2  +       0M      L1:i:1799       L2:i:48402      RC:i:135
	# L       edge_1  -       edge_3  +       0M      L1:i:1799       L2:i:174640     RC:i:127
	# L       edge_1  -       edge_3  -       0M      L1:i:1799       L2:i:174640     RC:i:151
	#
	# Implicit edge links are:
	# edge_1 + -> edge_1 -
	# edge_2 + -> edge_2 -
	# edge_3 + -> edge_3 -
	#
	# 2024-09-08
	# FIXME: For this example, I want to find an implementation for extracting a shortest cycle
	# in an undirected graph. That was where I stopped.
	#
	# search
	# Finding the shortest cycle in an undirected graph using every edge
	# - [Chinese Postman in Python. Detailed Implementation & Explanation | by Araz Sharma | Towards Data Science](https://towardsdatascience.com/chinese-postman-in-python-8b1187a3e5a)
	# - [Intro to graph optimization: solving the Chinese Postman Problem  andrew brooks](https://brooksandrew.github.io/simpleblog/articles/intro-to-graph-optimization-solving-cpp/#overview-of-cpp-algorithm)
	#
	# Use this tool chinese_postman:
	# - [postman_problems  PyPI](https://pypi.org/project/postman_problems/)
	# I might use this code or executable.
	#
	# input: 1.csv
	# node1,node2,distance
	# 0,1,1
	# 0,2,1
	# 1,2,1
	# 3,0,1
	# 3,4,1
	# 3,5,1
	# 4,5,1
	#
	# chinese_postman --edgelist 1.csv
	# chinese_postman --edgelist 1.csv 2>&1 | cut -d: -f3-
	#
	# output:
	# Solving the chinese postman problem..
	# Solution:
	# ('0', '3', 0, {'distance': 1, 'id': 3, 'augmented': True})
	# ('3', '5', 0, {'distance': 1, 'id': 5})
	# ('5', '4', 0, {'distance': 1, 'id': 6})
	# ('4', '3', 0, {'distance': 1, 'id': 4})
	# ('3', '0', 0, {'distance': 1, 'id': 3})
	# ('0', '2', 0, {'distance': 1, 'id': 1})
	# ('2', '1', 0, {'distance': 1, 'id': 2})
	# ('1', '0', 0, {'distance': 1, 'id': 0})
	# Solution summary stats:
	# distance_walked : 8
	# distance_doublebacked : 1
	# distance_walked_once : 7
	# distance_walked_optional : 0
	# distance_walked_required : 8
	# edges_walked : 8
	# edges_doublebacked : 1
	# edges_walked_once : 7
	# edges_walked_optional : 0
	# edges_walked_required : 8
	#
	# Assume that we have a text file:
	# edge_1
	# edge_2
	# edge_3
	#
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "${_polap_var_assembly_graph_final_gfa}" ]; then
		echoall "ERROR: no assembly graph file: ${assembly_graph_final_gfa}"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${_polap_var_annonation_table}" ]; then
		echoall "ERROR: no annotation table: ${_polap_var_annonation_table}"
		exit $EXIT_ERROR
	fi

	rm -rf "${_polap_var_mtdna}"
	mkdir -p "${_polap_var_mtdna}"

	echoerr "Inputs: ${_polap_var_assembly_graph_final_gfa}"
	echoerr "Inputs: ${_polap_var_annonation_table}"
	echoerr "Output: ${_polap_var_mt_fasta}"

	# 1. List connected components: steps 1 and 2
	gfatools view -S ${_polap_var_assembly_graph_final_gfa} >${_polap_var_gfa_all}

	echoerr "FILE: ${_polap_var_gfa_all}"

	cat ${_polap_var_gfa_all} | grep "^L" >${_polap_var_gfa_links}

	_polap_var_number_links_gfa=$(cat ${_polap_var_gfa_links} | wc -l)
	if [ "${_polap_var_number_links_gfa}" -eq 0 ]; then
		echoerr "LOG: no circular sequences are found."
		return
	fi

	echoerr "FILE: ${_polap_var_gfa_links}"

	"$WDIR"/run-polap-select-mtdna-1-gfa-links.R \
		${_polap_var_gfa_links} \
		${_polap_var_gfa_links_number} \
		${_polap_var_gfa_links_order}

	echoerr "FILE: ${_polap_var_gfa_links_number}"
	echoerr "FILE: ${_polap_var_gfa_links_order}"

	python "$WDIR"/run-polap-select-mtdna-2-find-connected-components.py \
		${_polap_var_gfa_links_number} \
		dummy \
		>${_polap_var_gfa_links_seed}

	echoerr "FILE: ${_polap_var_gfa_links_seed}"

	# 2. Choose the edge with the most MT genes.
	"$WDIR"/run-polap-select-mtdna-3-annotated-edge.R \
		${_polap_var_annonation_table} \
		${_polap_var_gfa_links_order} \
		${_polap_var_gfa_links_seed} \
		${_polap_var_annotated_edge}

	echoerr "FILE: ${_polap_var_annotated_edge}"

	# 3. Find the shortest path for the connected component
	#    that has the edge.
	_polap_var_component_edge=${_polap_var_mtdna}/3-component.edge.txt

	cp ${_polap_var_annotated_edge} ${_polap_var_component_edge}

	_polap_var_gfa_component=${_polap_var_mtdna}/3-gfa.component.txt
	_polap_var_gfa_component_graph=${_polap_var_mtdna}/3-gfa.component.graph.csv
	_polap_var_gfa_cycle_component=${_polap_var_mtdna}/3-gfa.cycle.component.txt
	_polap_var_gfa_cycle_edge=${_polap_var_mtdna}/3-gfa.cycle.edge.txt
	_polap_var_gfa_cycle_edge_fasta=${_polap_var_mtdna}/3-gfa.cycle.edge.fasta
	_polap_var_gfa_cycle_fasta=${_polap_var_mtdna}/3-gfa.cycle.fasta
	_polap_var_fasta=${_polap_var_mtdna}/5-gfa.fasta

	gfatools gfa2fa ${_polap_var_assembly_graph_final_gfa} \
		>${_polap_var_fasta}

	echoerr "FILE: ${_polap_var_fasta}"

	gfatools view -S \
		-l @${_polap_var_component_edge} \
		${_polap_var_gfa_all} |
		grep "^L" \
			>${_polap_var_gfa_component}

	echoerr "FILE: ${_polap_var_gfa_component}"

	_polap_var_number_edge_component=$(cat ${_polap_var_gfa_component} | wc -l)
	if [ "${_polap_var_number_edge_component}" -eq 1 ]; then
		echo ">concatenated_sequence" >${_polap_var_gfa_cycle_fasta}
		seqkit grep -f ${_polap_var_component_edge} ${_polap_var_fasta} |
			seqkit seq -s >>${_polap_var_gfa_cycle_fasta}
		echoerr "LOG: a single starting contig - done."
		echoerr "FILE: ${_polap_var_gfa_cycle_fasta}"
		return
	fi

	# step 4
	"$WDIR"/run-polap-select-mtdna-3-graph-component.R \
		${_polap_var_gfa_component} \
		${_polap_var_gfa_component_graph}

	echoerr "FILE: ${_polap_var_gfa_component_graph}"

	# return

	# FIXME: Macadamia case does not work.
	# (polap) goshng@thorne:~/all/polap/figshare/Macadamia_tetraphylla/o/2/mtdna$ cat 3-gfa.component.graph.csv
	# node1,node2,distance
	# 1+,3-,1
	# 1-,2-,1
	# 2+,3+,1
	# 2-,3-,1
	# 1+,1-,1
	# 3+,3-,1
	# 2+,2-,1
	# (polap) goshng@thorne:~/all/polap/figshare/Macadamia_tetraphylla/o/2/mtdna$ cat 3-gfa.cycle.component.txt
	# 1+,1-
	# 1-,2- <---
	# 2-,2+
	# 2+,3+ <---
	# 3+,3-
	# 3-,2- <---
	# 2-,3- <---
	# 3-,1+ <---
	# FIXME: not working, 2 is repeated. Edge with different vertices should not exist.
	# sometimes it works and not working some other. So, this is not working code.
	# (polap) goshng@thorne:~/all/polap/figshare/Taraxacum_mongolicum/o/1/mtdna$ cat 3-gfa.cycle.component.txt
	# 1+,1-
	# 1-,2+ <---
	# 2+,2-
	# 2-,2+
	# 2+,3+ <---
	# 3+,3-
	# 3-,2+ <---
	# 2+,1+ <---
	# (polap) goshng@thorne:~/all/polap/figshare/Taraxacum_mongolicum/o/1/mtdna$ cat 3-gfa.cycle.edge.txt
	# edge_1  +
	# edge_2  +
	# edge_2  -
	# edge_3  +

	source $HOME/miniconda3/bin/activate p36

	python "$WDIR"/run-polap-select-mtdna-4-find-cycle-component.py \
		${_polap_var_gfa_component_graph} \
		${_polap_var_gfa_cycle_component}

	echoerr "FILE: ${_polap_var_gfa_cycle_component}"

	conda deactivate

	# return

	# step 4
	# FIXME: Macadamia case does not work: check o/2/mtdna.
	"$WDIR"/run-polap-select-mtdna-5-cycle-edge.R \
		${_polap_var_gfa_cycle_component} \
		${_polap_var_gfa_cycle_edge}

	echoerr "FILE: ${_polap_var_gfa_cycle_edge}"

	# return

	# Create an empty file for the final concatenated sequence
	>${_polap_var_gfa_cycle_edge_fasta}

	# Loop through the list of IDs and their strand orientation
	while read id strand; do
		if [[ "$strand" == "+" ]]; then
			# If strand is +, just append the sequence to the final file
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq >>${_polap_var_gfa_cycle_edge_fasta}
		elif [[ "$strand" == "-" ]]; then
			# If strand is -, reverse complement the sequence before appending
			seqkit grep -p "$id" ${_polap_var_fasta} | seqkit seq -r -p >>${_polap_var_gfa_cycle_edge_fasta}
		fi
	done <${_polap_var_gfa_cycle_edge}

	echoerr "FILE: ${_polap_var_gfa_cycle_edge_fasta}"

	seqkit fx2tab ${_polap_var_gfa_cycle_edge_fasta} |
		cut -f2 |
		tr -d '\n' >concatenated_sequence.txt

	echo ">concatenated_sequence" >${_polap_var_gfa_cycle_fasta}
	cat concatenated_sequence.txt >>${_polap_var_gfa_cycle_fasta}

	# seqkit concat ${_polap_var_gfa_cycle_edge_fasta} >${_polap_var_gfa_cycle_fasta}

	echoerr "FILE: ${_polap_var_gfa_cycle_fasta}"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function ncbi_command_parse() {
	BIOPRJ=""
	SPECIES=""
	SRA=""
	while getopts "b:s:r:o:" option; do
		case $option in
		b) BIOPRJ=$OPTARG ;;
		s) SPECIES=$OPTARG ;;
		r) SRA=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		# h) usage_of ;;
		\?) # incorrect option
			echo "Error: Invalid option; try -h option"
			exit
			;;
		esac
	done
}

function _run_polap_x-bioproject() {
	ncbi_command_parse "$@"
	esearch -db bioproject -query "$BIOPRJ" | elink -target sra | efetch -format runinfo >"$BIOPRJ".txt
	echo "cat $BIOPRJ.txt | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty | less -S" 1>&2
}

function _run_polap_x-sra() {
	ncbi_command_parse "$@"
	# esearch -db sra -query $SRA | efetch -format runinfo | csvtk cut -f BioProject | csvtk del-header
	esearch -db sra -query "$SRA" | efetch -format runinfo >"$SRA".txt
	echo "use: cat $SRA.txt | csvtk cut -f BioProject | csvtk del-header" 1>&2
}

function _run_polap_x-bioproject2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	mkdir $ODIR
	BIOPRJ=$_arg_bioproject

	MDATA="$ODIR/accessions_demo.txt"
	esearch -db bioproject -query $BIOPRJ | elink -target biosample | efetch -format docsum | xtract.Linux -pattern DocumentSummary -block Ids -element Id -group SRA >${MDATA}
	SRSs=$(cat ${MDATA} | while read LINE; do
		NCOL=$(echo ${LINE} | wc -w)
		ACC=$(echo ${LINE} | cut -d ' ' -f ${NCOL})
		echo ${ACC}
	done | xargs)

	# SRS_str=$(join_by ' OR ' ${SRSs[@]})
	# echoall $SRS_str
	# esearch -db SRA -query "\"" $SRS_str "\"" | efetch -format runinfo | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	for SRS in ${SRSs[@]}; do
		esearch -db SRA -query ${SRS} | efetch -format runinfo
		# esearch -db SRA -query ${SRS} | efetch -format runinfo | tail -n +2
	done >$ODIR/accessions_demo.tab
	# csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_x-sra2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	SRA=$_arg_sra
	$script_dir/ncbitools fetch sra "$SRA"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# TODO: get known mtDNA
# compare known and the assembled using BLAST.
# not use clustalw because it is too slow. We just use the length.
#
################################################################################
function _run_polap_assemble-bioproject() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MTDIR=$ODIR/$JNUM

	help_message=$(
		cat <<HEREDOC
# NOT IMPLEMENTED YET!
# because we need a manual long-read selection step.
# You could execute this menu with option --test.
#
# Runs the organelle-genome assembly.
# Arguments:
#   -o $ODIR
#   -b $SR2: bioproject ID
# Inputs:
#   $SR2: bioproject ID
# Outputs:
#   mt.1.fa
Example: $(basename $0) ${_arg_menu[0]} -b PRJNA574453
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	_polap_var_bioproject=bioproject
	_polap_var_bioproject_runinfo=${_polap_var_bioproject}/1-runinfo.tsv
	_polap_var_bioproject_sra_long_read=${_polap_var_bioproject}/1-sra-long-read.tsv
	_polap_var_bioproject_sra_short_read=${_polap_var_bioproject}/1-sra-short-read.tsv

	rm -rf ${_polap_var_bioproject}
	mkdir -p ${_polap_var_bioproject}

	BIOPRJ=$SR2
	esearch -db bioproject -query "$BIOPRJ" |
		elink -target sra |
		efetch -format runinfo |
		csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName |
		csvtk csv2tab >${_polap_var_bioproject_runinfo}

	echoerr "FILE: ${_polap_var_bioproject_runinfo}"

	"$WDIR"/run-polap-assemble-bioproject-1-select-sra.R \
		${_polap_var_bioproject_runinfo} \
		${_polap_var_bioproject_sra_long_read} \
		${_polap_var_bioproject_sra_short_read}

	echoerr "FILE: ${_polap_var_bioproject_runinfo}"
	echoerr "FILE: ${_polap_var_bioproject_sra_long_read}"
	echoerr "FILE: ${_polap_var_bioproject_sra_short_read}"

	if [ -s ${_polap_var_bioproject_sra_long_read} ]; then
		SRA=$(cut -f1 ${_polap_var_bioproject_sra_long_read})
		"$script_dir"/run-polap-ncbitools fetch sra "$SRA"
		LR=$SRA.fastq
	else
		die "ERROR: no long-read dataset for the BioProject: $BIOPRJ"
	fi

	if [ -s ${_polap_var_bioproject_sra_short_read} ]; then
		SRA=$(cut -f1 ${_polap_var_bioproject_sra_short_read})
		SR1=${SRA}_1.fastq
		SR2=${SRA}_2.fastq
		"$script_dir"/run-polap-ncbitools fetch sra "$SRA"
	else
		die "ERROR: no short-read dataset for the BioProject: $BIOPRJ"
	fi

	_run_polap_assemble1
	_run_polap_annotate
	_run_polap_select-contigs
	# check the mt.contig.name-1
	if [ ! -s "$MTCONTIGNAME" ]; then
		die "LOG: $MTCONTIGNAME is empty. You have to choose seed contigs by yourself."
	fi
	_run_polap_assemble2
	INUM=1 _run_polap_annotate
	_run_polap_flye-polishing
	INUM=1 _run_polap_select-mtdna
	_run_polap_prepare-polishing
	PA=$ODIR/1/mt.0.fasta
	FA=$ODIR/1/mt.1.fa
	_run_polap_polish

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_x-ncbi-mtdna() {
	ncbi_command_parse "$@"
	_polap_var_bioproject=bioproject
	_polap_var_bioproject_runinfo=${_polap_var_bioproject}/1-runinfo.tsv
	_polap_var_bioproject_sra_long_read=${_polap_var_bioproject}/1-sra-long-read.tsv
	_polap_var_bioproject_mtdna_all_fasta=${_polap_var_bioproject}/1-mtdna-all.fasta
	_polap_var_bioproject_mtdna_stats=${_polap_var_bioproject}/1-mtdna.stats
	_polap_var_bioproject_mtdna=${_polap_var_bioproject}/2-mtdna.fasta
	_polap_var_bioproject_blastn1=${_polap_var_bioproject}/3-blastn1.txt
	_polap_var_bioproject_blastn2=${_polap_var_bioproject}/3-blastn2.txt
	_polap_var_bioproject_blastn3=${_polap_var_bioproject}/3-blastn3.txt
	_polap_var_bioproject_blastn3_length=${_polap_var_bioproject}/3-blastn3.length.txt

	_polap_var_mtdna1=$ODIR/1/mt.1.fa
	_polap_var_mtdna2=$ODIR/1/mt.2.fa
	_polap_var_mtdna3=$ODIR/1/mt.3.fa

	SPECIES=$(cut -f4 ${_polap_var_bioproject_sra_long_read})
	echoerr "LOG: bioproject's species: $SPECIES"

	# esearch -db nuccore \
	# 	-query "(mitochondrion[Title] AND complete[Title] AND genome[Title]) AND ${SPECIES}[Organism]" |
	# 	efetch -format fasta >${_polap_var_bioproject_mtdna_all_fasta}
	# seqkit stats ${_polap_var_bioproject_mtdna_all_fasta} --all >${_polap_var_bioproject_mtdna_stats}
	#
	# echoerr "FILE: ${_polap_var_bioproject_mtdna_stats}"
	#
	# seqkit head -n 1 ${_polap_var_bioproject_mtdna_all_fasta} -o ${_polap_var_bioproject_mtdna}
	#
	# echoerr "FILE: ${_polap_var_bioproject_mtdna}"

	blastn -query ${_polap_var_mtdna1} -subject ${_polap_var_bioproject_mtdna} \
		-outfmt "6 qseqid qstart sseqid sstart sstrand" \
		>${_polap_var_bioproject_blastn1}

	blastn -query ${_polap_var_mtdna1} -subject ${_polap_var_bioproject_mtdna} \
		>${_polap_var_bioproject_blastn1}.full

	echoerr "FILE: ${_polap_var_bioproject_blastn1}"

	_polap_var_bioproject_strand=$(cut -f5 ${_polap_var_bioproject_blastn1} | head -n 1)

	if [ ${_polap_var_bioproject_strand} = "plus" ]; then
		cp ${_polap_var_mtdna1} ${_polap_var_mtdna2}
	else
		# reversed
		seqkit seq -p -r ${_polap_var_mtdna1} -o ${_polap_var_mtdna2}
	fi

	blastn -query ${_polap_var_mtdna2} -subject ${_polap_var_bioproject_mtdna} \
		-outfmt "6 qseqid qstart sseqid sstart sstrand" \
		>${_polap_var_bioproject_blastn2}

	echoerr "FILE: ${_polap_var_bioproject_blastn2}"

	# restart the position at 1.
	_polap_var_bioproject_restart_position=$(sort -n -k4 ${_polap_var_bioproject_blastn2} | head -n 1 | cut -f2)
	echoerr "LOG: restart position: ${_polap_var_bioproject_restart_position}"
	seqkit restart -i ${_polap_var_bioproject_restart_position} \
		${_polap_var_mtdna2} -o ${_polap_var_mtdna3}

	blastn -query ${_polap_var_mtdna3} -subject ${_polap_var_bioproject_mtdna} \
		-outfmt "6 qseqid qstart sseqid sstart sstrand length pident" \
		>${_polap_var_bioproject_blastn3}

	echoerr "FILE: ${_polap_var_bioproject_blastn3}"

	"$WDIR"/run-polap-assemble-bioproject-3-length-match.R \
		${_polap_var_bioproject_blastn3} \
		${_polap_var_bioproject_blastn3_length}

	echoerr "FILE: ${_polap_var_bioproject_blastn3_length}"
}

function _run_polap_x-ncbi-ptdna() {
	ncbi_command_parse "$@"
	esearch -db nuccore \
		-query "(chloroplast[Title] AND complete[Title] AND genome[Title]) AND ${SPECIES}[Organism]" |
		efetch -format fasta >pt.fasta
}

function _run_polap_x-help() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	print_x-help 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Blast the final mtDNA sequence.
################################################################################
function _run_polap_blast-mtdna() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	ANUM=$INUM
	MTAA="$WDIR"/polap-mt.1.c70.3.faa
	PTAA="$WDIR"/polap-pt.2.c70.3.faa

	# FDIR="$ODIR"/$ANUM
	# assembly_contigs_stats="$FDIR"/30-contigger/contigs_stats.txt
	# assembly_contigs_fasta="$FDIR"/30-contigger/contigs.fasta
	# ADIR="$FDIR"/50-annotation
	# CONTIGFILE="$ADIR"/contig.fasta
	# CONTIGDB="$ADIR"/contig
	# MTAABLAST="$ADIR"/mtaa.blast
	# MTAABED="$ADIR"/mtaa.bed
	# MTGENECOUNT="$ADIR"/mt.gene.count
	# PTAABLAST="$ADIR"/ptaa.blast
	# PTAABED="$ADIR"/ptaa.bed
	# PTGENECOUNT="$ADIR"/pt.gene.count
	# CONTIGNAME="$ADIR"/contig.name

	help_message=$(
		cat <<HEREDOC
# Blast the final mtDNA sequence.
# Arguments:
#   -f $FA
# Inputs:
#   $ODIR/$INUM/$FA
# Outputs:
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>] -f mt.1.fa -o [$ODIR]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	_polap_var_chloroplot=$ODIR/$INUM/60-chloroplot
	echoall "please, wait for annotation with mitochondrial and plastid genes on $FA"

	if [ ! -s "$FA" ]; then
		echoall "ERROR: no FASTA file [$FA]"
		exit $EXIT_ERROR
	fi

	if [ -d "${_polap_var_chloroplot}" ]; then
		rm -rf "${_polap_var_chloroplot}"
		echo "INFO: ${_polap_var_chloroplot} is deleted."
	fi
	mkdir -p "${_polap_var_chloroplot}"
	echo "INFO: ${_polap_var_chloroplot} is created."

	makeblastdb -dbtype nucl \
		-in "${FA}" \
		-out "${_polap_var_chloroplot}"/dna \
		>/dev/null 2>&1
	echo "INFO: BLASTDB of the contig sequences: ${_polap_var_chloroplot}/dna"

	# mtDNA gene annotation and counts
	echo "INFO: BLAST of the mitochondrial proteins againt ${_polap_var_chloroplot}/dna"
	echo "INFO: executing the tblastn ... be patient!"
	# tblastn -query "$MTAA" \
	# 	-db "${_polap_var_chloroplot}"/dna \
	# 	-out "${_polap_var_chloroplot}"/mtaa.blast.full \
	# 	-evalue 1e-30 \
	# 	-num_threads "$NT" \
	# 	>/dev/null 2>&1

	tblastn -query "$MTAA" \
		-db "${_polap_var_chloroplot}"/dna \
		-out "${_polap_var_chloroplot}"/mtaa.blast \
		-evalue 1e-30 \
		-outfmt '6 qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle salltitles' \
		-num_threads "$NT" \
		>/dev/null 2>&1

	"$WDIR"/run-polap-genes.R "${_polap_var_chloroplot}"/mtaa.blast \
		"${_polap_var_chloroplot}"/mtaa.blast.bed \
		>/dev/null 2>&1
	sort -k1,1 -k2,2n "${_polap_var_chloroplot}"/mtaa.blast.bed >"${_polap_var_chloroplot}/mtaa.blast.sorted.bed"

	mkdir "${_polap_var_chloroplot}"/mtaa.bed

	"$WDIR"/run-polap-genes-bed4.R "${_polap_var_chloroplot}"/mtaa.blast \
		"${_polap_var_chloroplot}"/mtaa.blast.bed4
	# >/dev/null 2>&1

	echo "INFO: counting mitochondrial genes in the contigs"
	bedtools merge -i "${_polap_var_chloroplot}/mtaa.blast.sorted.bed" >${_polap_var_chloroplot}/mtaa.blast.sorted.bed.txt

	echoerr "FILE: ${_polap_var_chloroplot}/mtaa.blast.sorted.bed.txt"

	# head -n 1 "${_polap_var_chloroplot}/mtaa.blast.sorted.bed.txt" >1

	_polap_var_i=1
	while IFS= read -r gene; do
		printf "%s\n" "$gene" >"${_polap_var_chloroplot}"/${_polap_var_i}.gene.bed
		bedtools intersect -wa \
			-a "${_polap_var_chloroplot}"/mtaa.blast.bed4 \
			-b "${_polap_var_chloroplot}"/${_polap_var_i}.gene.bed \
			>"${_polap_var_chloroplot}"/${_polap_var_i}.bed4

		"$WDIR"/run-polap-blast-mtdna-1-determine-gene.R \
			"${_polap_var_chloroplot}"/${_polap_var_i}.bed4 \
			"$WDIR"/polap-mt.1.c70.3.faa.name \
			"$WDIR"/polap-mtgenes.txt \
			"${_polap_var_chloroplot}"/${_polap_var_i}.gene \
			"${_polap_var_chloroplot}"/${_polap_var_i}.bed4.description \
			"${_polap_var_chloroplot}"/${_polap_var_i}.bed4.count \
			>/dev/null 2>&1

		_polap_var_i=$((_polap_var_i + 1))

	done <"${_polap_var_chloroplot}/mtaa.blast.sorted.bed.txt"

	paste \
		<(cat "${_polap_var_chloroplot}"/*.gene.bed) \
		<(cat "${_polap_var_chloroplot}"/*.gene) \
		>"${_polap_var_chloroplot}"/annotation.bed

	echoerr "FILE: ${_polap_var_chloroplot}/annotation.bed"
	echoerr "CHECK: ${_polap_var_chloroplot}/*.check"
	ls ${_polap_var_chloroplot}/*.check 1>&2

	# Combine the following:
	# 1.gene
	# 1.gene.bed
	#
	#

	# csvtk cut -t -f 2,9,10,1 "${_polap_var_chloroplot}"/mtaa.blast >2

	# cut -f "${_polap_var_chloroplot}"/mtaa.blast

	# if [ "$DEBUG" -eq 1 ]; then set +x; fi
	# while IFS= read -r contig; do
	# 	grep -w "$contig" "$MTAABLAST".sorted.bed >"$MTAABED"/"$contig".bed
	# 	bedtools merge -i "$MTAABED"/$contig.bed >"$MTAABED"/"$contig".bed.txt
	# 	printf "%s\t%d\n" "$contig" $(wc -l <"$MTAABED"/$contig.bed.txt)
	# done <"$CONTIGNAME" | sort -k2 -rn >"$MTGENECOUNT"
	# if [ "$DEBUG" -eq 1 ]; then set -x; fi

	# echo "INFO: compressing the BLAST results of mitochondrial gene annotation"
	# tar zcf "$ADIR"/mtaa.bed.tar.gz "$ADIR"/mtaa.bed
	# rm -rf "$ADIR"/mtaa.bed

	echoerr "NEXT: $(basename $0) gene-table-mtdna -o $ODIR [-i $INUM]"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# based on _run_polap_count-gene
#
# Gene table for importing to Chloroplot R package.
################################################################################
function _run_polap_plot-mtdna() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	FDIR="$ODIR"/$INUM
	_polap_var_chloroplot=$ODIR/$INUM/60-chloroplot

	help_message=$(
		cat <<HEREDOC
# Counts genes annotated on a genome assembly.
# Arguments:
#   -i $INUM: a Flye genome assembly number
# Inputs:
#   $FDIR/30-contigger/contigs_stats.txt
#   $MTGENECOUNT
#   $PTGENECOUNT
# Outputs:
#   $FDIR/mt.contig.name-1
#   $FDIR/mt.contig.name-2
#   $FDIR/assembly_info_organelle_annotation_count.txt
#   $FDIR/assembly_info_organelle_annotation_count-all.txt
#   $FDIR/contig-annotation-table.txt 
Example: $(basename "$0") ${_arg_menu[0]} [-i|--inum <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	echoall "INFO: plot mitochondrial DNA genome on $INUM ..."

	"$WDIR"/run-polap-plot-mtdna.R \
		${_polap_var_chloroplot}/annotation.bed \
		$ODIR/$INUM/mt.3.fa
	>/dev/null 2>&1

	echoerr "FILE: see mt.3.pdf"

	# echoerr NEXT: $(basename "$0") select-reads -o "$ODIR" [-i $ANUM] [-j $ANUMNEXT]
	# echoerr NEXT: $(basename "$0") assemble2 -o "$ODIR" [-i $ANUM] [-j $ANUMNEXT]
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# Selects and assembles long-read data.
# Arguments:
#   -i 0
#   -j 1
#   -o o
#   -t $NT
#   -m $MR
#   MPAIR
#   MBRIDGE
#   COV
#   CIRCULARIZE
# Inputs:
# Outputs:
################################################################################
function _run_polap_assemble2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR="$ODIR"/$INUM
	ADIR="$FDIR"/50-annotation
	MTDIR="$ODIR"/$JNUM
	MTSEEDSDIR="$MTDIR"/seeds

	MTCONTIGNAME="$FDIR"/mt.contig.name-"$JNUM"

	# for contigs
	#	assembly_graph_final_fasta=o/30-contigger/contigs.fasta
	#	for edges
	assembly_graph_final_fasta="$FDIR"/30-contigger/graph_final.fasta

	help_message=$(
		cat <<HEREDOC
# Selects reads mapped on a genome assembly and assembles an organelle genome.
# Arguments:
#   -i $INUM: source Flye (usually whole-genome) assembly number
#   -j $JNUM: destination Flye organelle assembly number
#   -r $MPAIR: minimum minimap2 alignment length for a pair of contigs
#   -x $MBRIDGE: minimum long-read length for connecting the pair of contigs
#   -w $MSINGLE: minimum minimap2 alignment length for a single contig
#   -t $NT: the number of CPU cores
#   -c $COV: the Flye's coverage option
#   -g <arg>: computed by find-genome-size menu or given by users
# Inputs:
#   $MTCONTIGNAME
#   ${assembly_graph_final_fasta}
# Outputs:
#   $MTDIR/contig.fa
#   $MTSEEDSDIR/1.names
#   $MTSEEDSDIR/2.fq.gz
#   $MTDIR/contig_total_length.txt
#   $MTDIR/30-contigger/contigs.fasta
#   $MTDIR/30-contigger/contigs_stats.txt
#   $MTDIR/30-contigger/graph_final.fasta
#   $MTDIR/30-contigger/graph_final.gfa
Example: $(basename $0) ${_arg_menu[0]} [-i|--inum <arg>] [-j|--jnum <arg>] [-r|--pair-min <arg>] [-x|--bridge-min <arg>] [-w|--single-min <arg>] [-t|--threads <arg>] [-c|--coverage <arg>]
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	if [ ! -s "$MTCONTIGNAME" ]; then
		echoall "ERROR: no such mt.contig.name file: $MTCONTIGNAME"
		exit $EXIT_ERROR
	fi

	if [ ! -s "${assembly_graph_final_fasta}" ]; then
		echoall "ERROR: no assembly fasta file: ${assembly_graph_final_fasta}"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $LRNK ]]; then
		echoall "ERROR: no $LRNK long read-data file found: $LRNK"
		exit $EXIT_ERROR
	fi

	echoerr "NEXT: $(basename $0) select-reads -o $ODIR -i $INUM -j $JNUM"
	_run_polap_select-reads
	_run_polap_flye2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# NOT IMPLEMENTED YET!
# because we need a manual long-read selection step.
# You could execute this menu with option --test.
#
# Runs the organelle-genome assembly.
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Inputs:
#   $LR: a long-read fastq
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
# Outputs:
#   $MTDIR/assembly_graph.gfa
################################################################################
function _run_polap_assemble() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MTDIR=$ODIR/$JNUM

	help_message=$(
		cat <<HEREDOC
# NOT IMPLEMENTED YET!
# because we need a manual long-read selection step.
# You could execute this menu with option --test.
#
# Runs the organelle-genome assembly.
# Arguments:
#   -o $ODIR
#   -l $LR: a long-read fastq data file
#   -a $SR1: a short-read fastq data file
#   -b $SR2: another short-read fastq data file
# Inputs:
#   $LR: a long-read fastq 
#   $SR1: a short-read fastq data file
#   $SR2: another short-read fastq data file
# Outputs:
#   $MTDIR/assembly_graph.gfa
Example: $(basename $0) ${_arg_menu[0]} --test
HEREDOC
	)

	if [[ ${_arg_menu[1]} == "help" ]]; then
		echoerr "${help_message}"
		exit $EXIT_SUCCESS
	fi

	_run_polap_assemble1
	_run_polap_annotate
	_run_polap_select-contigs
	# check the mt.contig.name-1
	if [ ! -s "$MTCONTIGNAME" ]; then
		die "LOG: $MTCONTIGNAME is empty. You have to choose seed contigs by yourself."
	fi
	_run_polap_assemble2
	INUM=1 _run_polap_annotate
	# _run_polap_flye-polishing
	INUM=1 _run_polap_select-mtdna
	_run_polap_prepare-polishing
	PA=$ODIR/1/mt.0.fasta
	FA=$ODIR/1/mt.1.fa
	_run_polap_polish

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_x-help() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	print_x-help 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

################################################################################
# utilities
################################################################################

################################################################################
# for the magic logit function
################################################################################
function logit() {
	while read; do
		# echo "$(date) $REPLY" >> ${LOG_FILE}
		# -1 means "current time"
		# printf "[%(%Y-%m-%d %T)T] %s\n" -1 "$REPLY" >> ${LOG_FILE}
		printf "[%s] %s\n" "$(date +"%Y-%m-%d %T")" "$REPLY" >>${LOG_FILE}
	done
}

function echoerr() { echo "$@" 1>&2; }

function echoall() {
	echo "$@" 1>&2
	echo "$@"
}

function yell() { echo "$0: $*" >&2; }
function die() {
	yell "$*"
	exit 111
}
function try() { "$@" || die "cannot $*"; }

################################################################################
# All of the variables at our disposal
################################################################################

# include and execute other BASH and R scripts
WDIR="$(dirname "$0")"
WDIR="${BASH_SOURCE%/*}"
if [[ ! -d "$WDIR" ]]; then
	WDIR="$PWD"
fi
WDIR=$script_dir

# variables for input data file names for flexible data processing.
LR=$_arg_long_reads       # long-read data file
SR1=$_arg_short_read1     # paired short-read data file 1
SR2=$_arg_short_read2     # paired short-read data file 2
PA=$_arg_unpolished_fasta # assembled draft sequence extracted from bandage
FA=$_arg_final_assembly   # polished sequence

# variables for output
ODIR=$_arg_outdir
INUM=$_arg_inum
JNUM=$_arg_jnum
FDIR="$ODIR"/0 # flye 1st output

# tuning variables for optimal performance
LRNK=$ODIR/nk.fq.gz
MR=$_arg_min_read_length
MPAIR=$_arg_pair_min     # 3000 for MT, 1000 for PT
MBRIDGE=$_arg_bridge_min # used to be 3000,
MSINGLE=$_arg_single_min # not used deprecated
COV=$_arg_coverage
# NT=$(cat /proc/cpuinfo | grep -c processor)
NT=$_arg_threads
if test -z "$DEBUG"; then
	DEBUG=0
fi
CIRCULARIZE=$_arg_circularize # "--circularize"
SPECIES=$_arg_species

################################################################
# Variables
SRA=$_arg_sra
SRALONG=""
SRASHORT=""
RESUME=$_arg_resume
ALL_ANNOTATE="--selective-annotate"
FLYE_CONTIGGER="--contigger"
USE_EDGES="--no-use-edges"
NO_REDUCTION_READS=$_arg_reduction_reads
NO_COVERAGE_CHECK=$_arg_coverage_check

# Constants
EXIT_SUCCESS=0
EXIT_FAIL=1
EXIT_ERROR=2
RETURN_SUCCESS=0
RETURN_FAIL=1

SECONDS=0

################################################################
# MAIN
#
if [ $# -eq 0 ]; then
	print_help
	touch make-menus
	exit $EXIT_SUCCESS
fi

# all message to a log file
# https://stackoverflow.com/questions/49851882/how-to-log-echo-statement-with-timestamp-in-shell-script
if [ "${_arg_log}" = "polap.log" ]; then
	LOG_FILE="./polap.log"
else
	LOG_FILE="${_arg_log}"
fi
exec 3>&1 1>> >(logit)
# exec 3>&1 1>> >(logit) 2>&1

CMD="$0 $*"
echo "CMD: $CMD"

# subcommand function call
if declare -f "_run_polap_${_arg_menu[0]}" >/dev/null 2>&1; then
	# invoke that function, passing arguments through
	_run_polap_"$@" # same as "$1" "$2" "$3" ... for full argument list
else
	echoerr "Menu: assemble1, annotate, assemble2,"
	echoerr "      reset, total-length-long, find-genome-size, reduce-data, flye1,"
	echoerr "      blast-genome, count-gene, select-reads, flye2,"
	echoerr "      flye-polishing, prepare-polishing, polish,"
	echoerr "      assemble,"
	echoerr "ERROR: no such menu of $1"
fi

ELAPSED="Time: $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
