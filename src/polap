#!/usr/bin/env bash
################################################################################
# This file is part of polap.
#
# polap is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# polap is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# polap. If not, see <https://www.gnu.org/licenses/>.
################################################################################

# Created by argbash-init v2.10.0
# DEFINE_SCRIPT_DIR([])
# INCLUDE_PARSING_CODE([polap-parsing.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# set -e
# set -u
# set -euo pipefail
# _POLAP_DEBUG=0
# _POLAP_RELEASE=0
if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
	echo "[ERROR] This script must be executed, not sourced: use 'bash $BASH_SOURCE'" >&2
	return 1 2>/dev/null || exit 1
fi
: "${_POLAP_DEBUG:=0}"
export _POLAP_DEBUG
: "${_POLAP_RELEASE:=1}"
export _POLAP_RELEASE

# OTHER STUFF GENERATED BY Argbash
_polap_script_bin_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}
_POLAPLIB_DIR="${_polap_script_bin_dir}/polaplib"
source "${_POLAPLIB_DIR}/polap-lib-version.sh"

. "${_POLAPLIB_DIR}/polap-parsing.sh" # '.' means 'source'
_polap_output_dest="/dev/null"

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# vvv  PLACE YOUR CODE HERE  vvv

################################################################################
# include bash shell files
################################################################################

# for var in $(compgen -v _arg_); do
# 	echo "$var=${!var}"
# done

source "${_POLAPLIB_DIR}/polap-constants.sh"
source "${_POLAPLIB_DIR}/polap-lib-debug.sh"
source "${_POLAPLIB_DIR}/polap-lib-string.sh"
source "${_POLAPLIB_DIR}/polap-lib-steps.sh"
source "${_POLAPLIB_DIR}/polap-lib-errors.sh"
source "${_POLAPLIB_DIR}/run-polap-function-utilities.sh"
source "${_POLAPLIB_DIR}/polap-lib-log.sh"
source "${_POLAPLIB_DIR}/polap-lib-conda.sh"
source "${_POLAPLIB_DIR}/polap-lib-file.sh"
source "${_POLAPLIB_DIR}/polap-lib-filepath.sh"
source "${_POLAPLIB_DIR}/polap-lib-fastq.sh"
source "${_POLAPLIB_DIR}/polap-lib-array.sh"
source "${_POLAPLIB_DIR}/polap-lib-timing.sh"
source "${_POLAPLIB_DIR}/polap-lib-number.sh"
source "${_POLAPLIB_DIR}/polap-lib-ncbi.sh"
source "${_POLAPLIB_DIR}/polap-lib-random.sh"
source "${_POLAPLIB_DIR}/polap-lib-process.sh"
source "${_POLAPLIB_DIR}/polap-lib-wga.sh"
source "${_POLAPLIB_DIR}/polap-lib-oga.sh"
source "${_POLAPLIB_DIR}/polap-lib-man.sh"
source "${_POLAPLIB_DIR}/polap-lib-mt.sh"
source "${_POLAPLIB_DIR}/polap-lib-pt.sh"
source "${_POLAPLIB_DIR}/polap-lib-assemble.sh"
source "${_POLAPLIB_DIR}/polap-lib-seed-read.sh"
source "${_POLAPLIB_DIR}/polap-lib-test.sh"
source "${_POLAPLIB_DIR}/polap-lib-lines.sh"
source "${_POLAPLIB_DIR}/polap-lib-annotate.sh"
source "${_POLAPLIB_DIR}/polap-lib-filter.sh"
source "${_POLAPLIB_DIR}/polap-lib-bandage.sh"
source "${_POLAPLIB_DIR}/polap-lib-readassemble.sh"
source "${_POLAPLIB_DIR}/polap-cmd-readassemble.sh"
source "${_POLAPLIB_DIR}/polap-cmd-assemble-rate.sh"
source "${_POLAPLIB_DIR}/polap-cmd-assemble-omega.sh"
source "${_POLAPLIB_DIR}/polap-cmd-pt.sh"
source "${_POLAPLIB_DIR}/polap-cmd-mt.sh"
source "${_POLAPLIB_DIR}/polap-cmd-annotate-read.sh"
source "${_POLAPLIB_DIR}/polap-cmd-seed-read.sh"
source "${_POLAPLIB_DIR}/polap-cmd-simulate.sh"
source "${_POLAPLIB_DIR}/polap-cmd-count.sh"
source "${_POLAPLIB_DIR}/polap-cmd-filter.sh"
source "${_POLAPLIB_DIR}/polap-cmd-blast.sh"
source "${_POLAPLIB_DIR}/polap-cmd-menus.sh"
source "${_POLAPLIB_DIR}/polap-function-set-variables.sh"

source "${_POLAPLIB_DIR}/polap-cmd-fasta.sh"
source "${_POLAPLIB_DIR}/polap-cmd-fastq.sh"
source "${_POLAPLIB_DIR}/polap-cmd-subtract.sh"
source "${_POLAPLIB_DIR}/polap-cmd-random.sh"
source "${_POLAPLIB_DIR}/polap-cmd-bandage.sh"
source "${_POLAPLIB_DIR}/polap-cmd-wga.sh"
# source "${_POLAPLIB_DIR}/run-polap-function-nextdenovo.sh"

source "${_POLAPLIB_DIR}/polap-function-disassemble-seeds.sh"

# organelle-genome annotation
source "${_POLAPLIB_DIR}/polap-cmd-annotate.sh"
source "${_POLAPLIB_DIR}/run-polap-function-annotate-contig.sh"

# read selection and organelle-genome assembly
source "${_POLAPLIB_DIR}/polap-cmd-oga.sh"
source "${_POLAPLIB_DIR}/run-polap-function-dga.sh"
source "${_POLAPLIB_DIR}/polap-cmd-polishing.sh"

# Template
source "${_POLAPLIB_DIR}/run-polap-function-template.sh"

# NCBI: BioProject
source "${_POLAPLIB_DIR}/polap-cmd-bioproject.sh"

# contig selection
source "${_POLAPLIB_DIR}/polap-cmd-seeds.sh"

# mtDNA or ptDNA selection
# mtDNA annotation and plotting
# NCBI: mtDNA
source "${_POLAPLIB_DIR}/polap-cmd-mtdna.sh"

# report, archive, and cleanup
source "${_POLAPLIB_DIR}/polap-cmd-archive.sh"

# assemble
source "${_POLAPLIB_DIR}/polap-cmd-assemble.sh"
source "${_POLAPLIB_DIR}/polap-cmd-disassemble.sh"
source "${_POLAPLIB_DIR}/polap-cmd-disassemble-hifi.sh"
source "${_POLAPLIB_DIR}/run-polap-function-directional.sh"

# miscellaneous
source "${_POLAPLIB_DIR}/run-polap-function-miscellaneous.sh"

source "${_POLAPLIB_DIR}/polap-cmd-test.sh"
# source "${_POLAPLIB_DIR}/run-polap-function-taxonomy.sh"

source "${_POLAPLIB_DIR}/polap-cmd-install.sh"
source "${_POLAPLIB_DIR}/polap-cmd-demo.sh"
# source "${_POLAPLIB_DIR}/run-polap-function-ncbixml.sh"
source "${_POLAPLIB_DIR}/polap-lib-config.sh"

source "${_POLAPLIB_DIR}/polap-cmd-ptgaul.sh"
source "${_POLAPLIB_DIR}/polap-cmd-version.sh"
source "${_POLAPLIB_DIR}/polap-lib-data.sh"
# ADD A NEW SUBCOMMAND SOURCE HERE.

################################################################################
# All of the variables at our disposal
################################################################################

################################################################
# MAIN
#
if [ $# -eq 0 ]; then
	print_help
	touch make-menus
	exit $EXIT_SUCCESS
fi

# the default output o is created.
# o/polap.log, o/tmp, o/log are created as well.
source "${_POLAPLIB_DIR}/polap-variables-main.sh"

# see polap-variables-main.sh for the logit function.
# all message to a log file
# https://stackoverflow.com/questions/49851882/how-to-log-echo-statement-with-timestamp-in-shell-script
exec 3>&1 1>> >(logit)
# exec 3>&1 1>> >(logit) 2>&1

[[ "${_arg_clock}" == "on" ]] && date +"%Y-%m-%d %H:%M:%S" >&3
CMD="$0 $*"
echo "POLAP: ${_polap_version}"
echo "CMD: $CMD"

# Print all the global variables from polap-parsing.sh.
for var in $(compgen -v _arg_); do
	echo "$var=${!var}"
done

# Options
if [[ -n "${_arg_genomesize}" ]]; then
	_arg_genomesize=$(_polap_lib_unit-convert_to_int ${_arg_genomesize})
fi

# Call a subcommand function
if declare -f "_run_polap_${_arg_menu[0]}" >/dev/null 2>&1; then
	# invoke that function, passing arguments through
	# _run_polap_"$@" # same as "$1" "$2" "$3" ... for full argument list
	if _run_polap_${_arg_menu[0]}; then
		_polap_log3 "Menu ${_arg_menu[0]} has been finished."
	else
		_polap_error_message $?
	fi
else
	# Check arguments as files
	for _menu_item in "${_arg_menu[@]}"; do

		seqtype=$(_polap_lib_fastq-check-type "${_menu_item}")

		case "$seqtype" in
		illumina)
			_polap_log1 "Detected Illumina short-read"
			if [[ "${_arg_short_read1_is}" == "on" ]]; then
				_arg_short_read2="${_menu_item}"
				_arg_short_read2_is="on"
			fi
			_arg_short_read1="${_menu_item}"
			_arg_short_read1_is="on"
			;;
		pacbio-hifi)
			_polap_log1 "Detected PacBio HiFi read"
			_arg_long_reads="${_menu_item}"
			_arg_long_reads_is="on"
			;;
		nano-raw)
			_polap_log1 "Detected Nanopore raw read"
			_arg_long_reads="${_menu_item}"
			_arg_long_reads_is="on"
			;;
		unknown)
			_polap_log1 "Could not determine sequencing type: pacbio-clr, nano-hq"
			;;
		esac
	done

	if [[ -s "${_arg_long_reads}" ]]; then
		seqtype=$(_polap_lib_fastq-check-type "${_arg_long_reads}")
		if [[ "${seqtype}" == "nano-raw" ]]; then
			_polap_log0 "ONT long-read: ${_arg_long_reads}"
			_arg_data_type="nano-raw"
			_arg_flye_data_type="--nano-raw"
			_arg_minimap2_data_type="map-ont"
		elif [[ "${seqtype}" == "pacbio-hifi" ]]; then
			_polap_log0 "PacBio HiFi long-read: ${_arg_long_reads}"
			_arg_data_type="pacbio-hifi"
			_arg_flye_data_type="--pacbio-hifi"
			_arg_minimap2_data_type="map-hifi"
		else
			_polap_log0 "ERROR: no long-read data"
		fi
	fi

	if [[ -s "${_arg_short_read1}" ]]; then
		seqtype=$(_polap_lib_fastq-check-type "${_arg_short_read1}")
		if [[ "${seqtype}" == "illumina" ]]; then
			_polap_log0 "Short-read 1: ${_arg_short_read1}"
		else
			_polap_log0 "ERROR: no short-read data: ${_arg_short_read1}"
		fi
	else
		_polap_log1 "no short-read data"
	fi

	if [[ -s "${_arg_short_read2}" ]]; then
		seqtype=$(_polap_lib_fastq-check-type "${_arg_short_read2}")
		if [[ "${seqtype}" == "illumina" ]]; then
			_polap_log0 "Short-read 2: ${_arg_short_read2}"
		else
			_polap_log0 "ERROR: no short-read data: ${_arg_short_read2}"
		fi
	else
		_polap_log1 "no short-read data"
	fi

	if [[ -s "${_arg_long_reads}" ]]; then
		_polap_log1 "Execute polap command"
		if [[ "${_arg_plastid}" == "on" ]]; then
			_run_polap_readassemble
		else
			_arg_plastid="on"
			_run_polap_readassemble
			_arg_plastid="off"
			_arg_noncoding="on"
			_run_polap_readassemble
		fi
	else
		_polap_log0 "-----------------------------------"
		_polap_log0 "Menu: assemble, prepare-polishing, polish"
		_polap_log0 "  assemble1, total-length-long, find-genome-size, reduce-data, flye1, annotate"
		_polap_log0 "  assemble2, select-seeds, map-reads, test-reads, select-reads, flye2"
		_polap_log0 "ERROR: no such menu of $1"
	fi
fi

[[ "${_arg_clock}" == "on" ]] && date +"%Y-%m-%d %H:%M:%S" >&3
ELAPSED="Time at $(hostname): $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"

# Close FD 3 when no longer needed
exec 3>&-

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
