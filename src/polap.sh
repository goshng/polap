#!/usr/bin/env bash

# Created by argbash-init v2.10.0
# DEFINE_SCRIPT_DIR([])
# INCLUDE_PARSING_CODE([polap-parsing.sh])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}
. "$script_dir/polap-parsing.sh" # '.' means 'source'

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash

# vvv  PLACE YOUR CODE HERE  vvv
# For example:
# printf 'Value of --%s: %s\n' 'long-reads' "$_arg_long_reads"
# printf 'Value of --%s: %s\n' 'outdir' "$_arg_outdir"
# printf 'Value of --%s: %s\n' 'short-read1' "$_arg_short_read1"
# printf 'Value of --%s: %s\n' 'short-read2' "$_arg_short_read2"
# printf 'Value of --%s: %s\n' 'sra' "$_arg_sra"
# printf 'Value of --%s: %s\n' 'unpolished-fasta' "$_arg_unpolished_fasta"
# printf 'Value of --%s: %s\n' 'final-assembly' "$_arg_final_assembly"
# printf 'Value of --%s: %s\n' 'min-read-length' "$_arg_min_read_length"
# printf 'Value of --%s: %s\n' 'threads' "$_arg_threads"
# printf 'Value of --%s: %s\n' 'coverage' "$_arg_coverage"
# printf 'Value of --%s: %s\n' 'single-min' "$_arg_single_min"
# printf "'%s' is %s\\n" 'reduction-reads' "$_arg_reduction_reads"
# printf "'%s' is %s\\n" 'contigger' "$_arg_contigger"
# printf "'%s' is %s\\n" 'all-annotate' "$_arg_all_annotate"
# printf "'%s' is %s\\n" 'use-edges' "$_arg_use_edges"
# printf "'%s' is %s\\n" 'coverage-check' "$_arg_coverage_check"
# printf "'%s' is %s\\n" 'resume' "$_arg_resume"
# printf "'%s' is %s\\n" 'circularize' "$_arg_circularize"
# printf "'%s' is %s\\n" 'step0' "$_arg_step0"
# printf "'%s' is %s\\n" 'step1' "$_arg_step1"
# printf "'%s' is %s\\n" 'step2' "$_arg_step2"
# printf "'%s' is %s\\n" 'step3' "$_arg_step3"
# printf "'%s' is %s\\n" 'step4' "$_arg_step4"
# printf "'%s' is %s\\n" 'step5' "$_arg_step5"
# printf "'%s' is %s\\n" 'step6' "$_arg_step6"
# printf "'%s' is %s\\n" 'step7' "$_arg_step7"
# printf "'%s' is %s\\n" 'step8' "$_arg_step8"
# printf "'%s' is %s\\n" 'step9' "$_arg_step9"
# printf "Value of '%s': %s\\n" 'menu' "${_arg_menu[0]}"
# printf "Value of '%s': %s\\n" 'menu' "${_arg_menu[1]}"
# printf "Value of '%s': %s\\n" 'menu' "${_arg_menu[2]}"

# functions
#
function run_check1() {
	command -v bc >/dev/null 2>&1 || {
		echo >&2 "bc: not installed"
		return $RETURN_FAIL
	}
	command -v seqkit >/dev/null 2>&1 || {
		echo >&2 "seqkit: not installed"
		return $RETURN_FAIL
	}
	command -v minimap2 >/dev/null 2>&1 || {
		echo >&2 "minimap2: not installed"
		return $RETURN_FAIL
	}
	command -v flye >/dev/null 2>&1 || {
		echo >&2 "flye: not installed"
		return $RETURN_FAIL
	}
	command -v makeblastdb >/dev/null 2>&1 || {
		echo >&2 "makeblastdb: not installed"
		return $RETURN_FAIL
	}
	command -v tblastn >/dev/null 2>&1 || {
		echo >&2 "tblastn: not installed"
		return $RETURN_FAIL
	}
	command -v bedtools >/dev/null 2>&1 || {
		echo >&2 "bedtools: not installed"
		return $RETURN_FAIL
	}
	command -v prefetch >/dev/null 2>&1 || {
		echo >&2 "prefetch: not installed"
		return $RETURN_FAIL
	}
	command -v jellyfish >/dev/null 2>&1 || {
		echo >&2 "jellyfish: not installed"
		return $RETURN_FAIL
	}
	command -v csvtk >/dev/null 2>&1 || {
		echo >&2 "csvtk: not installed"
		return $RETURN_FAIL
	}
	return $RETURN_SUCCESS
}

function run_check2() {
	command -v msbwt >/dev/null 2>&1 || {
		echo >&2 "msbwt: not installed"
		return $RETURN_FAIL
	}
	command -v ropebwt2 >/dev/null 2>&1 || {
		echo >&2 "ropebwt2: not installed"
		return $RETURN_FAIL
	}
	command -v fmlrc >/dev/null 2>&1 || {
		echo >&2 "ropebwt2: not installed"
		return $RETURN_FAIL
	}
	return $RETURN_SUCCESS
}

function run_output2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi
	echo INFO: source code folder: $WDIR
	echo INFO: output folder: $ODIR
	echo INFO: number of CPUs: $NT
	echo INFO: source flye output: $INUM
	echo INFO: destination flye output: $JNUM
	echoerr INFO: ${_arg_minimum[@]}
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_template() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echoall $0
	echoall $FUNCNAME
	echoall $1
	echoall $2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function join_by {
	local d=${1-} f=${2-}
	if shift 2; then
		printf %s "$f" "${@/#/$d}"
	fi
}

# not working or NCBI connection errors
# https://github.com/schultzm/entrez_direct_tut
function _run_polap_bioproject() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	mkdir $ODIR
	BIOPRJ=$_arg_bioproject

	MDATA="$ODIR/accessions_demo.txt"
	esearch -db bioproject -query $BIOPRJ | elink -target biosample | efetch -format docsum | xtract.Linux -pattern DocumentSummary -block Ids -element Id -group SRA >${MDATA}
	SRSs=$(cat ${MDATA} | while read LINE; do
		NCOL=$(echo ${LINE} | wc -w)
		ACC=$(echo ${LINE} | cut -d ' ' -f ${NCOL})
		echo ${ACC}
	done | xargs)

	# SRS_str=$(join_by ' OR ' ${SRSs[@]})
	# echoall $SRS_str
	# esearch -db SRA -query "\"" $SRS_str "\"" | efetch -format runinfo | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	for SRS in ${SRSs[@]}; do
		esearch -db SRA -query ${SRS} | efetch -format runinfo
		# esearch -db SRA -query ${SRS} | efetch -format runinfo | tail -n +2
	done >$ODIR/accessions_demo.tab
	# csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty 1>&2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_sra() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	SRA=$_arg_sra
	$script_dir/ncbitools fetch sra "$SRA"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

###############################################################################
# START of main functions
#
# polap analysis
#
# most data
# yang ~/hey/run/mtdna$
# Lolium perenne
# thorne:/media/h1/run/mtdna$

function _run_polap_reset() {
	if ! run_check1; then
		echoerr "ERROR: change your conda environment to polap-dev."
		echoerr "INFO: (base) $ conda env create -f src/environment.yaml"
		echoerr "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi
	if [ "$DEBUG" -eq 1 ]; then set -x; fi
	if [ -d "$ODIR" ]; then
		while true; do
			read -p "Folder [$ODIR] already exists. Do you want to delete it? [y/n] " yn
			case $yn in
			[Yy]*)
				rm -rf $ODIR
				break
				;;
			[Nn]*)
				exit $EXIT_FAIL
				;;
			*) echo "Please answer yes or no." ;;
			esac
		done
	fi
	mkdir -p "$ODIR"
	echoall "DATA: Your output folder [$ODIR] is created."
	if [ "$ODIR" != "o" ]; then
		echoall "Use -o $ODIR option in all subsequent analysis"
		echoall "  because your output folder is not the default of 'o'."
	fi
	echoerr NEXT: $0 total-length-long [-l l.fq]
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_total-length-long() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echoerr "please, wait ..."
	seqkit stats -Ta "$LR" | csvtk cut -t -f "sum_len" | csvtk del-header >"$ODIR"/long_total_length.txt
	LONG_TOTAL_LENGTH=$(cat "$ODIR"/long_total_length.txt)
	echoall "DATA: total length of your long-read data (bases): $LONG_TOTAL_LENGTH"
	echoerr NEXT: $0 find-genome-size [-a s1.fq] [-b s2.fq]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_find-genome-size() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echoerr "please, wait ..."
	# See https://bioinformatics.uconn.edu/genome-size-estimation-tutorial/
	if [ -s $SR1 ]; then
		if [ -s $SR2 ]; then
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1" "$SR2"
		else
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1"
		fi
	else
		echoerr "ERROR: no short-read data: $SR1"
		exit $EXIT_ERROR
	fi
	jellyfish histo -o "$ODIR"/jellyfish_out.histo "$ODIR"/jellyfish_out
	"$WDIR"/run-polap-jellyfish.R \
		"$ODIR"/jellyfish_out.histo \
		"$ODIR"/short_expected_genome_size.txt

	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	echoall "DATA: expected genome size using short-read data (bases): $EXPECTED_GENOME_SIZE"
	# EXPECTED_COVERAGE=$(cat "$ODIR"/long_coverage.txt)
	# EXPECTED_COVERAGE=${EXPECTED_COVERAGE%.*}
	# echo "DATA: long reads expected coverage: ${EXPECTED_COVERAGE}x"
	echoerr NEXT: $0 reduce-data [-m 3000]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

# -l l.fq -m 3000
function _run_polap_reduce-data() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi
	# step1
	seqkit seq --quiet -m "$MR" --threads 4 "$LR" -o "$LRNK" >/dev/null 2>&1
	echo "DATA: long-read minimum $MR reads data $LRNK is created"
	echoerr NEXT: $0 flye1 [-g 150000] [-t 4] [-c 30] [-o o]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

# ODIR
# LR
# SR1
# SR2
function _run_xxx_find-genome-size2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echoerr "please, wait ..."
	seqkit stats -Ta "$LR" | csvtk cut -t -f "sum_len" | csvtk del-header >"$ODIR"/long_total_length.txt
	LONG_TOTAL_LENGTH=$(cat "$ODIR"/long_total_length.txt)
	echo "DATA: long reads total (bases): $LONG_TOTAL_LENGTH"

	# See https://bioinformatics.uconn.edu/genome-size-estimation-tutorial/

	if [ -s $SR1 ]; then
		if [ -s $SR2 ]; then
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1" "$SR2"
		else
			jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1"
		fi
	else
		echoerr "ERROR: no short-read data: $SR1"
		exit $EXIT_ERROR
	fi
	jellyfish histo -o "$ODIR"/jellyfish_out.histo "$ODIR"/jellyfish_out
	"$WDIR"/run-polap-jellyfish.R "$ODIR"/jellyfish_out.histo \
		"$LONG_TOTAL_LENGTH" \
		"$ODIR"/long_coverage.txt \
		"$ODIR"/short_expected_genome_size.txt
	EXPECTED_COVERAGE=$(cat "$ODIR"/long_coverage.txt)
	EXPECTED_COVERAGE=${EXPECTED_COVERAGE%.*}
	echo "DATA: long reads expected coverage: ${EXPECTED_COVERAGE}x"
	echoerr NEXT: $0 reduce-data [-m 3000]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_flye1() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	FDIR=$ODIR/0
	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	echo "DATA: short reads expected genome size (bases): $EXPECTED_GENOME_SIZE"
	if [ ! -z "$_arg_genomesize" ]; then
		EXPECTED_GENOME_SIZE=$_arg_genomesize
		echoall "OPTION: short reads expected genome size (bases) we use instead: $EXPECTED_GENOME_SIZE"
	fi

	echo "INFO: executing the whole-genome assembly using flye ... be patient!"
	flye --nano-raw "$LRNK" \
		--out-dir "$FDIR" \
		--threads "$NT" \
		--asm-coverage "$COV" \
		--genome-size "$EXPECTED_GENOME_SIZE" \
		--stop-after contigger \
		>/dev/null 2>&1

	echo "INFO: assembly graph in the flye contigger stage: $PWD/$FDIR/30-contigger/graph_final.gfa"
	echoerr "NEXT: $0 annotate [0]"

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_blast-genome() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	# src/run-polap-annotation o "$NT" --selective-annotate --contigger
	if [ $# -eq 0 ]; then
		ANUM=0
	else
		ANUM=$1
	fi
	echoall "please, wait for contig annotation with mitochondrial and plastid genes on $ANUM"

	MTAA=$WDIR/mt.1.c70.3.faa
	PTAA=$WDIR/pt.2.c70.3.faa
	# FLYEDIR=$ODIR
	# NUMTHREADS=$NT

	# ALL_ANNOTATE=1
	# FLYE_CONTIGGER=1

	FDIR=$ODIR/$ANUM
	ASSEMBLYINFO="$FDIR"/30-contigger/contigs_stats.txt
	ASSEMBLYFILE="$FDIR"/30-contigger/contigs.fasta

	ADIR="$FDIR"/50-annotation
	CONTIGFILE="$ADIR"/contig.fasta
	CONTIGDB="$ADIR"/contig
	MTAABLAST="$ADIR"/mtaa.blast
	MTAABED="$ADIR"/mtaa.bed
	MTGENECOUNT="$ADIR"/mt.gene.count
	PTAABLAST="$ADIR"/ptaa.blast
	PTAABED="$ADIR"/ptaa.bed
	PTGENECOUNT="$ADIR"/pt.gene.count

	if [ -d "$ADIR" ]; then
		rm -rf "$ADIR"
		echo "INFO: $ADIR is deleted."
	fi
	mkdir -p "$ADIR"
	echo "INFO: $ADIR is created."

	CONTIGNAME="$ADIR"/contig.name

	#src/run-polap-select.R o/30-contigger/contigs_stats.txt o/50-annotation/contig.name
	grep -v "#" $ASSEMBLYINFO | cut -f 1 >$CONTIGNAME
	echo "INFO: contig sequence names in file: $CONTIGNAME"

	# seqkit grep --threads $NT -f "$CONTIGNAME" \
	# 	"$ASSEMBLYFILE" \
	# 	-o "$ADIR"/contig.fasta \
	# 	>/dev/null 2>&1
	cp $ASSEMBLYFILE "$ADIR"/contig.fasta
	echo "INFO: contig sequence file: $ADIR/contig.fasta"

	makeblastdb -dbtype nucl \
		-in "$ASSEMBLYFILE" \
		-out "$ADIR"/contig \
		>/dev/null 2>&1
	echo "INFO: BLASTDB of the contig sequences: $ADIR/contig"

	# mtDNA gene annotation and counts
	echo "INFO: BLAST of the mitochondrial proteins againt $ADIR/contig"
	echo "INFO: executing the tblastn ... be patient!"
	tblastn -query "$MTAA" \
		-db "$ADIR"/contig \
		-out "$ADIR"/mtaa.blast \
		-evalue 1e-30 \
		-outfmt '6 qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle salltitles' \
		-num_threads "$NT" \
		>/dev/null 2>&1
	"$WDIR"/run-polap-genes.R "$ADIR"/mtaa.blast \
		"$ADIR"/mtaa.blast.bed \
		>/dev/null 2>&1
	sort -k1,1 -k2,2n "$ADIR"/mtaa.blast.bed >"$MTAABLAST".sorted.bed
	mkdir "$ADIR"/mtaa.bed

	# + IFS=
	# + read -r contig
	# + grep -w contig_2905 o/50-annotation/ptaa.blast.sorted.bed
	# + bedtools merge -i o/50-annotation/ptaa.bed/contig_2905.bed
	# ++ wc -l
	# + printf '%s\t%d\n' contig_2905 0
	# + IFS=
	# + read -r contig

	echo "INFO: counting mitochondrial genes in the contigs"
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
	while IFS= read -r contig; do
		grep -w $contig "$MTAABLAST".sorted.bed >"$MTAABED"/"$contig".bed
		bedtools merge -i "$MTAABED"/$contig.bed >"$MTAABED"/"$contig".bed.txt
		printf "%s\t%d\n" $contig $(wc -l <"$MTAABED"/$contig.bed.txt)
	done <"$CONTIGNAME" | sort -k2 -rn >"$MTGENECOUNT"
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: compressing the BLAST results of mitochondrial gene annotation"
	tar zcf "$ADIR"/mtaa.bed.tar.gz "$ADIR"/mtaa.bed
	rm -rf "$ADIR"/mtaa.bed

	# Plastid gene annotation and counts
	echo "INFO: BLAST of the plastid proteins againt $ADIR/contig"
	echo "INFO: executing the tblastn ... be patient!"
	tblastn -query "$PTAA" \
		-db "$ADIR"/contig \
		-out "$ADIR"/ptaa.blast \
		-evalue 1e-30 -outfmt '6 qaccver saccver pident length mismatch gapopen qstart qend sstart send evalue bitscore stitle salltitles' \
		-num_threads $NT \
		>/dev/null 2>&1
	"$WDIR"/run-polap-genes.R "$ADIR"/ptaa.blast \
		"$ADIR"/ptaa.blast.bed \
		>/dev/null 2>&1
	sort -k1,1 -k2,2n "$ADIR"/ptaa.blast.bed >"$PTAABLAST".sorted.bed
	mkdir "$ADIR"/ptaa.bed

	echo "INFO: counting plastid genes in the contigs"
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
	while IFS= read -r contig; do
		grep -w $contig "$PTAABLAST".sorted.bed >"$PTAABED"/$contig.bed
		bedtools merge -i "$PTAABED"/$contig.bed >"$PTAABED"/$contig.bed.txt
		printf "%s\t%d\n" $contig $(wc -l <"$PTAABED"/$contig.bed.txt)
	done <"$CONTIGNAME" | sort -k2 -rn >"$PTGENECOUNT"
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: compressing the BLAST results of plastid gene annotation"
	tar zcf "$ADIR"/ptaa.bed.tar.gz "$ADIR"/ptaa.bed
	rm -rf "$ADIR"/ptaa.bed

	echoerr "NEXT: $0 count-gene $ANUM"
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_count-gene() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		ANUM=0
	else
		ANUM=$1
	fi
	echoall "INFO: count mitochondrial and plastid genes on $ANUM"

	FDIR=$ODIR/$ANUM
	ADIR="$FDIR"/50-annotation
	"$WDIR"/run-polap-mtcontig.R "$FDIR" \
		"$FDIR"/mt.contig.name \
		"$FDIR"/assembly_info_organelle_annotation_count.txt \
		"$FDIR"/assembly_info_organelle_annotation_count-all.txt \
		--contigger \
		>/dev/null 2>&1

	echo "USE: assembly graph: "$PWD"/"$FDIR"/30-contigger/graph_final.gfa"
	echoall "column -t "$FDIR"/assembly_info_organelle_annotation_count.txt"
	echoall "column -t "$FDIR"/assembly_info_organelle_annotation_count-all.txt"
	# echo edge_1 >$FDIR/mt.contig.name-1
	# echo edge_2 >>$FDIR/mt.contig.name-1
	# echo edge_3 >>$FDIR/mt.contig.name-1
	echoerr "Example file: $FDIR/mt.contig.name-1"
	echoerr "edge_1"
	echoerr "edge_2"
	echoerr "edge_3"
	echoall "INFO: edit $FDIR/mt.contig.name-1 for mtDNA contig candidates"
	echo "INFO: edit $FDIR/mt.contig.name-<destination flye number> for mtDNA contig candidates"

	ANUMNEXT=$((ANUM + 1))
	echoerr NEXT: $0 select-reads [-i $ANUM] [-j $ANUMNEXT]
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _func_polap_select-reads() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		INUM=0
		JNUM=1
	elif [ $# -eq 1 ]; then
		INUM=0
		JNUM=$1
	elif [ $# -eq 2 ]; then
		INUM=$1
		JNUM=$2
	fi

	_run_polap_select-reads

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_select-reads() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	MR=$_arg_min_read_length
	FDIR=$ODIR/$INUM
	ADIR="$FDIR"/50-annotation
	MTDIR=$ODIR/$JNUM
	MTSEEDSDIR=$MTDIR/seeds

	MTCONTIGNAME=$FDIR/mt.contig.name-$JNUM
	if [ ! -s "$MTCONTIGNAME" ]; then
		echoall "ERROR: no such mt.contig.name file: $MTCONTIGNAME"
		exit $EXIT_ERROR
	fi

	# for contigs
	#	ASSEMBLY_FASTA=o/30-contigger/contigs.fasta
	#	for edges
	ASSEMBLY_FASTA="$FDIR"/30-contigger/graph_final.fasta
	# PAIR_MIN=$MPAIR
	# SINGLE_MIN=$MSINGLE
	#	echo "INFO: mt.contig.name-${STEP4}: contigs only"
	#	echo 'INFO: use contigs: o/30-contigger/contigs.fasta'

	if [ -d "$MTDIR" ]; then
		while true; do
			read -p "Folder [$MTDIR] already exists. Do you want to replace it? [y/n] " yn
			case $yn in
			[Yy]*)
				rm -rf $MTDIR
				echo "INFO: $MTDIR is deleted."
				break
				;;
			[Nn]*)
				echoall "INFO: [$MTDIR] is not replaced."
				echoerr "you might want a new mt.contig.name file for flye2 step."
				exit $EXIT_FAIL
				;;
			*) echo "Please answer yes or no." ;;
			esac
		done
	fi

	echo $CMD >$ODIR/organelle-assembly_${INUM}-${JNUM}

	mkdir -p $MTSEEDSDIR
	ln -s "$PWD"/"$ODIR"/nk.fq.gz -t $MTDIR
	echoall "INFO: extracts contigs from the assembly $ASSEMBLY_FASTA"
	echo "INFO: uses mt.contig.name at $MTCONTIGNAME"
	echoerr "FILE: contigs in $MTCONTIGNAME"
	cat $MTCONTIGNAME >&2
	echoerr "please, wait for a long-read data selection ... $INUM -> $JNUM ... bridge=$MBRIDGE p_mapping=$MPAIR s_mapping=$MSINGLE min_len_read=$MR"
	# ADIR="$ODIR"/50-annotation
	# if [[ ! -d $ADIR ]]; then
	# 	mkdir -p $ADIR
	# fi

	seqkit grep --threads $NT -f $MTCONTIGNAME $ASSEMBLY_FASTA -o $MTDIR/contig.fa >/dev/null 2>&1
	# seqtk subseq $LRNK $ASSEMBLY_FASTA $MTCONTIGNAME >"$MTDIR"/contig.fa
	# if [[ $CIRCULARIZE == "--circularize" ]]; then
	contig_count=$(wc -l <"$MTCONTIGNAME")
	if [[ $CIRCULARIZE == "on" ]]; then
		if [ "$contig_count" -eq 1 ]; then
			seqkit fx2tab --length --name $MTDIR/contig.fa -o $MTDIR/contig.fa.len >/dev/null 2>&1
			A=$(cut -f2 $MTDIR/contig.fa.len)
			B=$(echo "scale=0; $A/2" | bc)
			C=$((B + 1))
			seqkit subseq -r 1:$B $MTDIR/contig.fa -o $MTDIR/c1.fa >/dev/null 2>&1
			seqkit subseq -r $C:$A $MTDIR/contig.fa -o $MTDIR/c2.fa >/dev/null 2>&1
			cat $MTDIR/c?.fa | seqkit replace -p '.+' -r 'edge_{nr}' -o $MTDIR/contig.fa >/dev/null 2>&1
			cp "$MTCONTIGNAME" "$MTCONTIGNAME"-backup
			echo -e "edge_1\nedge_2" >"$MTCONTIGNAME"
			echo "INFO: creates new $MTDIR/contig.fa and $MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit $EXIT_ERROR
			"$WDIR"/run-polap-single.R $MTSEEDSDIR/contig.tab $MTSEEDSDIR $MSINGLE >/dev/null 2>&1
			cat $MTSEEDSDIR/single.names | sort | uniq >$MTSEEDSDIR/1.names
			echo "INFO: creates long read single name in $MTSEEDSDIR/1.names"
		fi
	fi
	echo "DATA: $MTDIR/contig.fa is created."

	CONTIG_LENGTH=$(seqkit stats -Ta $MTDIR/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	if [[ -s "$MTDIR"/contig.paf ]]; then
		echo "DATA: previously created $MTDIR/contig.paf is used without executing minimap2."
	else
		minimap2 -cx map-ont "$MTDIR"/contig.fa "$LRNK" -t "$NT" -o "$MTDIR"/contig.paf >/dev/null 2>&1
		echo "DATA: $LRNK is used to select reads."
		echo "DATA: $MTDIR/contig.paf is created."
	fi

	cut -f1-11 "$MTDIR"/contig.paf | awk -v minlength="$MR" '{if ($2>=minlength) {print}}' >"$MTDIR"/contig.tab
	echo "DATA: minimum length of long reads in the read selection: $MR"
	echo "DATA: $MTDIR/contig.tab is created."

	# MT: MPAIR=3000 MBRIDGE=3000 MSINGLE=3000
	# PT: MPAIR=1000 MBRIDGE=5000 MSINGLE=0
	Rscript --vanilla "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" $MTDIR/contig.tab $MTSEEDSDIR $MPAIR $MBRIDGE $MSINGLE >/dev/null 2>&1
	# "$WDIR"/run-polap-pairs.R "$MTCONTIGNAME" $MTDIR/contig.tab $MTSEEDSDIR $MPAIR $MBRIDGE $MSINGLE >/dev/null 2>&1
	echo "OPTION polap pairs alignment minimum: $MPAIR"
	echo "OPTION polap pairs bridge minimum: $MBRIDGE"
	echo "DATA: pair contig names in $MTSEEDSDIR are created."
	echo "DATA: single contig name in $MTSEEDSDIR is created."

	# cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	cat "$MTSEEDSDIR"/single.names | sort | uniq >"$MTSEEDSDIR"/1.names
	echo "INFO: creates long read names and the single name in $MTSEEDSDIR/1.names"

	# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names $LRNK -o "$MTSEEDSDIR"/1.fq.gz >/dev/null 2>&1
	seqtk subseq $LRNK "$MTSEEDSDIR"/1.names | gzip >"$MTSEEDSDIR"/1.fq.gz
	echo "DATA: organelle reads in $MTSEEDSDIR/1.fq.gz"

	TOTAL_LENGTH=$(seqkit stats -Ta $MTSEEDSDIR/1.fq.gz | csvtk cut -t -f "sum_len" | csvtk del-header)
	EXPECTED_COVERAGE=$((TOTAL_LENGTH / CONTIG_LENGTH))
	echo "INFO: expected coverage: ${EXPECTED_COVERAGE}x"

	if [ "$EXPECTED_COVERAGE" -lt $COV ]; then
		echo "DATA: no data reduction: COV=$COV"
		ln -s 1.fq.gz $MTSEEDSDIR/2.fq.gz
	else
		RATE=$(echo "scale=10; $COV/$EXPECTED_COVERAGE" | bc)
		echoall "SUGGESTION: you might want to increase the minimum read lengths because you have enough long-read data."
		echoall "DATA: data reduction by rate of $RATE"
		seqkit sample -p $RATE $MTSEEDSDIR/1.fq.gz -o $MTSEEDSDIR/2.fq.gz >/dev/null 2>&1
	fi

	C=$(ls -1 "$MTSEEDSDIR/"*".name" 2>/dev/null | wc -l)
	if [ $C != 0 ]; then
		echo "INFO: bridging reads exist: combinations of $C."
		seqkit seq -n -i $MTSEEDSDIR/2.fq.gz >"$MTSEEDSDIR"/single.names.2
		cat "$MTSEEDSDIR/"*".name" "$MTSEEDSDIR"/single.names.2 | sort | uniq >"$MTSEEDSDIR"/1.names.2
		# seqkit grep --threads $NT -f "$MTSEEDSDIR"/1.names.2 $LRNK -o "$MTSEEDSDIR"/2.fq.gz >/dev/null 2>&1
		seqtk subseq $LRNK "$MTSEEDSDIR"/1.names.2 | gzip >"$MTSEEDSDIR"/2.fq.gz
	fi
	echo "DATA: organelle reads in $MTSEEDSDIR/2.fq.gz"

	# put the backup to the original
	if [[ $CIRCULARIZE == "on" ]]; then
		if [[ -s "$MTCONTIGNAME"-backup ]]; then
			mv "$MTCONTIGNAME"-backup "$MTCONTIGNAME"
		else
			echo "DEV: not implemented yet"
			exit EXIT_ERROR
		fi
	fi

	echoerr NEXT: $0 flye2 -j $JNUM

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _func_polap_flye2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		JNUM=1
	else
		JNUM=$1
	fi

	_run_polap_flye2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_flye2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: organelle-genome assembly on $JNUM"

	MTDIR=$ODIR/$JNUM
	MTSEEDSDIR=$MTDIR/seeds

	CONTIG_LENGTH=$(seqkit stats -Ta $MTDIR/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "$CONTIG_LENGTH" >"$MTDIR"/contig_total_length.txt
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: executing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for an organelle-genome assembly on $JNUM ..."
	flye --nano-raw $MTSEEDSDIR/2.fq.gz \
		--out-dir $MTDIR \
		--threads $NT \
		--asm-coverage $COV \
		--genome-size $CONTIG_LENGTH \
		--stop-after contigger \
		>/dev/null 2>&1
	echoall "CHECK: assembly graph "$PWD/$MTDIR"/30-contigger/graph_final.gfa"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"
	echoall NEXT: $0 flye-polishing -j $JNUM

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_flye-polishing() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: polishing organelle-genome assembly on $JNUM"

	MTDIR=$ODIR/$JNUM
	MTSEEDSDIR=$MTDIR/seeds

	CONTIG_LENGTH=$(seqkit stats -Ta $MTDIR/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
	echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"

	echo "INFO: polishing the organelle-genome assembly using flye ... be patient!"
	echoerr "please, wait for polishing the organelle-genome assembly on $JNUM ..."
	flye --nano-raw $MTSEEDSDIR/2.fq.gz \
		--out-dir $MTDIR \
		--threads $NT \
		--asm-coverage $COV \
		--genome-size $CONTIG_LENGTH \
		--resume \
		>/dev/null 2>&1
	echoall "CHECK: the polishing assembly graph $PWD/$MTDIR/assembly_graph.gfa"
	echoerr "DO: extract a draft organelle genome sequence from the polished assembly graph"
	# echo "column -t $ODIR/assembly_info_organelle_annotation_count.txt"
	echoall NEXT: $0 check-coverage

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_ncbi-fetch-mtdna() {
	if [ -z "$_arg_species" ]; then
		echoerr "ERROR: no --specie option is used."
	else
		S="${_arg_species// /-}"
		esearch -db nuccore -query "(mitochondrion[Title] AND complete[Title] AND genome[Title]) AND ${_arg_species}[Organism]" |
			efetch -format gb >"${S}".mt.gb
	fi
}

function _run_polap_ncbi-fetch-nucleotide() {
	if [ -z "$_arg_accession" ]; then
		echoerr "ERROR: no --accession option is used."
	else
		esearch -db nuccore -query "${_arg_accession}[ACCN]" </dev/null |
			efetch -format fasta >${_arg_accession}.fa
	fi
}

function _run_polap_align-two-dna-sequences() {
	blastn -query $_arg_query -subject $_arg_subject >pairwise-alignment.txt
	echoerr see pairwise-alignment.txt
}

function _run_polap_clustal() {
	if [[ -s x.aln ]]; then
		echoall "INFO: clustalw alignemnt is found."
	else
		local MT1=$_arg_query
		shift
		local MT2=$_arg_subject
		shift
		command -v clustalw2 >/dev/null 2>&1 || {
			echo >&2 "clustalw2: not installed"
			exit 1
		}
		cat $MT1 $MT2 >x.fa
		clustalw2 x.fa
	fi
	# TODO: works for only Linux.
	GAP1=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	GAP2=$(sed -n '5~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
	MATCH=$(sed -n '6~4p' x.aln | tr -dc '*' | wc -c)
	TOTAL=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | wc -c)
	GAP=$((GAP1 + GAP2))
	MISMATCH=$((TOTAL - MATCH - GAP))
	echoall "INFO: pairwise alignment:   length: $TOTAL"
	echoall "INFO: pairwise alignment:    match: $MATCH"
	echoall "INFO: pairwise alignment: mismatch: $MISMATCH"
	echoall "INFO: pairwise alignment:     gaps: $GAP"
}

function _run_polap_check-coverage() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	echo "INFO: executing minimap2 and samtools for checking the long reads coverage on the $PA ... be patient!"
	minimap2 -t $NT -ax map-ont $PA $LRNK 2>/dev/null |
		samtools view -u 2>/dev/null |
		samtools sort -o "$ODIR"/1.bam \
			>/dev/null 2>&1
	samtools coverage -A -w 32 "$ODIR"/1.bam 1>&2

	echoerr INFO: conda env create -f $WDIR/environment-fmlrc.yaml
	echoerr INFO: conda activate polap-fmlrc
	echoerr NEXT: $0 prepare-polishing [-a s1.fq] [-b s2.fq]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_prepare-polishing() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if ! run_check2; then
		echoerr "ERROR: change your conda environment to polap-fmlrc."
		echoerr "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		echoerr "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	echo "INFO: excuting ropebwt2 and msbwt on the short reads ... be patient!"
	if [[ $SR1 = *.fastq || $SR1 = *.fq ]]; then
		cat $SR1 $SR2 |
			awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN |
			msbwt convert $ODIR/msbwt \
				>/dev/null 2>&1
	elif [[ $SR1 = *.fq.gz || $SR1 = *.fastq.gz ]]; then
		zcat $SR1 $SR2 |
			awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN |
			msbwt convert $ODIR/msbwt \
				>/dev/null 2>&1
	fi

	echoerr NEXT: $0 polish [-p mt.0.fasta] [-f mt.1.fa]

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_polish() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if ! run_check2; then
		echoerr "ERROR: change your conda environment to polap-fmlrc."
		echoerr "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		echoerr "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	if [[ ! -s "$ODIR/msbwt/comp_msbwt.npy" ]]; then
		echoall "ERROR: no msbwt at $ODIR/msbwt/comp_msbwt.npy"
		echoall "HINT: $0 prepare-polishing [-a s1.fq] [-b s2.fq]"
		exit $EXIT_ERROR
	fi

	echo "INFO: executing fmlrc on the draft sequence $PA ... be patient!"
	if [[ -s $PA ]]; then
		fmlrc -p $NT $ODIR/msbwt/comp_msbwt.npy $PA $FA >/dev/null 2>&1
	else
		echo "ERROR: no unpolished fasta file: $PA"
		exit $EXIT_ERROR
	fi

	echoerr NEXT: $0 reference algiment compare
	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_assemble1() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	_run_polap_reset
	_run_polap_total-length-long
	_run_polap_find-genome-size
	_run_polap_reduce-data
	_run_polap_flye1

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_annotate() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	if [ $# -eq 0 ]; then
		ANUM=0
	else
		ANUM=$1
	fi

	_run_polap_blast-genome $ANUM
	_run_polap_count-gene $ANUM

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_assemble2() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	_run_polap_select-reads
	_run_polap_flye2

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function _run_polap_assemble() {
	if [ "$DEBUG" -eq 1 ]; then set -x; fi

	_run_polap_reset
	_run_polap_total-length-long
	_run_polap_find-genome-size
	_run_polap_reduce-data
	_run_polap_flye1 -g 150000
	_run_polap_blast-genome
	_run_polap_count-gene
	_run_polap_select-reads
	_run_polap_flye2
	_run_polap_check-coverage
	source $HOME/miniconda3/bin/activate polap-fmlrc
	_run_polap_prepare-polishing
	_run_polap_polish
	conda deactivate

	if [ "$DEBUG" -eq 1 ]; then set +x; fi
}

function assemble1() {
	while getopts "l:a:b:o:t:" option; do
		case $option in
		l) LR=$OPTARG ;;
		a) SR1=$OPTARG ;;
		b) SR2=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		t) NT=$OPTARG ;;
		\?) # incorrect option
			echo "Error: Invalid option; 1 try -h option"
			exit 1
			;;
		esac
	done

	if ! run_check1; then
		echo "ERROR: change your conda environment to polap-dev."
		echo "INFO: (base) $ conda env create -f src/environment.yaml"
		echo "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi
	run_output1

	if [[ ! -s $LR ]]; then
		echo "ERROR: no long-read data file found: $LR"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR1 ]]; then
		echo "ERROR: no short-read data file found: $SR1"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR2 ]]; then
		echo "ERROR: no short read-data file found: $SR2"
		exit $EXIT_ERROR
	fi
	LRNK=$ODIR/nk.fq.gz

	run_jellyfish
	run_flye1
	run_annotation $INUM
	run_genecount $INUM
}

function assemble2() {
	MR=3000
	while getopts "i:j:o:t:m:a:b:c:u" option; do
		case $option in
		i) INUM=$OPTARG ;;
		j) JNUM=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		t) NT=$OPTARG ;;
		m) MR=$OPTARG ;;
		a) MPAIR=$OPTARG ;;
		b) MBRIDGE=$OPTARG ;;
		c) COV=$OPTARG ;;
		u) CIRCULARIZE="--circularize" ;;
		\?) # incorrect option
			echo "Error: Invalid option; 2 try -h option"
			exit $EXIT_ERROR
			;;
		esac
	done
	LRNK=$ODIR/nk.fq.gz
	if [[ "$MR" -lt 3000 ]]; then
		echo "ERROR: your minimum read length should be at least 3000 bp"
		exit $EXIT_ERROR
	fi

	# if [[ "$MR" -eq 3000 ]]; then
	# 	LRNK=$ODIR/nk.fq.gz
	# elif [[ "$MR" -gt 3000 ]]; then
	# 	LRNK=$ODIR/nk.fq.gz
	# 	if [ -s "$LR" ]; then
	# 		seqkit seq --quiet -m "$MR" --threads 4 "$LR" -o $LRNK >/dev/null 2>&1
	# 		echo "DATA: long-read minimum $MR reads data nk.fq.gz is created"
	# 	else
	# 		echo "ERROR: no long-read data file while your minimum read length is less than 3000 bp"
	# 		exit $EXIT_ERROR
	# 	fi
	# else
	# 	echo "ERROR: your minimum read length should be at least 3000 bp"
	# 	exit $EXIT_ERROR
	# fi

	if ! run_check1; then
		echo "ERROR: change your conda environment to polap-dev."
		echo "INFO: (base) $ conda env create -f src/environment.yaml"
		echo "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $LRNK ]]; then
		echo "ERROR: no $LRNK long read-data file found: $LRNK"
		exit $EXIT_ERROR
	fi
	run_output2

	run_flye2 $INUM $JNUM
	run_annotation $JNUM
	run_genecount $JNUM
}

function test1() {
	ODIR=otest
	NT=56
	MR=3000
	while getopts "i:o:t:m:c:u" option; do
		case $option in
		i) INUM=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		t) NT=$OPTARG ;;
		m) MR=$OPTARG ;;
		c) COV=$OPTARG ;;
		u) CIRCULARIZE="--circularize" ;;
		\?) # incorrect option
			echo "Error: Invalid option; t try -h option"
			exit
			;;
		esac
	done
	LRNK=$ODIR/nk.fq.gz
	if [[ "$MR" -lt 3000 ]]; then
		echo "ERROR: your minimum read length should be at least 3000 bp"
		exit $EXIT_ERROR
	fi

	if ! run_check1; then
		echo "ERROR: change your conda environment to polap-dev."
		echo "INFO: (base) $ conda env create -f src/environment.yaml"
		echo "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $LRNK ]]; then
		echo "ERROR: no $LRNK long read-data file found: $LRNK"
		exit $EXIT_ERROR
	fi

	run_annotation
	# run_count_genes
	run_flye2 $INUM $JNUM
}

function assemble3() {
	while getopts "a:b:p:f:o:t:" option; do
		case $option in
		a) SR1=$OPTARG ;;
		b) SR2=$OPTARG ;;
		p) PA=$OPTARG ;;
		f) FA=$OPTARG ;;
		o) ODIR=$OPTARG ;;
		t) NT=$OPTARG ;;
		\?) # incorrect option
			echo "Error: Invalid option; 3 try -h option"
			exit
			;;
		esac
	done

	if ! run_check2; then
		echo "ERROR: change your conda environment to polap-fmlrc."
		echo "INFO: (base) $ conda env create -f src/environment-fmlrc.yaml"
		echo "INFO: (base) $ conda activate polap-fmlrc"
		exit $EXIT_ERROR
	fi

	if [[ ! -s $SR1 ]]; then
		echo "ERROR: no short read-data file found: $SR1"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $SR2 ]]; then
		echo "ERROR: no short read-data file found: $SR2"
		exit $EXIT_ERROR
	fi

	LRNK=$ODIR/nk.fq.gz
	run_polish1
	run_polish2
}

function coverage() {
	while getopts "o:p:t:" option; do
		case $option in
		o) ODIR=$OPTARG ;;
		p) PA=$OPTARG ;;
		t) NT=$OPTARG ;;
		\?) # incorrect option
			echo "Error: Invalid option; c try -h option"
			exit
			;;
		esac
	done
	LRNK=$ODIR/nk.fq.gz

	if ! run_check1; then
		echo "ERROR: change your conda environment to polap-dev."
		echo "INFO: (base) $ conda env create -f src/environment.yaml"
		echo "INFO: (base) $ conda activate polap-dev"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $PA ]]; then
		echo "ERROR: no draft sequence: $PA"
		exit $EXIT_ERROR
	fi
	if [[ ! -s $LRNK ]]; then
		echo "ERROR: no $LRNK long read-data file found: $LRNK"
		exit $EXIT_ERROR
	fi

	run_samtools
}

function count() {
	echoall count-bgn
	echoall gount-end

	s=${_arg_menu[1]}
	y=$(seqkit stats -Ta $s | csvtk cut -t -f "sum_len" | csvtk del-header)
	echoall $y
	# >"$ODIR"/long_total_length.txt
}

function genomesize() {

	if [[ ! -s "$ODIR"/jellyfish_out.histo ]]; then
		if [[ $(file -b --mime-type "$SR1") == "application/gzip" ]]; then
			gunzip -c "$SR1" >"${SR1%.gz}"
			SR1="${SR1%.gz}"
		fi
		if [[ $(file -b --mime-type "$SR2") == "application/gzip" ]]; then
			gunzip -c "$SR2" >"${SR2%.gz}"
			SR2="${SR2%.gz}"
		fi
		jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/jellyfish_out --min-qual-char=? "$SR1" "$SR2"
		jellyfish histo -o "$ODIR"/jellyfish_out.histo "$ODIR"/jellyfish_out
	fi
	"$WDIR"/run-polap-jellyfish.R "$ODIR"/jellyfish_out.histo "$LONG_TOTAL_LENGTH" "$ODIR"/long_coverage.txt "$ODIR"/short_expected_genome_size.txt
	EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
	EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
	EXPECTED_COVERAGE=$(cat "$ODIR"/long_coverage.txt)
	EXPECTED_COVERAGE=${EXPECTED_COVERAGE%.*}

}

# for the magic logit function
function logit() {
	while read; do
		# echo "$(date) $REPLY" >> ${LOG_FILE}
		# -1 means "current time"
		# printf "[%(%Y-%m-%d %T)T] %s\n" -1 "$REPLY" >> ${LOG_FILE}
		printf "[%s] %s\n" "$(date +"%Y-%m-%d %T")" "$REPLY" >>${LOG_FILE}
	done
}

function echoerr() { echo "$@" 1>&2; }

function echoall() {
	echo "$@" 1>&2
	echo "$@"
}

function yell() { echo "$0: $*" >&2; }
function die() {
	yell "$*"
	exit 111
}
function try() { "$@" || die "cannot $*"; }

################################################################################
# All of the variables at our disposal
#

# include and execute other BASH and R scripts
WDIR="$(dirname "$0")"
WDIR="${BASH_SOURCE%/*}"
if [[ ! -d "$WDIR" ]]; then
	WDIR="$PWD"
fi
WDIR=$script_dir

# variables for input data file names for flexible data processing.
LR=$_arg_long_reads       # long-read data file
SR1=$_arg_short_read1     # paired short-read data file 1
SR2=$_arg_short_read2     # paired short-read data file 2
PA=$_arg_unpolished_fasta # assembled draft sequence extracted from bandage
FA=$_arg_final_assembly   # polished sequence

# variables for output
ODIR=$_arg_outdir
INUM=$_arg_inum
JNUM=$_arg_jnum
FDIR=$ODIR/0 # flye 1st output
# GDIR=$ODIR/1 # flye 2nd output

# tuning variables for optimal performance
LRNK=$ODIR/nk.fq.gz
MR=$_arg_min_read_length
MPAIR=$_arg_pair_min     # 3000 for MT, 1000 for PT
MBRIDGE=$_arg_bridge_min # used to be 3000,
MSINGLE=$_arg_single_min # not used deprecated
COV=$_arg_coverage
# NT=$(cat /proc/cpuinfo | grep -c processor)
NT=$_arg_threads
if test -z "$DEBUG"; then
	DEBUG=0
fi
CIRCULARIZE=$_arg_circularize # "--circularize"
SPECIES=$_arg_species

################################################################
# Variables
SRA=$_arg_sra
SRALONG=""
SRASHORT=""
RESUME=$_arg_resume
ALL_ANNOTATE="--selective-annotate"
FLYE_CONTIGGER="--contigger"
USE_EDGES="--no-use-edges"
NO_REDUCTION_READS=$_arg_reduction_reads
NO_COVERAGE_CHECK=$_arg_coverage_check
STEP0=0
STEP1=0
STEP2=0
STEP3=0
STEP4=0
STEP5=0
STEP6=0
STEP7=0
MULTISTEP=0

# v1: 500/1000
# v2: 3000
# PAIR_MIN=500    # 3k or 5k
# SINGLE_MIN=3000 # 3k or 5k
SINGLE1=0
SINGLE2=0
BACKUP=species

# Constants
EXIT_SUCCESS=0
EXIT_FAIL=1
EXIT_ERROR=2
RETURN_SUCCESS=0
RETURN_FAIL=1

SECONDS=0

################################################################
# MAIN
#
if [ $# -eq 0 ]; then
	print_help
	exit $EXIT_SUCCESS
fi

# all message to a log file
# https://stackoverflow.com/questions/49851882/how-to-log-echo-statement-with-timestamp-in-shell-script
LOG_FILE="./polap.log"
exec 3>&1 1>> >(logit)
# exec 3>&1 1>> >(logit) 2>&1

CMD="$0 $*"
echo "CMD: $CMD"

# subcommand function call
if declare -f "_run_polap_${_arg_menu[0]}" >/dev/null 2>&1; then
	# invoke that function, passing arguments through
	if [ ${_arg_menu[0]} != "assemble" ]; then
		_run_polap_"$@" # same as "$1" "$2" "$3" ... for full argument list
	else
		_run_polap_assemble
	fi
else
	echoerr "Menu: assemble1, annotate, assemble2, flye-polishing"
	echoerr "      reset, total-length-long, find-genome-size, reduce-data,"
	echoerr "      flye1, blast-genome, count-gene, select-reads, flye2,"
	echoerr "      flye-polishing, check-coverage,"
	echoerr "      prepare-polishing, polish,"
	echoerr "      ncbi-fetch-nucleotide, align-two-dna-sequences, clustal"
	echoerr "ERROR: no such menu of $1"
fi

ELAPSED="Time: $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"

# ^^^  TERMINATE YOUR CODE BEFORE THE BOTTOM ARGBASH MARKER  ^^^

# ] <-- needed because of Argbash
