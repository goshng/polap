#!/bin/bash
################################################################################
# This file is part of polap.
#
# polap is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# polap is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# polap. If not, see <https://www.gnu.org/licenses/>.
################################################################################

################################################################################
# Polap uses argbash to process the command-line options.
# We initialized polap.sh script with the followings.
# Now, we do not use them but edit the script polap-parsing.sh when we need
# to change options. It is instructive to learn how one can use argbash to
# process the command-line options in order to understand the way how polap
# script handles them.
################################################################################

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([long-reads],[l],[long-reads data file in fastq format],[l.fq])
# ARG_OPTIONAL_SINGLE([outdir],[o],[output folder name],[o])
# ARG_OPTIONAL_SINGLE([short-read1],[a],[short-read fastq file 1],[s1.fq])
# ARG_OPTIONAL_SINGLE([short-read2],[b],[short-read fastq file 2],[s2.fq])
# ARG_OPTIONAL_SINGLE([sra],[],[SRA data])
# ARG_OPTIONAL_SINGLE([unpolished-fasta],[p],[polishing sequence in fasta format],[mt.0.fasta])
# ARG_OPTIONAL_SINGLE([final-assembly],[f],[final assembly in fasta format],[mt.1.fa])
# ARG_OPTIONAL_SINGLE([min-read-length],[m],[minimum length of long reads],[3000])
# ARG_OPTIONAL_SINGLE([threads],[t],[number of CPUs],[$(cat /proc/cpuinfo | grep -c processor)])
# ARG_OPTIONAL_SINGLE([log],[],[log file],[polap.log])
# ARG_OPTIONAL_SINGLE([coverage],[c],[step4: coverage for the 2nd assembly],[30])
# ARG_OPTIONAL_SINGLE([pair-min],[r],[minimum mapped bases or PAF 11th column],[3000])
# ARG_OPTIONAL_SINGLE([bridge-min],[x],[minimum bridging read length or PAF 7th column],[3000])
# ARG_OPTIONAL_SINGLE([single-min],[w],[minimum mapped bases or PAF 11th column],[3000])
# ARG_OPTIONAL_SINGLE([inum],[i],[previous output number of organelle-genome assembly],[0])
# ARG_OPTIONAL_SINGLE([jnum],[j],[current output number of organelle-genome assembly],[1])
# ARG_OPTIONAL_SINGLE([genomesize],[g],[expected genome size])
# ARG_OPTIONAL_SINGLE([bioproject],[],[NCBI BioProject ID])
# ARG_OPTIONAL_SINGLE([species],[],[Species scientific name])
# ARG_OPTIONAL_SINGLE([accession],[],[NCBI accession ID])
# ARG_OPTIONAL_SINGLE([query],[],[query sequence for blastn])
# ARG_OPTIONAL_SINGLE([subject],[],[subject sequence for blastn])
# ARG_OPTIONAL_REPEATED([minimum],[M],[Pair, Bridge, and Single minimum],[])
# ARG_OPTIONAL_BOOLEAN([reduction-reads],[],[redo: no reduction of long-read data],[on])
# ARG_OPTIONAL_BOOLEAN([contigger],[],[step1: use flye's 40-polishing result])
# ARG_OPTIONAL_BOOLEAN([all-annotate],[],[step2: annotate all contigs])
# ARG_OPTIONAL_BOOLEAN([bridge-same-strand],[],[step4: use flye's edges not contigs])
# ARG_OPTIONAL_BOOLEAN([coverage-check],[],[step4: no coverage check for step 4])
# ARG_OPTIONAL_BOOLEAN([resume],[],[step1,step4: flye option resume])
# ARG_OPTIONAL_BOOLEAN([circularize],[u],[step4: circularize a contig])
# ARG_POSITIONAL_MULTI([menu],[Polap menu],[3],[assemble],[infile],[outfile])
# ARG_VERSION([echo $0 v0.2.6])
# ARG_VERBOSE([])
# ARG_DEFAULTS_POS([])
# ARG_HELP(['P'lant 'o'rganelle DNA 'l'ong-read 'a'ssembly 'p'ipeline.])
# DEFINE_SCRIPT_DIR([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

begins_with_short_option() {
	local first_option all_short_options='loabpfmtcrxwijgMuvhs'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_brg_menu=("run" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0")
# THE DEFAULTS INITIALIZATION - OPTIONALS

# Tesing groups of datasets
declare -a Sall

Smain=(
	'Eucalyptus_pauciflora'
)

# Data28
Stest=(
	Cochlearia_groenlandica
	Euphorbia_peplus
)
# Pachyrhizus_erosus
# Anthoceros_angustus
# Test_species
# Taxon_genus

Ssome=(
	Aegilops_umbellulata
	Anthoceros_agrestis
	Anthoceros_angustus
	Arabidopsis_thaliana
	Arctium_lappa
	Aristolochia_californica
	Azolla_caroliniana
	Biancaea_sappan
	Brassica_napus
	Brassica_rapa
	Breynia_androgyna
	Bromus_tectorum
	Camelina_sativa
	Camellia_gigantocarpa
	Camellia_meiocarpa
	Campeiostachys_kamoji
	Canavalia_ensiformis
	Canavalia_gladiata
	Carduus_pycnocephalus
	Carex_pseudochinensis
	Chenopodium_quinoa
	Chionographis_japonica
	Cichorium_endivia
	Cichorium_intybus
	Cinchona_pubescens
	Citrus_sinensis
	Cochlearia_groenlandica
	Codonopsis_lanceolata
	Cucumis_sativus_var_hardwickii
	Cynara_cardunculus
	Cyperus_esculentus
	Delonix_regia
	Dillenia_suffruticosa
	Dioscorea_japonica
	Dunaliella_tertiolecta
	Erythranthe_laciniata
	Eschscholzia_californica
	Eucalyptus_pauciflora
	Euonymus_alatus
	Euphorbia_peplus
	Fagopyrum_esculentum
	Fagopyrum_tataricum
	Fragaria_chiloensis
	Glebionis_coronaria
	Glebionis_segetum
	Gleditsia_sinensis
	Glycyrrhiza_uralensis
	Gossypium_herbaceum
	Gossypium_raimondii
	Haloxylon_ammodendron
	Helianthus_tuberosus
	Herpetospermum_pedunculosum
	Heteromeles_arbutifolia
	Hevea_brasiliensis
	Hordeum_vulgare
	Ipomoea_aquatica
	Jasminum_sambac
	Juglans_californica
	Juncus_effusus
	Juncus_inflexus
	Juncus_roemerianus
	Juncus_validus
	Lablab_purpureus
	Lactuca_sativa
	Lathyrus_sativus
	Layia_glandulosa
	Leiosporoceros_dussii
	Leucaena_leucocephala
	Linanthus_parryae
	Lithocarpus_litseifolius
	Lolium_multiflorum
	Lolium_perenne
	Lupinus_luteus
	Macadamia_jansenii
	Macadamia_tetraphylla
	Malus_domestica
	Malus_niedzwetzkyana
	Marah_fabacea
	Mimosa_bimucronata
	Morus_mongolica
	Musa_acuminata_subsp_malaccensis
	Nemophila_menziesii
	Neostapfia_colusana
	Noccaea_caerulescens
	Notothylas_orbicularis
	Ocimum_basilicum
	Ophrys_lutea
	Oryza_coarctata
	Oryza_longistaminata
	Oryza_rufipogon
	Pachyrhizus_erosus
	Penstemon_fruticosus
	Phaeomegaceros_chiloensis
	Phaseolus_coccineus
	Phyllospadix_torreyi
	Pisum_sativum
	Platanus_racemosa
	Populus_pruinosa
	Populus_trichocarpa
	Populus_x_sibirica
	Prinsepia_uniflora
	Prunus_campanulata
	Prunus_mandshurica
	Punica_granatum
	Quercus_berberidifolia
	Quercus_engelmannii
	Quercus_gilva
	Quercus_glauca
	Quercus_tomentella
	Quercus_wislizeni
	Salix_arbutifolia
	Salix_dunnii
	Salix_purpurea
	Selenicereus_monacanthus
	Sequoia_sempervirens
	Sesbania_cannabina
	Smallanthus_sonchifolius
	Solanum_cheesmaniae
	Solanum_lycopersicum
	Solanum_tuberosum
	Spirodela_polyrhiza
	Stephania_tetrandra
	Taraxacum_mongolicum
	Thalia_dealbata
	Thinopyrum_intermedium
	Trifolium_pratense
	Trifolium_repens
	Triticum_aestivum
	Triticum_timopheevii
	Tuctoria_greenei
	Umbellularia_californica
	Urochloa_decumbens
	Vaccinium_bracteatum
	Vaccinium_vitis_idaea
	Vigna_radiata
	Vitis_vinifera
)

_bolap_command_string=bolap

if [[ -s "${HOME}/.bolaprc" ]]; then
	_bolap_type=$(<"${HOME}/.bolaprc")
	if [[ -z "${_bolap_type}" ]]; then
		_bolap_type="read"
	fi
else
	_bolap_type="read"
	echo "${_bolap_type}" >"${HOME}/.bolaprc"
fi

_brg_verbose=1
_brg_verbose_str=""
opt_c_arg="off"
opt_t_arg="v5"
if [[ "${_bolap_type}" == "read" ]]; then
	opt_t_arg="v6"
fi
opt_m_arg="off"
opt_y_flag=false
opt_f_flag=false
opt_e_arg=""
_brg_help="off"
_brg_preset=""
_brg_config_dir="$HOME/.polap/profiles"
_brg_config_path=""
_brg_default_target_dir="${opt_m_arg}"

print_help() {

	help_message=$(
		cat <<HEREDOC
BOLAP - Benchmarking of organelle DNA long-read assembly pipeline.
Version: ${_polap_version}, Analysis: ${_bolap_type}

Usage: ${_bolap_command_string} [-hyvf] [-c CSV] [--version] [command] [--help|-h]

bolap is a tool for data analysis of plant plastid genome assembly
by annotating long reads with organelle genome sequences and selecting those
originating from organelle genomes.

commands:
  use                  Use one of benchmark analysis datasets: read, cflye, aflye
  install/setup/update Install, setup, update tools using conda environments.
  uninstall            Uninstall tools.
  list (search)        List or search for tools.
  run                  Run tools
  download             Download data.
  help                 Print help message for commands and others.
  config               Config view, add, etc.
  benchmark            Benchmark GetOrganelle, ptGAUL, TIPPo, and Oatk.
  clean (delete, rm)   Remove unnecessary folders.

options:
  -h, --help           Show this help message and exit.
  -y                   Enable YES to any question.
  -v                   Enable verbose mode.
  -f                   Enable profiling.
  -c <arg>             Set value for -c option (default: ${opt_c_arg})
  -t <arg>             Set value for -t option (default: ${opt_t_arg})
  -m <arg>             Set value for -m option figure folder (default: ${_brg_default_target_dir})
  --version            Show the polap-data-${_bolap_type} version number and exit.
HEREDOC
	)

	# get                  Get results.
	# archive              Archive results.
	# man                  Generate reports.
	# build (assemble)     Build plastid or mitochondrial genomes.
	# print-help-all       List all help messages.

	# Display help message
	echo "${help_message}"
}

parse_preset_commandline() {
	# source "${_POLAPLIB_DIR}/polap-cmd-version.sh" # '.' means 'source'
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		--preset)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset="$2"
			shift
			;;
		--config-dir)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_dir="$2"
			shift
			;;
		--config-path)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_path="$2"
			shift
			;;
		*) ;;
		esac
		shift
	done
}

parse_commandline() {
	# source "${_POLAPLIB_DIR}/polap-cmd-version.sh" # '.' means 'source'
	_positionals_count=0
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		-c)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_c_arg="$2"
			csv_file="$2"
			shift
			;;
		-t)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_t_arg="$2"
			shift
			;;
		-m)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_m_arg="$2"
			_brg_default_target_dir="${opt_m_arg}"
			shift
			;;
		-y)
			opt_y_flag=true
			;;
		-f)
			opt_f_flag=true
			;;
		--preset)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset="$2"
			shift
			;;
		--config-dir)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_dir="$2"
			shift
			;;
		--config-path)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_path="$2"
			shift
			;;
		--version)
			_polap_lib_version
			# print_version
			# print_version_git_message
			exit
			;;
		-q | --quiet)
			_brg_verbose=0
			;;
		-v | --verbose)
			_brg_verbose=$((_brg_verbose + 1))
			;;
		--help)
			_brg_help="on"
			;;
		-h)
			print_help
			exit
			;;
		*)
			_last_positional="$1"
			_positionals+=("$_last_positional")
			_positionals_count=$((_positionals_count + 1))
			;;
		esac
		shift
	done
}

handle_passed_args_count() {
	test "${_positionals_count}" -le 12 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 5, but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
	local _positional_name _shift_for=$1
	_positional_names="_brg_menu[0] _brg_menu[1] _brg_menu[2] _brg_menu[3] _brg_menu[4] _brg_menu[5] _brg_menu[6] _brg_menu[7] _brg_menu[8] _brg_menu[9] _brg_menu[10] _brg_menu[11]"

	shift "$_shift_for"
	for _positional_name in ${_positional_names}; do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_preset_commandline "$@"

if [[ -z "${_brg_config_path}" ]]; then
	_brg_config_path="${_brg_config_dir}/${_brg_preset}.yaml"
fi

if [[ -n "${_brg_config_path}" && ! -f "${_brg_config_path}" ]]; then
	echo "[info] new profile (${_brg_preset}): ${_brg_config_path}" >&2
	touch "${_brg_config_path}"
	# echo "[error] no such profile (${_brg_preset}): ${_brg_config_path}" >&2
	# exit 127
fi

LOAD_PY="${_POLAPLIB_DIR}/polap-py-config-load.py"
[[ -f "$LOAD_PY" ]] || {
	echo "[error] not found: $LOAD_PY" >&2
	exit 127
}
if [[ -n "${_brg_config_path}" && -s "${_brg_config_path}" ]]; then
	ENV_LINES=$(python3 "$LOAD_PY" --path "${_brg_config_path}" --format env --prefix "PCFG")
	eval "$ENV_LINES"
	source "${_POLAPLIB_DIR}/polap-bash-apply-pcfg.sh"
	polap_apply_pcfg
fi
# echo "[config] preset=${PCFG_PRESET:-}"
# echo "         name=${PCFG_NAME:-}"

_polap_cmd="${_polap_script_bin_dir}/polap.sh"
if [[ "${_POLAP_RELEASE}" == "1" ]]; then
	_polap_cmd="${_polap_script_bin_dir}/polap"
else
	_polap_cmd="${_polap_script_bin_dir}/polap.sh"
fi

_polap2_cmd="${_polap_script_bin_dir}/polap2.sh"
if [[ "${_POLAP_RELEASE}" == "1" ]]; then
	_polap2_cmd="${_polap_script_bin_dir}/polap2"
else
	_polap2_cmd="${_polap_script_bin_dir}/polap2.sh"
fi

_brg_adir="${opt_t_arg:-t5}"

_brg_verbose=1
parse_commandline "$@"

handle_passed_args_count
set +u
assign_positional_args 1 "${_positionals[@]}"
set -u

verbose_or_quiet_flags() {
	((_brg_verbose > 0)) && for ((i = 1; i < _brg_verbose; i++)); do echo -n "-v "; done || echo -n "--quiet"
}

_brg_verbose_str=$(verbose_or_quiet_flags)

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}

### END OF CODE GENERATED BY Argbash (sortof) ### ])
