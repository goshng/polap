################################################################################
# This file is part of polap.
#
# polap is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# polap is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# polap. If not, see <https://www.gnu.org/licenses/>.
################################################################################

################################################################################
# Polap uses argbash to process the command-line options.
# We initialized polap.sh script with the followings.
# Now, we do not use them but edit the script polap-parsing.sh when we need
# to change options. It is instructive to learn how one can use argbash to
# process the command-line options in order to understand the way how polap
# script handles them.
################################################################################

# Created by argbash-init v2.10.0
# ARG_OPTIONAL_SINGLE([long-reads],[l],[long-reads data file in fastq format],[l.fq])
# ARG_OPTIONAL_SINGLE([outdir],[o],[output folder name],[o])
# ARG_OPTIONAL_SINGLE([short-read1],[a],[short-read fastq file 1],[s1.fq])
# ARG_OPTIONAL_SINGLE([short-read2],[b],[short-read fastq file 2],[s2.fq])
# ARG_OPTIONAL_SINGLE([sra],[],[SRA data])
# ARG_OPTIONAL_SINGLE([unpolished-fasta],[p],[polishing sequence in fasta format],[mt.0.fasta])
# ARG_OPTIONAL_SINGLE([final-assembly],[f],[final assembly in fasta format],[mt.1.fa])
# ARG_OPTIONAL_SINGLE([min-read-length],[m],[minimum length of long reads],[3000])
# ARG_OPTIONAL_SINGLE([threads],[t],[number of CPUs],[$(cat /proc/cpuinfo | grep -c processor)])
# ARG_OPTIONAL_SINGLE([log],[],[log file],[polap.log])
# ARG_OPTIONAL_SINGLE([coverage],[c],[step4: coverage for the 2nd assembly],[30])
# ARG_OPTIONAL_SINGLE([pair-min],[r],[minimum mapped bases or PAF 11th column],[3000])
# ARG_OPTIONAL_SINGLE([bridge-min],[x],[minimum bridging read length or PAF 7th column],[3000])
# ARG_OPTIONAL_SINGLE([single-min],[w],[minimum mapped bases or PAF 11th column],[3000])
# ARG_OPTIONAL_SINGLE([inum],[i],[previous output number of organelle-genome assembly],[0])
# ARG_OPTIONAL_SINGLE([jnum],[j],[current output number of organelle-genome assembly],[1])
# ARG_OPTIONAL_SINGLE([genomesize],[g],[expected genome size])
# ARG_OPTIONAL_SINGLE([bioproject],[],[NCBI BioProject ID])
# ARG_OPTIONAL_SINGLE([species],[],[Species scientific name])
# ARG_OPTIONAL_SINGLE([accession],[],[NCBI accession ID])
# ARG_OPTIONAL_SINGLE([query],[],[query sequence for blastn])
# ARG_OPTIONAL_SINGLE([subject],[],[subject sequence for blastn])
# ARG_OPTIONAL_REPEATED([minimum],[M],[Pair, Bridge, and Single minimum],[])
# ARG_OPTIONAL_BOOLEAN([reduction-reads],[],[redo: no reduction of long-read data],[on])
# ARG_OPTIONAL_BOOLEAN([contigger],[],[step1: use flye's 40-polishing result])
# ARG_OPTIONAL_BOOLEAN([all-annotate],[],[step2: annotate all contigs])
# ARG_OPTIONAL_BOOLEAN([bridge-same-strand],[],[step4: use flye's edges not contigs])
# ARG_OPTIONAL_BOOLEAN([coverage-check],[],[step4: no coverage check for step 4])
# ARG_OPTIONAL_BOOLEAN([resume],[],[step1,step4: flye option resume])
# ARG_OPTIONAL_BOOLEAN([circularize],[u],[step4: circularize a contig])
# ARG_POSITIONAL_MULTI([menu],[Polap menu],[3],[assemble],[infile],[outfile])
# ARG_VERSION([echo $0 v0.2.6])
# ARG_VERBOSE([])
# ARG_DEFAULTS_POS([])
# ARG_HELP(['P'lant 'o'rganelle DNA 'l'ong-read 'a'ssembly 'p'ipeline.])
# DEFINE_SCRIPT_DIR([])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.10.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info

die() {
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}

begins_with_short_option() {
	local first_option all_short_options='loabpfmtcrxwijgMuvhs'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_brg_menu=("run" "0" "0" "0" "0" "0" "0" "0" "0" "0" "0")
# THE DEFAULTS INITIALIZATION - OPTIONALS

# Tesing groups of datasets
declare -a Sall

Smain=(
	'Eucalyptus_pauciflora'
)

# Data28
Stest=(
	Cochlearia_groenlandica
	Euphorbia_peplus
)
# Pachyrhizus_erosus
# Anthoceros_angustus
# Test_species
# Taxon_genus

Ssome=(
	Aegilops_umbellulata
	Anthoceros_agrestis
	Anthoceros_angustus
	Arabidopsis_thaliana
	Arctium_lappa
	Aristolochia_californica
	Azolla_caroliniana
	Biancaea_sappan
	Brassica_napus
	Brassica_rapa
	Breynia_androgyna
	Bromus_tectorum
	Camelina_sativa
	Camellia_gigantocarpa
	Camellia_meiocarpa
	Campeiostachys_kamoji
	Canavalia_ensiformis
	Canavalia_gladiata
	Carduus_pycnocephalus
	Carex_pseudochinensis
	Chenopodium_quinoa
	Chionographis_japonica
	Cichorium_endivia
	Cichorium_intybus
	Cinchona_pubescens
	Citrus_sinensis
	Cochlearia_groenlandica
	Codonopsis_lanceolata
	Cucumis_sativus_var_hardwickii
	Cynara_cardunculus
	Cyperus_esculentus
	Delonix_regia
	Dillenia_suffruticosa
	Dioscorea_japonica
	Dunaliella_tertiolecta
	Erythranthe_laciniata
	Eschscholzia_californica
	Eucalyptus_pauciflora
	Euonymus_alatus
	Euphorbia_peplus
	Fagopyrum_esculentum
	Fagopyrum_tataricum
	Fragaria_chiloensis
	Glebionis_coronaria
	Glebionis_segetum
	Gleditsia_sinensis
	Glycyrrhiza_uralensis
	Gossypium_herbaceum
	Gossypium_raimondii
	Haloxylon_ammodendron
	Helianthus_tuberosus
	Herpetospermum_pedunculosum
	Heteromeles_arbutifolia
	Hevea_brasiliensis
	Hordeum_vulgare
	Ipomoea_aquatica
	Jasminum_sambac
	Juglans_californica
	Juncus_effusus
	Juncus_inflexus
	Juncus_roemerianus
	Juncus_validus
	Lablab_purpureus
	Lactuca_sativa
	Lathyrus_sativus
	Layia_glandulosa
	Leiosporoceros_dussii
	Leucaena_leucocephala
	Linanthus_parryae
	Lithocarpus_litseifolius
	Lolium_multiflorum
	Lolium_perenne
	Lupinus_luteus
	Macadamia_jansenii
	Macadamia_tetraphylla
	Malus_domestica
	Malus_niedzwetzkyana
	Marah_fabacea
	Mimosa_bimucronata
	Morus_mongolica
	Musa_acuminata_subsp_malaccensis
	Nemophila_menziesii
	Neostapfia_colusana
	Noccaea_caerulescens
	Notothylas_orbicularis
	Ocimum_basilicum
	Ophrys_lutea
	Oryza_coarctata
	Oryza_longistaminata
	Oryza_rufipogon
	Pachyrhizus_erosus
	Penstemon_fruticosus
	Phaeomegaceros_chiloensis
	Phaseolus_coccineus
	Phyllospadix_torreyi
	Pisum_sativum
	Platanus_racemosa
	Populus_pruinosa
	Populus_trichocarpa
	Populus_x_sibirica
	Prinsepia_uniflora
	Prunus_campanulata
	Prunus_mandshurica
	Punica_granatum
	Quercus_berberidifolia
	Quercus_engelmannii
	Quercus_gilva
	Quercus_glauca
	Quercus_tomentella
	Quercus_wislizeni
	Salix_arbutifolia
	Salix_dunnii
	Salix_purpurea
	Selenicereus_monacanthus
	Sequoia_sempervirens
	Sesbania_cannabina
	Smallanthus_sonchifolius
	Solanum_cheesmaniae
	Solanum_lycopersicum
	Solanum_tuberosum
	Spirodela_polyrhiza
	Stephania_tetrandra
	Taraxacum_mongolicum
	Thalia_dealbata
	Thinopyrum_intermedium
	Trifolium_pratense
	Trifolium_repens
	Triticum_aestivum
	Triticum_timopheevii
	Tuctoria_greenei
	Umbellularia_californica
	Urochloa_decumbens
	Vaccinium_bracteatum
	Vaccinium_vitis_idaea
	Vigna_radiata
	Vitis_vinifera
)

_brg_dry_run=false
_brg_redo=false
_brg_cleanup=false
_bolap_command_string=bolap

if [[ -s "${HOME}/.bolaprc" ]]; then
	_bolap_type=$(<"${HOME}/.bolaprc")
	if [[ -z "${_bolap_type}" ]]; then
		_bolap_type="read"
	fi
else
	_bolap_type="read"
	echo "${_bolap_type}" >"${HOME}/.bolaprc"
fi

_brg_outdir=""
_brg_sindex=0
_brg_verbose=1
_brg_verbose_str=""
_brg_dataset="${_POLAPLIB_DIR}/polap-dataset-${_bolap_type}.json"
opt_c_arg="off"
opt_t_arg="v5"
if [[ "${_bolap_type}" == "read" ]]; then
	opt_t_arg="v6"
fi
opt_m_arg="off"
opt_y_flag=false
opt_f_flag=false
opt_e_arg=""
_brg_help="off"
_brg_preset=""
_brg_config_dir="$HOME/.polap/profiles"
_brg_config_path=""
_brg_default_target_dir="${opt_m_arg}"
declare -a _blg_unknown_opts=()
declare -a _brg_outdir_list=()

print_help() {

	help_message=$(
		cat <<HEREDOC
BOLAP - Benchmarking of organelle DNA long-read assembly pipeline.
Version: ${_polap_version}
Type: ${_bolap_type}

Usage: ${_bolap_command_string} [command] [options] -s species_name

bolap is a tool for data analysis of plant plastid genome assembly
by annotating long reads with organelle genome sequences and selecting those
originating from organelle genomes.

Required arguments:
  -s STR               Set species folder (REQUIRED).

commands:
  benchmark (default)  Benchmark GetOrganelle, ptGAUL, TIPPo, and Oatk.
  install/setup/update Install, setup, update tools using conda environments.
  run                  Run tools
  download             Download data.
  uninstall            Uninstall tools.
  use                  Use one of benchmark analysis datasets: read, cflye, aflye
  conda                Manage conda environments.
  list                 List for tools.
  help                 Print help message for commands and others.
  tutorial             Print tutorial message for bolap usage. 
  config               Config view, add, etc.
  clean                Remove unnecessary folders.

options:
  -i INT               Set species index (default: ${_brg_sindex})
  -c FILE              Set value for -c option (default: ${opt_c_arg})
  -t STR               Set value for -t option (default: ${opt_t_arg})
  -f                   Enable profiling.
  -y                   Yes for all questions.
  -v                   Enable verbose mode.
  --remote STR         Set the remote cental server (default: none).
  --version            Show the polap-data-${_bolap_type} version number and exit.
  -h, --help           Show this help message and exit.
HEREDOC
	)

	echo "${help_message}"
}

# --preset, --config-dir, --config-path
# preset defines a configuration profile name, which helps to save
# writing long command-lines. Two ways to specify configuration profile:
# 1) --preset PROFILE_NAME
#    This will look for a configuration file at ~/.polap/profiles/PROFILE_NAME.yaml
# 2) --config-path /path/to/configuration.yaml
#    This will use the specified configuration file directly.
# If both are specified, --config-path takes precedence.
parse_preset_commandline() {
	# source "${_POLAPLIB_DIR}/polap-cmd-version.sh" # '.' means 'source'
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		--preset)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset="$2"
			shift
			;;
		--preset-dir)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset_dir="$2"
			shift
			;;
		--preset-path)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset_path="$2"
			shift
			;;
		*) ;;
		esac
		shift
	done
}

parse_commandline() {
	# source "${_POLAPLIB_DIR}/polap-cmd-version.sh" # '.' means 'source'
	_positionals_count=0
	while test $# -gt 0; do
		_key="$1"
		case "$_key" in
		-s)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_outdir="${2%/}"
			_brg_outdir_list+=("$_brg_outdir") # append to array
			shift
			;;
		-i)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_sindex="$2"
			shift
			;;
		-j)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_dataset="$2"
			shift
			;;
		-c)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_c_arg="$2"
			csv_file="$2"
			shift
			;;
		-t)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_t_arg="$2"
			shift
			;;
		-m)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			opt_m_arg="$2"
			_brg_default_target_dir="${opt_m_arg}"
			shift
			;;
		--dry-run)
			_brg_dry_run=true
			;;
		--redo)
			_brg_redo=true
			;;
		--cleanup)
			_brg_cleanup=true
			;;
		-y)
			opt_y_flag=true
			;;
		-f)
			opt_f_flag=true
			;;
		--preset)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_preset="$2"
			shift
			;;
		--config-dir)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_dir="$2"
			shift
			;;
		--config-path)
			test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
			_brg_config_path="$2"
			shift
			;;
		--version)
			_polap_lib_version
			# print_version
			# print_version_git_message
			exit
			;;
		-q | --quiet)
			_brg_verbose=0
			;;
		-v | --verbose)
			_brg_verbose=$((_brg_verbose + 1))
			;;
		--help)
			_brg_help="on"
			;;
		-h)
			print_help
			exit
			;;
		# -*)
		# 	_brg_unknown_opts+=("$1")
		# 	shift || true
		# 	if [[ $# -gt 0 ]]; then
		# 		_brg_unknown_opts+=("$1")
		# 	fi
		# 	;;
		*)
			_last_positional="$1"
			_positionals+=("$_last_positional")
			_positionals_count=$((_positionals_count + 1))
			;;
		esac
		shift || true
	done
}

handle_passed_args_count() {
	test "${_positionals_count}" -le 12 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 0 and 5, but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}

assign_positional_args() {
	local _positional_name _shift_for=$1
	_positional_names="_brg_menu[0] _brg_menu[1] _brg_menu[2] _brg_menu[3] _brg_menu[4] _brg_menu[5] _brg_menu[6] _brg_menu[7] _brg_menu[8] _brg_menu[9] _brg_menu[10] _brg_menu[11]"

	shift "$_shift_for"
	for _positional_name in ${_positional_names}; do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

# ---------------------------------------------
# Default preset configuration (can be overridden by env or CLI)
# ---------------------------------------------
: "${POLAP_PRESET_DIR:="$HOME/.polap/presets"}"
: "${POLAP_PRESET:=""}"
: "${POLAP_PRESET_PATH:=""}"

# CLI overrides
_brg_preset=""
_brg_preset_dir=""
_brg_preset_path=""
_brg_allow_create="yes"
_brg_dry_run="no"

# ---------------------------------------------
# Parse CLI arguments
# ---------------------------------------------

parse_preset_commandline "$@"

# ---------------------------------------------
# Resolve effective values
# ---------------------------------------------
preset_name="${_brg_preset:-${POLAP_PRESET}}"
preset_dir="${_brg_preset_dir:-${POLAP_PRESET_DIR}}"
preset_path="${_brg_preset_path:-${POLAP_PRESET_PATH}}"

# Expand ~ early
if [[ -n "$preset_dir" ]]; then
	# shellcheck disable=SC2086
	preset_dir="$(eval printf '%s' "$preset_dir")"
fi
if [[ -n "$preset_path" ]]; then
	# shellcheck disable=SC2086
	preset_path="$(eval printf '%s' "$preset_path")"
fi

# Compute effective preset file path
if [[ -n "$preset_path" ]]; then
	effective_preset="$preset_path"
elif [[ -n "$preset_name" ]]; then
	[[ -n "$preset_dir" ]] || preset_dir="$HOME/.polap/presets"
	effective_preset="$preset_dir/$preset_name.yaml"
else
	effective_preset=""
fi

# ---------------------------------------------
# Inform user
# ---------------------------------------------
if [[ "$_brg_dry_run" == "yes" ]]; then
	if [[ -n "$preset_name" ]]; then
		echo "[info] preset: ${preset_name}" >&2
	else
		echo "[info] no preset specified" >&2
	fi

	if [[ -n "$effective_preset" ]]; then
		echo "[info] preset file: ${effective_preset}" >&2
	else
		echo "[info] no preset file" >&2
	fi
	exit 0
fi

# ---------------------------------------------
# Ensure file presence / creation
# ---------------------------------------------
if [[ -n "$effective_preset" ]]; then
	if [[ -f "$effective_preset" ]]; then
		: # OK
	else
		if [[ "$_brg_allow_create" == "yes" ]]; then
			mkdir -p -- "${effective_preset%/*}"
			{
				echo "# polap preset (auto-created)"
				echo "preset_name: ${preset_name}"
				echo "pipeline:"
				echo "  example_key: example_value"
			} >"$effective_preset"
			echo "[info] created new preset: $effective_preset" >&2
		else
			echo "[error] preset not found: $effective_preset (and --no-create given)" >&2
			exit 127
		fi
	fi
fi

# ---------------------------------------------
# Load and apply preset configuration
# ---------------------------------------------
LOAD_PY="${_POLAPLIB_DIR}/polap-py-config-load.py"
if [[ ! -f "$LOAD_PY" ]]; then
	echo "[error] not found: $LOAD_PY" >&2
	exit 127
fi

if [[ -n "$effective_preset" && -s "$effective_preset" ]]; then
	if ! ENV_LINES="$(python3 "$LOAD_PY" --path "$effective_preset" --format env --prefix "PCFG" 2>&1)"; then
		echo "[error] failed to parse preset YAML: $effective_preset" >&2
		printf '%s\n' "$ENV_LINES" >&2
		exit 1
	fi
	safe_env=$(printf '%s\n' "$ENV_LINES" | grep -E '^[A-Z0-9_]+=' || true)
	eval "$safe_env"

	APPLY_SH="${_POLAPLIB_DIR}/polap-bash-apply-pcfg.sh"
	if [[ -f "$APPLY_SH" ]]; then
		# shellcheck disable=SC1090
		source "$APPLY_SH"
		if declare -F polap_apply_pcfg >/dev/null 2>&1; then
			polap_apply_pcfg
		fi
	fi
fi

# Polap command
_polap_cmd="${_polap_script_bin_dir}/polap.sh"
if [[ "${_POLAP_RELEASE}" == "1" ]]; then
	_polap_cmd="${_polap_script_bin_dir}/polap"
else
	_polap_cmd="${_polap_script_bin_dir}/polap.sh"
fi

# Command-line parsing
_brg_adir="${opt_t_arg:-t5}"
_brg_verbose=1
_brg_args=("$@")
parse_commandline "$@"

handle_passed_args_count
set +u
assign_positional_args 1 "${_positionals[@]}"
set -u

verbose_or_quiet_flags() {
	((_brg_verbose > 0)) && for ((i = 1; i < _brg_verbose; i++)); do echo -n "-v "; done || echo -n "--quiet"
}

_brg_verbose_str=$(verbose_or_quiet_flags)

# OTHER STUFF GENERATED BY Argbash
script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}

### END OF CODE GENERATED BY Argbash (sortof) ### ])
