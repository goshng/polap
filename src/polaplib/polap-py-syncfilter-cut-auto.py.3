#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
polap-py-syncfilter-cut-auto.py  (YAML + CLI overrides; strict bands)

Purpose:
  From a syncfilter quickview TSV, estimate:
    1) a nuclear right-tail cut: cut_nuc_log = mu_nuc + z(tail)*sigma_nuc
    2) (optional) mt/pt bands from anchor ID lists:
       mu_mt/pt = median(X_anchors), sigma_mt/pt = std (fallback MAD),
       band: [mu - z(tail_mt/pt)*sigma, mu + z* sigma]

Reclassification policy (strict):
  - If X in mt band ⇒ mt
  - Else if X in pt band ⇒ pt
  - Else if X <= cut_nuc_log ⇒ nuclear
  - Else ⇒ nuclear (conservative; no leakage to mt/pt outside bands)

I/O:
  - Input TSV: columns: read_id, n_syncmer, mean, median, q25, q75, class
  - X = log10(median), ignore rows with median <= 0

YAML (flat) keys used (CLI wins):
  x_method, x_tail, tail_mt, tail_pt, x_win, band_max, sigma_floor
  pt_anchors, mt_anchors
  quickview_tsv or input (used if -i/--input omitted)
  cuts_out, tsv_out, png

CLI overrides (selected):
  -i/--input, --method, --tail, --tail-mt, --tail-pt,
  --window-width, --band-max, --sigma-floor, --nbins
  --pt FILE, --mt FILE
  --cuts-out PATH, --tsv-out PATH, --png PATH
  --path FILE.yaml | --config-dir DIR --preset NAME

Exit codes: 0 ok; 2 usage; 3 IO; 4 parse
"""
import argparse, os, sys, math, json
from collections import defaultdict


# ---------------- YAML ----------------
def _load_yaml(path):
    try:
        import yaml  # type: ignore

        with open(path, "r", encoding="utf-8") as fh:
            d = yaml.safe_load(fh) or {}
        if not isinstance(d, dict):
            raise ValueError("YAML is not a mapping")
        return d
    except ImportError:
        # fallback minimal flat YAML parser
        d = {}
        with open(path, "r", encoding="utf-8") as fh:
            for ln in fh:
                ln = ln.strip()
                if not ln or ln.startswith("#") or ":" not in ln:
                    continue
                k, v = ln.split(":", 1)
                k = k.strip()
                v = v.strip().strip("'").strip('"')
                vl = v.lower()
                if vl in ("true", "false"):
                    d[k] = vl == "true"
                else:
                    try:
                        if "." in v:
                            d[k] = float(v)
                        else:
                            d[k] = int(v)
                    except ValueError:
                        d[k] = v
        return d


def resolve_config(config_dir=None, preset=None, path=None):
    if path:
        return os.path.expanduser(path)
    if not config_dir or not preset:
        return None
    return os.path.join(os.path.expanduser(config_dir), f"{preset}.yaml")


# ---------------- utils ----------------
def read_ids(path):
    s = set()
    if not path:
        return s
    with open(path) as fh:
        for line in fh:
            tok = line.strip().split()
            if tok:
                s.add(tok[0])
    return s


def load_quickview(tsv):
    rows = []
    with open(tsv, encoding="utf-8") as fh:
        header = fh.readline().rstrip("\n").split("\t")
        idx = {h: i for i, h in enumerate(header)}
        # expected: read_id, n_syncmer, mean, median, q25, q75, class
        for ln in fh:
            sp = ln.rstrip("\n").split("\t")
            if len(sp) < 6:
                continue
            try:
                rid = sp[idx.get("read_id", 0)].split()[0]
                med = float(sp[idx.get("median", 3)])
                if med <= 0:
                    continue
                X = math.log10(med)
                rows.append(
                    {
                        "read_id": rid,
                        "median": med,
                        "X": X,
                    }
                )
            except Exception:
                pass
    return rows


def sigma_mad(x):
    if not x:
        return None
    import statistics as st

    med = st.median(x)
    mad = st.median([abs(v - med) for v in x])
    if mad == 0:
        try:
            return float(st.pvariance(x) ** 0.5)
        except Exception:
            return None
    return float(mad / 0.6744897501960817)


# robust z (right-tail)
try:
    from statistics import NormalDist
except Exception:
    NormalDist = None


def z_for_tail(t):
    t = float(t)
    if t <= 0.0:
        return float("inf")
    if t >= 1.0:
        return 0.0
    if NormalDist is not None:
        return NormalDist().inv_cdf(1.0 - t)
    # fallback approx (Abramowitz-Stegun)
    import math

    p = 1.0 - t
    a1, a2, a3, a4, a5, a6 = (
        -39.69683028665376,
        220.9460984245205,
        -275.9285104469687,
        138.3577518672690,
        -30.66479806614716,
        2.506628277459239,
    )
    b1, b2, b3, b4 = (
        -54.47609879822406,
        161.5858368580409,
        -155.6989798598866,
        66.80131188771972,
    )
    c1, c2, c3, c4, c5, c6 = (
        -0.007784894002430293,
        -0.3223964580411365,
        -2.400758277161838,
        -2.549732539343734,
        4.374664141464968,
        2.938163982698783,
    )
    d1, d2, d3 = (0.007784695709041462, 0.3224671290700398, 2.445134137142996)
    plow, phigh = 0.02425, 1.0 - 0.02425
    if p < plow:
        q = (-2.0 * math.log(p)) ** 0.5
        x = (((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / (
            (((d1 * q + d2) * q + d3) * q + 1.0)
        )
    elif p > phigh:
        q = (-2.0 * math.log(1.0 - p)) ** 0.5
        x = -(((((c1 * q + c2) * q + c3) * q + c4) * q + c5) * q + c6) / (
            (((d1 * q + d2) * q + d3) * q + 1.0)
        )
    else:
        q = p - 0.5
        r = q * q
        x = (
            (((((a1 * r + a2) * r + a3) * r + a4) * r + a5) * r + a6)
            * q
            / (((((b1 * r + b2) * r + b3) * r + b4) * r + 1.0))
        )
    return float(x)


# hist utils
def smooth(y, rounds=2):
    x = y[:]
    for _ in range(rounds):
        if len(x) < 3:
            break
        x = (
            [x[0]]
            + [
                0.25 * x[i - 1] + 0.5 * x[i] + 0.25 * x[i + 1]
                for i in range(1, len(x) - 1)
            ]
            + [x[-1]]
        )
    return x


def windowed_mode(logm, nbins=320, win=0.12):
    # smoothed histogram moving-sum "mode"
    import numpy as np

    if len(logm) == 0:
        return 0.0
    lo, hi = min(logm), max(logm)
    if lo == hi:
        return lo
    hist, edges = np.histogram(logm, bins=nbins, range=(lo, hi))
    ctrs = 0.5 * (edges[:-1] + edges[1:])
    s = smooth(list(hist), 1)
    # moving window ~ win
    bw = (hi - lo) / nbins if nbins > 0 else 1e-6
    half = max(1, int((win / 2) / bw))
    mv = []
    for i in range(len(s)):
        L = max(0, i - half)
        R = min(len(s), i + half + 1)
        mv.append(sum(s[L:R]))
    idx = int(max(range(len(mv)), key=lambda i: mv[i]))
    return float(ctrs[idx])


def sigma_window(logm, mu, w=0.20, min_n=50):
    import numpy as np

    sel = [x for x in logm if (mu - w) <= x <= mu]
    if len(sel) < min_n:
        return None
    return float(np.std(sel)) if len(sel) > 1 else None


# plotting
def plot_bands(X_all, bands, png_path):
    try:
        import matplotlib

        matplotlib.use("Agg")
        import matplotlib.pyplot as plt
    except Exception:
        return
    import numpy as np

    plt.figure(figsize=(8.5, 4.8))
    plt.hist(X_all, bins=140, alpha=0.35, label="all")
    colors = {"nuclear": "tab:blue", "mt": "tab:orange", "pt": "tab:green"}
    for t in ("nuclear", "mt", "pt"):
        if t in bands:
            b = bands[t]
            mu = b["mu"]
            sg = b["sigma"]
            r = b["range"]
            c = colors.get(t, "k")
            if r[0] is not None:
                plt.axvline(r[0], linestyle="--", linewidth=1.8, color=c)
            if r[1] is not None:
                plt.axvline(r[1], linestyle="--", linewidth=1.8, color=c)
            plt.axvline(
                mu, linestyle=":", linewidth=1.6, color=c, label=f"{t} μ={mu:.3f}"
            )
    plt.xlabel("log10(median syncmer multiplicity / coverage proxy)")
    plt.ylabel("count (reads)")
    plt.legend(loc="upper right", fontsize=9)
    plt.tight_layout()
    plt.savefig(png_path, dpi=150)
    plt.close()


# ---------------- main ----------------
def main():
    ap = argparse.ArgumentParser(
        description="Auto-cut and band learning for nuclear/pt/mt using anchor IDs (strict bands)."
    )
    # addressing
    ap.add_argument("--path", help="explicit YAML config with defaults")
    ap.add_argument("--config-dir", help="base config dir (default: ~/.polap/profiles)")
    ap.add_argument("--preset", help="profile name with --config-dir")

    # IO
    ap.add_argument("-i", "--input", help="syncfilter quickview TSV")
    ap.add_argument("--cuts-out", help="PATH for cuts tsv")
    ap.add_argument("--tsv-out", help="PATH for reclass tsv")
    ap.add_argument("--png", help="overlay PNG")

    # banding knobs
    ap.add_argument(
        "--method",
        dest="x_method",
        choices=["mad", "window", "std", "valley", "hybrid"],
    )
    ap.add_argument("--tail", type=float, dest="x_tail")
    ap.add_argument("--tail-mt", type=float)
    ap.add_argument("--tail-pt", type=float)
    ap.add_argument("--window-width", type=float, dest="x_win")
    ap.add_argument("--band-max", type=float)
    ap.add_argument("--sigma-floor", type=float)
    ap.add_argument("--nbins", type=int)

    # anchors
    ap.add_argument("--pt", help="pt anchor IDs file", dest="pt_anchors")
    ap.add_argument("--mt", help="mt anchor IDs file", dest="mt_anchors")

    args = ap.parse_args()

    # load YAML if provided
    cfg = {}
    cfg_path = resolve_config(args.config_dir, args.preset, args.path)
    if cfg_path and os.path.exists(cfg_path):
        cfg = _load_yaml(cfg_path)

    # provenance
    overrides = []
    for a in sys.argv[1:]:
        if a in ("--path", "--config-dir", "--preset"):  # keep; still useful
            overrides.append(a)
        else:
            overrides.append(a)
    print(
        f"[provenance] config={cfg_path or '?'} overrides={' '.join(overrides) if overrides else '(none)'}",
        file=sys.stderr,
    )

    # merge knobs (CLI wins)
    def get(key, default=None, cli_name=None):
        cli_val = getattr(args, key if cli_name is None else cli_name, None)
        if cli_val is not None:
            return cli_val
        return cfg.get(key, default)

    # IO resolution
    input_tsv = get("input") or cfg.get("quickview_tsv") or cfg.get("input")
    if not input_tsv:
        print("[error] need --input or YAML quickview_tsv/input", file=sys.stderr)
        return 2
    cuts_out = (
        get("cuts_out")
        or f"{os.path.splitext(os.path.splitext(input_tsv)[0])[0]}.cuts.tsv"
    )
    tsv_out = (
        get("tsv_out")
        or f"{os.path.splitext(os.path.splitext(input_tsv)[0])[0]}.reclass.tsv"
    )
    png_out = get("png")

    # banding params
    method = get("x_method", "hybrid", "x_method")
    tail_nuc = float(get("x_tail", 0.05, "x_tail") or 0.05)
    tail_mt = get("tail_mt", None)
    tail_pt = get("tail_pt", None)
    xwin = float(get("x_win", 0.20, "x_win") or 0.20)
    band_max = float(get("band_max", 2.0, "band_max") or 2.0)
    sigma_floor = float(get("sigma_floor", 0.03, "sigma_floor") or 0.03)
    nbins = int(get("nbins", 320, "nbins") or 320)

    # anchors
    pt_ids = read_ids(get("pt_anchors"))
    mt_ids = read_ids(get("mt_anchors"))

    # load data
    rows = load_quickview(input_tsv)
    if not rows:
        print("[error] no usable rows in TSV", file=sys.stderr)
        return 3
    X_all = [r["X"] for r in rows]

    # estimate nuclear band: use subset X < band_max
    X_nuc_band = [x for x in X_all if x < band_max]
    if not X_nuc_band:
        print(f"[error] no X < {band_max}", file=sys.stderr)
        return 3

    mu_nuc = windowed_mode(X_nuc_band, nbins=nbins, win=xwin)
    # sigma
    if method == "mad":
        sg_nuc = sigma_mad(X_nuc_band) or sigma_floor
    elif method == "std":
        import statistics as st

        sg_nuc = (
            float(st.pvariance(X_nuc_band) ** 0.5)
            if len(X_nuc_band) > 1
            else sigma_floor
        )
    else:
        sg_nuc = sigma_window(X_nuc_band, mu_nuc, w=xwin, min_n=50)
        if sg_nuc is None:
            sg_nuc = sigma_mad(X_nuc_band) or sigma_floor
    sg_nuc = max(sg_nuc, sigma_floor)
    z_nuc = z_for_tail(tail_nuc)
    cut_nuc_log = mu_nuc + z_nuc * sg_nuc
    cut_nuc_lin = 10**cut_nuc_log

    # learn bands from anchors
    import statistics as st

    def learn_band_from_anchors(ids_set):
        X = [r["X"] for r in rows if r["read_id"] in ids_set]
        if len(X) < 10:
            return None
        mu = float(st.median(X))
        try:
            sg = float(st.pvariance(X) ** 0.5) if len(X) > 1 else None
        except Exception:
            sg = None
        if sg is None or sg <= 0:
            sg = sigma_mad(X) or sigma_floor
        sg = max(sg, sigma_floor)
        return (mu, sg)

    band_mt = learn_band_from_anchors(mt_ids) if mt_ids else None
    band_pt = learn_band_from_anchors(pt_ids) if pt_ids else None

    # choose tails for mt/pt (default to nuclear tail if not provided)
    tail_mt = float(tail_mt if tail_mt is not None else tail_nuc)
    tail_pt = float(tail_pt if tail_pt is not None else tail_nuc)
    z_mt = z_for_tail(tail_mt)
    z_pt = z_for_tail(tail_pt)

    # cuts.tsv lines
    cuts_lines = []
    cuts_lines.append(
        {
            "f1": f"{cut_nuc_lin:.8f}",
            "f2": "NA",
            "three_bins": "0",
            "method": method,
            "mu_log10": f"{mu_nuc:.5f}",
            "sigma_log10": f"{sg_nuc:.5f}",
            "tail": f"{tail_nuc}",
            "type": "nuclear",
        }
    )
    if band_mt:
        mu_mt, sg_mt = band_mt
        cuts_lines.append(
            {
                "f1": f"{10**(mu_mt - z_mt*sg_mt):.8f}",
                "f2": f"{10**(mu_mt + z_mt*sg_mt):.8f}",
                "three_bins": "1",
                "method": "std",
                "mu_log10": f"{mu_mt:.5f}",
                "sigma_log10": f"{sg_mt:.5f}",
                "tail": f"{tail_mt}",
                "type": "mt",
            }
        )
    if band_pt:
        mu_pt, sg_pt = band_pt
        cuts_lines.append(
            {
                "f1": f"{10**(mu_pt - z_pt*sg_pt):.8f}",
                "f2": f"{10**(mu_pt + z_pt*sg_pt):.8f}",
                "three_bins": "1",
                "method": "std",
                "mu_log10": f"{mu_pt:.5f}",
                "sigma_log10": f"{sg_pt:.5f}",
                "tail": f"{tail_pt}",
                "type": "pt",
            }
        )

    # write cuts
    with open(cuts_out, "w", encoding="utf-8") as w:
        w.write("f1\tf2\tthree_bins\tmethod\tmu_log10\tsigma_log10\ttail\ttype\n")
        for L in cuts_lines:
            w.write(
                f"{L['f1']}\t{L['f2']}\t{L['three_bins']}\t{L['method']}\t{L['mu_log10']}\t{L['sigma_log10']}\t{L['tail']}\t{L['type']}\n"
            )
    print(f"[cuts] {cuts_out}")

    # strict reclassification
    # build band dicts on log10
    bands = {
        "nuclear": {"mu": mu_nuc, "sigma": sg_nuc, "range": (cut_nuc_log, cut_nuc_log)}
    }
    rng_mt = None
    rng_pt = None
    if band_mt:
        mu_mt, sg_mt = band_mt
        rng_mt = (mu_mt - z_mt * sg_mt, mu_mt + z_mt * sg_mt)
        bands["mt"] = {"mu": mu_mt, "sigma": sg_mt, "range": rng_mt}
    if band_pt:
        mu_pt, sg_pt = band_pt
        rng_pt = (mu_pt - z_pt * sg_pt, mu_pt + z_pt * sg_pt)
        bands["pt"] = {"mu": mu_pt, "sigma": sg_pt, "range": rng_pt}

    def in_rng(x, rng):
        return (
            (rng is not None)
            and (rng[0] is not None)
            and (rng[1] is not None)
            and (rng[0] <= x <= rng[1])
        )

    # reclassify
    for r in rows:
        x = r["X"]
        if rng_mt and in_rng(x, rng_mt):
            r["class"] = "mt"
        elif rng_pt and in_rng(x, rng_pt):
            r["class"] = "pt"
        elif x <= cut_nuc_log:
            r["class"] = "nuclear"
        else:
            r["class"] = "nuclear"  # conservative

    # write reclass tsv + ids
    with open(tsv_out, "w", encoding="utf-8") as w:
        w.write("read_id\tn_syncmer\tmean\tmedian\tq25\tq75\tclass\n")
        for r in rows:
            w.write(f"{r['read_id']}\t\t\t{r['median']:.3f}\t\t\t{r['class']}\n")
    print(f"[reclass] {tsv_out}")

    base = os.path.splitext(tsv_out)[0]
    buckets = defaultdict(list)
    for r in rows:
        buckets[r["class"]].append(r["read_id"])
    for name in ("nuclear", "mt", "pt"):
        fn = f"{base}.{name}.ids"
        with open(fn, "w", encoding="utf-8") as w:
            for rid in buckets.get(name, []):
                w.write(rid + "\n")
        print(f"[ids] {name} -> {fn} (n={len(buckets.get(name, []))})")

    # plot
    if png_out:
        plot_bands(X_all, bands, png_out)
        print(f"[plot] {png_out}")

    return 0


if __name__ == "__main__":
    sys.exit(main())
