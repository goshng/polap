#!/usr/bin/env bash
set -euo pipefail
set -o errtrace

if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
	echo "[ERROR] This script must be executed, not sourced: use 'bash $BASH_SOURCE'" >&2
	return 1 2>/dev/null || exit 1
fi
: "${_POLAP_DEBUG:=0}"
export _POLAP_DEBUG
: "${_POLAP_RELEASE:=0}"
export _POLAP_RELEASE

_polap_script_bin_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)" || {
	echo "Couldn't determine the script's running directory, which probably matters, bailing out" >&2
	exit 2
}

# ───────────────────────────────────────────────────────────────────────────────
_POLAPLIB_DIR="${_polap_script_bin_dir}/polaplib"

# Source the helper and ensure profiles exist
if [[ -r "${_POLAPLIB_DIR}/polap-lib-profiles.sh" ]]; then
	source "${_POLAPLIB_DIR}/polap-lib-profiles.sh"
	_polap_ensure_profiles_dir
fi

source "${_POLAPLIB_DIR}/polap-lib-version.sh"
source "${_POLAPLIB_DIR}/polap-parsing.sh"

# ── NEW: autoloader ────────────────────────────────────────────
for arg in "$@"; do
	case "$arg" in
	--trace-load)
		export POLAP_AUTOLOAD_TRACE=1
		shift
		;;
	esac
done
source "${_POLAPLIB_DIR}/polap-bash-autoload.sh"
polap_autoload "${_POLAPLIB_DIR}"
polap_trap_enable

# ───────────────────────────────────────────────────────────────

# END OF CODE GENERATED BY Argbash (sortof)

################################################################################
# All of the variables at our disposal
################################################################################

################################################################
# MAIN
#
if [ $# -eq 0 ]; then
	print_help
	touch make-menus
	exit $EXIT_SUCCESS
fi

# the default output o is created. o/polap.log, o/tmp, o/log are created as well.
source "${_POLAPLIB_DIR}/polap-variables-main.sh"
_polap_timer_reset
_polap_lib_log-init

# see polap-variables-main.sh for the logit function. all message to a log file
# exec 3>&1 1>> >(logit)
# Save real stdout as 3
# exec 3>&1
# Send stdout through your logger
# exec 1> >(logit)
# Tee *all* stderr to log file AND keep showing on screen
# exec 4>&2 # save real stderr (screen)
# exec 2> >(tee -a "$LOG_FILE" >&4)
# exec 5> >(tee -a "$LOG_FILE" >&4)

# before your other exec redirects
exec 3>&1 # real stdout (screen)
exec 4>&2 # real stderr (screen)

# send parent stdout through logger
exec 1> >(logit)

# tee parent stderr to log + screen
exec 2> >(tee -a "$LOG_FILE" >&4)

# Robust FD 5: always tee to log AND real screen, even if FD 4 changes
if [[ -t 2 ]]; then
	exec 5> >(tee -a "$LOG_FILE" >/dev/tty)
else
	# no tty (cron, pipe). Fallback: tee to whatever stderr currently is.
	exec 5> >(tee -a "$LOG_FILE" >&2)
fi

[[ "${_arg_clock}" == "on" ]] && date +"%Y-%m-%d %H:%M:%S" >&3
CMD="$0 $*"
echo "POLAP: ${_polap_version}"
echo "CMD: $CMD"

# Print all the global variables from polap-parsing.sh.
set +u
for var in $(compgen -v _arg_); do
	# echo "$var"
	# echo "val=${var}"
	# val="${!var-}"
	echo "$var=${!var}"
done
set -u

# Options
if [[ -n "${_arg_genomesize}" ]]; then
	_arg_genomesize=$(_polap_lib_unit-convert_to_int ${_arg_genomesize})
fi

# _polap_lib_random-init "${_arg_random_seed}"

# Call a subcommand function
if declare -f "_run_polap_${_arg_menu[0]}" >/dev/null 2>&1; then
	_polap_log1 "Execute: subcommand ${_arg_menu[0]}"

	"_run_polap_${_arg_menu[0]}"
	_polap_log3 "Menu ${_arg_menu[0]} has been finished."

elif [[ ! -f "${_arg_menu[0]}" ]]; then
	_polap_log0 "-----------------------------------"
	_polap_log0 "Menu: assemble, prepare-polishing, polish"
	_polap_log0 "  assemble1, total-length-long, find-genome-size, reduce-data, flye1, annotate"
	_polap_log0 "  assemble2, select-seeds, map-reads, test-reads, select-reads, flye2"
	_polap_log0 "ERROR: no such menu of $1"
else
	_polap_log1 "Execute: file: ${_arg_menu[0]}"

	# Check arguments as files

	_polap_lib_conda-ensure_conda_env polap || exit 1

	for _menu_item in "${_arg_menu[@]}"; do
		seqtype=$(_polap_lib_try _polap_lib_fastq-check-type "${_menu_item}" --fallback skip)
		# seqtype=$(_polap_lib_fastq-check-type "${_menu_item}")
		case "$seqtype" in
		illumina)
			_polap_log1 "Detected Illumina short-read: $_menu_item"
			if [[ "${_arg_short_read1_is}" == "on" ]]; then
				_arg_short_read2="${_menu_item}"
				_arg_short_read2_is="on"
				_arg_2_fastq="$_arg_short_read2"
			else
				_arg_short_read1="${_menu_item}"
				_arg_short_read1_is="on"
				_arg_1_fastq="$_arg_short_read1"
			fi
			;;
		pacbio-hifi)
			_polap_log1 "Detected PacBio HiFi read"
			_arg_long_reads="${_menu_item}"
			_arg_long_reads_is="on"
			_arg_long_reads_original="${_arg_long_reads}"
			_arg_l_fastq="${_arg_long_reads}"
			;;
		nano-raw)
			_polap_log1 "Detected Nanopore raw read"
			_arg_long_reads="${_menu_item}"
			_arg_long_reads_is="on"
			_arg_long_reads_original="${_arg_long_reads}"
			_arg_l_fastq="${_arg_long_reads}"
			;;
		unknown)
			_polap_log1 "Could not determine sequencing type ${_menu_item}: pacbio-clr, nano-hq"
			;;
		# *)
		# 	_polap_log1 "unknown sequencing data type: ${_menu_item}"
		# 	;;
		esac
	done

	_polap_log1 "checking: ${_arg_long_reads}"
	if [[ -s "${_arg_long_reads}" ]]; then
		seqtype=$(_polap_lib_try _polap_lib_fastq-check-type "${_arg_long_reads}" --fallback skip)
		if [[ "${seqtype}" == "nano-raw" ]]; then
			_polap_log0 "ONT long-read: ${_arg_long_reads}"
			_arg_data_type="nano-raw"
			_arg_flye_data_type="--nano-raw"
			_arg_minimap2_data_type="map-ont"
		elif [[ "${seqtype}" == "pacbio-hifi" ]]; then
			_polap_log0 "PacBio HiFi long-read: ${_arg_long_reads}"
			_arg_data_type="pacbio-hifi"
			_arg_flye_data_type="--pacbio-hifi"
			_arg_minimap2_data_type="map-hifi"
		else
			_polap_log0 "ERROR: no long-read data: ${_arg_long_reads}: ${seqtype}"
		fi
	fi

	if [[ -s "${_arg_short_read1}" ]]; then
		seqtype=$(_polap_lib_fastq-check-type "${_arg_short_read1}")
		if [[ "${seqtype}" == "illumina" ]]; then
			_polap_log0 "Short-read 1: ${_arg_short_read1}"
		else
			_polap_log0 "ERROR: no short-read data: ${_arg_short_read1}"
		fi
	else
		_polap_log1 "no short-read data"
	fi

	if [[ -s "${_arg_short_read2}" ]]; then
		seqtype=$(_polap_lib_fastq-check-type "${_arg_short_read2}")
		if [[ "${seqtype}" == "illumina" ]]; then
			_polap_log0 "Short-read 2: ${_arg_short_read2}"
		else
			_polap_log0 "ERROR: no short-read data: ${_arg_short_read2}"
		fi
	else
		_polap_log1 "no short-read data"
	fi

	if [[ -s "${_arg_long_reads}" ]]; then
		_polap_log1 "Execute polap assemble"
		_polap_lib_random-init
		_polap_lib_random-get
		_run_polap_assemble

		# if [[ "${_arg_plastid}" == "on" ]]; then
		# 	# plastid genome assembly
		# 	_run_polap_readassemble
		# else
		# 	# mitochondrial genome assembly: ptDNA and then mtDNA assembly
		# 	_arg_plastid="on"
		# 	_run_polap_readassemble
		# 	# mtDNA assembly
		# 	_arg_plastid="off"
		# 	_arg_noncoding="on"
		# 	_run_polap_readassemble
		# fi
	else
		_polap_log0 "-----------------------------------"
		_polap_log0 "Menu: assemble, prepare-polishing, polish"
		_polap_log0 "  assemble1, total-length-long, find-genome-size, reduce-data, flye1, annotate"
		_polap_log0 "  assemble2, select-seeds, map-reads, test-reads, select-reads, flye2"
		_polap_log0 "ERROR: no such menu of $1"
	fi

	conda deactivate
fi

[[ "${_arg_clock}" == "on" ]] && date +"%Y-%m-%d %H:%M:%S" >&3
ELAPSED="Time at $(hostname): $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"
exec 3>&-
