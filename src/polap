#!/usr/bin/env bash

################################################################################
# polap: Plant organelle long-read assembly pipeline
# Copyright (C) 2023 Sungshin Women's University
#
# This program is free software: you can redistribute it and/or modify it under 
# the terms of the GNU General Public License as published by the Free Software 
# Foundation, either version 3 of the License, or (at your option) any later 
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with 
# this program. If not, see <https://www.gnu.org/licenses/>.
################################################################################

################################################################################
# Brief introduction:
################################################################################
# polap represents plant organelle long read assembly pipeline.
# I name it polap because the small project
# was inspired by the chloroplast genome assembly pipeline called 
# ptGAUL (https://github.com/Bean061/ptgaul) by Wenbin Zhou.
# As such, it uses the long read genome assembler, 
# flye (https://github.com/fenderglass/Flye), with 
# the assembled sequence polishing tool, 
# fmlrc (https://github.com/holtjma/fmlrc) by Matt Holt.
# Additionally, it makes use of the sequencing depths from a flye genome
# assembly and organelle gene annotation to select contigs originating in
# user's target mitochondrial genome using 
# BLAST (ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/).
# The pipeline exploits the results of a long-read assembler,
# flye runs. So, it could be called a flye helper pipeline with features of 
# organelle gene annotation for selecting organelle-origin contigs from 
# a flye whole-genome assembly.
################################################################################

################################################################################
# Log
################################################################################
# 2023-08-06: version 0.1.3
#  - jellyfish: genome estimation with short-read data
#  - pair/single option: 500/1000 -> 3000/3000
#  - ptGAUL-like single option: 1000 -> 3000
# 2023-08-02: version 0.1.2
#  - gce: genome estimation with long-read data
#  - pair/single option: 500/1000
#  - ptGAUL-like single option: 1000
# 2023-06-02: version 0.1.1
#  - steps 1 through 4: the first draft
#  - steps 6 and 7: ptGAUL's polishing steps
################################################################################

################################################################################
# Package requirement
################################################################################
# for assembling in steps 1,2,3,4
# minimap2 2.22-r1101
# seqkit 2.0.0
# flye 2.72.9-b1768
# blastn: 2.11.0+
# bedtools v2.30.0
# R with dplyr package
#
# for coverage in step5
# samtools 1.17
# 
# for polishing in steps 6 and 7
# python2 environment:
# fmlrc=1.0.0
# ropebwt2=r187
# msbwt==0.3.0
################################################################################

VERSION="0.1.3"
# version
function version() {
    echoall "$(basename "$0") version $VERSION"
#     cat >&2 <<EOM
# $(basename "$0") version 0.1.3
# EOM
}

function version_print () {
    echo "$(basename "$0") version $VERSION"
#     cat >&2 <<EOM
# $(basename "$0") version 0.1.3
# EOM
}

# debugging
# set -x

# exit if errors
set -e

# execution time count
SECONDS=0

# include and execute other BASH and R scripts
WDIR="$(dirname "$0")"
WDIR="${BASH_SOURCE%/*}"
if [[ ! -d "$WDIR" ]]; then WDIR="$PWD"; fi
source "$WDIR/run-polap-common.sh"

# debugging main variables
function print_options() {
    # cat >&2 <<EOM
    cat <<EOM
STEPS=[0]$STEP0 [1]$STEP1 [2]$STEP2 [3]$STEP3 [4]$STEP4 [5]$STEP5 [6]$STEP6 [7]$STEP7
ODIR=$ODIR
LR3K=$LR3K
LR=$LR
SR1=$SR1
SR2=$SR2
NT=$NT
MR=$MR
PA=$PA
FA=$FA
EOM
}

# usage for long options
function usage() {
    cat >&2 <<EOM
$(basename "$0") [options]

Decription:
Plant organelle long-read assembly pipeline.

steps subcommand:
    -0, --step0                     step0: check requirement 
    -1, --step1                     step1: flye whole genome assembly
    -2, --step2                     step2: organelle gene annotation
    -3, --step3                     step3: contig selection
    -4, --step4 <number>            step4: 60-mt-<number>
    -5, --step5                     step5: check the assembly
    -6, --step6                     step6: polishing step 1
    -7, --step7                     step7: polishing step 2
main step options:
    -l, --long-reads <fastq>        long-reads data file in fastq format
    -k, --3k-long-reads <fastq>     long-reads (min 3001bp) fastq file
    -o, --outdir <dir>              output folder name [default: o]
    -a, --short-read1 <fastq>       short-read fastq file 1
    -b, --short-read2 <fastq>       short-read fastq file 2
    -s, --sra <SRA accession>       SRA data
    -p, --unpolished-fasta <fasta>  polishing sequence in fasta format
    -f, --final-assembly <fasta>    final assembly in fasta format
    -m, --min-read-length <number>  minimum length of long reads [$MR]
    -t, --threads <number>          number of CPUs
    -n, --no-reduction-reads        [step0] no reduction of long-read data
    -x, --no-contigger              [step1] use flye's 40-polishing result
    -y, --all-annotate              [step2] annotate all contigs
    -e, --use-edges                 [step4] use flye's edges not contigs
    -c, --coverage <number>         [step4] coverage for the 2nd assembly [$COV]
    -q, --no-coverage-check         [step4] no coverage check for step 4
    -w, --single-min <number>       [step4] min overlap on each contig [$SINGLE_MIN]
    -r, --resume                    [step1,step4] flye option resume
    -v, --version                   display version
    -h, --help                      display this help
subcommand assemble:
    assemble -s SRRlong,SRRshort    assemble using SRA data sets
    assemble -l l.fq -a 1.fq -b 2.fq assemble using a fastq data file
subcommand bflye:
    bflye -l l.fq -a 1.fq -b 2.fq   step0 and step1 
subcommand annotate:
    annotate                        step2 and step3
subcommand aflye:
    aflye info -n 1 -o o            print assembly_info.txt in 60-mt-1
    aflye seq -n 0 -c con -f o.fa   extract a contig from the first whole genome assembly
    aflye seq -c contig_1 -f o.fa   extract a contig for a mtDNA candidate
    aflye backup                    backup results
    aflye backup -b genus_species
    aflye recovery -b genus_species
subcommand of:
    of geseq                        Geseq gff3 to gff3 for Workbench
    of prepare
    of run
    of align -n 2   
    of refine -n 2  
    # of -a a.fa.1 -b a.fa -s species.of -g gene-to-remove.txt -f cpseudochinensis.mt.1.faa -o of
    iq                              iqtree
    # iq -n 3 -g of -l SWU240720_cds-blatx
    species                         species.map
    genes                           gene presence/absence table
    # polap genes -g of
subcommand draw:    
    draw                            draw tree and gene table
    draw -s 1 -p t1.pdf
    draw -s 1 -p t1.pdf --node 12
    draw -s 2 -p t4.pdf -r 25 -n 12 -t phylogenies/s.treefile -m species.map 
    draw -s 2 -p t4.pdf -r 25 -n 12 -t phylogenies/s.treefile -m species.map  --nodesize
    draw -s 3 -p t4.pdf -r 25 -n 12 -t phylogenies/s.treefile -m species.map 
    draw -s 4 -m species.map -g phylogenies/genes.tsv -o OL347690,MT483944 -l SWU240720 -p p2.pdf
    draw -s 5 -r 25 -n 12 -t phylogenies/s.treefile -m species.map -g phylogenies/genes.tsv -o OL347690,MT483944 -l SWU240720 -p t5.pdf
subcommand ncbi:
    ncbi bioproject -b PRJNA766491  sra info of NCBI BioProject in csv format
    ncbi sra -r SRR12549541         sra info in csv format
    ncbi tax -b PRJNA766491         taxonomy of NCBI BioProject
    ncbi mtdna -s "Vigna radiata"   mtDNA in genbank
    ncbi ptdna -s "Vigna radiata"   ptDNA in genbank (cpdna)
    cat PRJNA935991.txt | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty | less -S

Usage:
    polap ncbi bioproject -b PRJNA574453
    polap assemble -s SRR10190639,SRR10250248 -t 4
    polap assemble -l long.fq -a short1.fq -b short2.fq
    polap -0 -l long.fq -a short1.fq -b short2.fq
    polap -1 -k n3k.fq.gz
    polap -2
    polap -3
    polap -4 1 -k n3k.fq.gz -t 4
    polap -2 -o o/60-mt-1/o --all-annotate
    polap -3 -o o/60-mt-1/o
    polap -5
    polap aflye seq -c contig_1 -f mt.0.fa
    polap -6 -a r1.fq -b r2.fq
    polap -7 -p mt.0.fa -f mt.1.fa
    polap compare mt.1.fa MN544313.1.fa 
    polap rearrange 90405 mt.1.fa mt.2.fa (90405 is the first position)
    polap clustal mt.2.fa MN544313.1.fa 
    polap aflye backup -b Anthoceros_agrestis
    polap aflye recovery -b Anthoceros_agrestis.tar.gz
EOM
    exit 1
}

function set_options() {
    # --options for short option
    # --longoptions for long option
    # --name for command name
    # -- for user comment
    arguments=$(getopt --options s:hvl:k:t:m:o:C01234:567a:b:p:f:c:nxyeqw:r \
                       --longoptions help,verbose,long-reads:,3k-long-reads:,threads:,min-read-length:,short-reads:,outdir:,version,command-options,step0,step1,step2,step3,step4:,step5,step6,step7,code,resume,short-read1:,short-read2:,polishing-sequence:,final-assembly:,all-annotate,coverage,no-coverage-check,pair-min:,single-min:,no-reduction-reads,contigger,use-edges,no-contigger \
                       --name $(basename $0) \
                       -- "$@")
    eval set -- "$arguments"

    while true
    do
        case "$1" in
            -o | --outdir)
                ODIR=$2
                shift 2
                ;;
            -k | --3k-long-reads)
                LR3K=$2
                shift 2
                ;;
            -l | --long-reads)
                LR=$2
                shift 2
                ;;
            -a | --short-read1)
                SR1=$2
                shift 2
                ;;
            -b | --short-read2)
                SR2=$2
                shift 2
                ;;
            -s | --sra)
                SRALONG=$2
                SRASHORT=$3
                shift 3
                ;;
            -0 | --step0)
                STEP0=1
                shift
                ;;
            -1 | --step1)
                STEP1=1
                shift
                ;;
            -2 | --step2)
                STEP2=1
                shift
                ;;
            -3 | --step3)
                STEP3=1
                shift
                ;;
            -4 | --step4)
                STEP4=$2
                shift 2
                ;;
            -5 | --step5)
                STEP5=1
                shift
                ;;
            -6 | --step6)
                STEP6=1
                shift
                ;;
            -7 | --step7)
                STEP7=1
                shift
                ;;
            -p | --polishing-sequence)
                PA=$2
                shift 2
                ;;
            -f | --final-assembly)
                FA=$2
                shift 2
                ;;
            -t | --threads)
                NT=$2
                shift 2
                ;;
            -m | --min-read-length)
                MR=$2
                shift 2
                ;;
            -n | --no-reduction-reads)
                # for step0
                NO_REDUCTION_READS="--no-reduction-reads"
                shift
                ;;
            -r | --resume)
                # for step1
                RESUME="--resume"
                shift
                ;;
            -x | --no-contigger)
                # for step1
                FLYE_CONTIGGER="--polishing"
                shift
                ;;
            -y | --all-annotate)
                # for step2
                ALL_ANNOTATE="--all-annotate"
                shift
                ;;
            -e | --use-edges)
                # for step4
                USE_EDGES="--use-edges"
                shift
                ;;
            -q | --no-coverage-check)
                NO_COVERAGE_CHECK="--no-coverage-check"
                shift
                ;;
            -c | --coverage)
                COV=$2
                shift 2
                ;;
            -w | --single-min)
                SINGLE_MIN=$2
                shift 2
                ;;
            --code)
                astep1
                astep2
                bstep4
                exit 1
                ;;
            -h | --help)
                usage
                ;;
            -C | --command-options)
                print_options
                ;;
            -v | --version)
                version
				shift
                ;;
            --)
                shift
                break
                ;;
            *)
                usage
                ;;
        esac
    done

    # the remaining arguments
    # shift $((OPTIND-1))
    # url=$@
}

function set_options0() {
    while getopts "s:hvl:k:t:m:o:C01234:567cra:b:p:f:" option; do
        case "$option" in
            o) ODIR=$OPTARG
                ;;
            k) LR3K=$OPTARG
                ;;
            l) LR=$OPTARG
                ;;
            a) SR1=$OPTARG
                ;;
            b) SR2=$OPTARG
                ;;
            s) SRA=$OPTARG
                ;;
            0) STEP0=1;;
            1) STEP1=1;;
            2) STEP2=1;;
            3) STEP3=1;;
            4) # step4
                STEP4=$OPTARG
                ;;
            5) STEP5=1;;
            6) STEP6=1;;
            7) STEP7=1;;
            p) PA=$OPTARG
                ;;
            f) FA=$OPTARG
                ;;
            t) NT=$OPTARG
                ;;
            m) MR=$OPTARG
                ;;
            r) RESUME="--resume"
                ;;
            c) # after step1
                astep1
                astep2
                bstep4
                exit 1
                ;;
            h) # display Help
                echo "Note: use short options only"
                usage
                ;;
            C) # display options
                print_options
                ;;
            v) # display Help
                version
                ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
   done
}

function step0() {
    echo "DEBUG: start of step0"
    if [[ ! -e $ODIR ]]; then
        echo "INFO: $ODIR": an output folder is created.
        mkdir -p "$ODIR"
    else
        if [[ ! -d $ODIR ]]; then
            echo "$ODIR already exists but is not a directory"
            exit 1
        fi
    fi

    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    command -v minimap2 >/dev/null 2>&1 || { echo >&2 "minimap2: not installed"; exit 1; }
    command -v flye >/dev/null 2>&1 || { echo >&2 "flye: not installed"; exit 1; }
    command -v makeblastdb >/dev/null 2>&1 || { echo >&2 "makeblastdb: not installed"; exit 1; }
    command -v tblastn >/dev/null 2>&1 || { echo >&2 "tblastn: not installed"; exit 1; }
    command -v bedtools >/dev/null 2>&1 || { echo >&2 "bedtools: not installed"; exit 1; }
    command -v kmerfreq >/dev/null 2>&1 || { echo >&2 "kmerfreq: not installed"; exit 1; }
    command -v gce >/dev/null 2>&1 || { echo >&2 "gce: not installed"; exit 1; }
    command -v prefetch >/dev/null 2>&1 || { echo >&2 "prefetch: not installed"; exit 1; }
    command -v jellyfish >/dev/null 2>&1 || { echo >&2 "jellyfish: not installed"; exit 1; }

    if [[ -n $NO_REDUCTION_READS ]]; then
        echo "DATA: no reduction of reads or --no-reduction-reads"
        return 0
    fi

    if [[ -n $LR3K ]]; then
        echo "DATA: $LR3K is used for 3K long-read data"
        return 0
    fi

    if [[ -s n3k.fq.gz ]]; then
        LR3K=n3k.fq.gz
        echo "DATA: n3k.fq.gz is found."
        return 0
    fi

    if [[ -s n.fq.gz ]]; then
        LR=n.fq.gz
        echo "DATA: n.fq.gz is found."
        return 0
    fi

    if [[ -n $SRALONG ]]; then
        LR=$SRALONG.fastq
        if [[ ! -s $SRALONG.fastq ]]; then
            ncbitools fetch sra "$SRALONG"
        fi
        [[ -s $LR ]] && echo "INFO: long-read data: $LR"
        SR1=${SRASHORT}_1.fastq
        SR2=${SRASHORT}_2.fastq
        if [[ ! -s ${SRASHORT}_1.fastq ]]; then
            ncbitools fetch sra "$SRASHORT"
        fi
        [[ -s $SR1 ]] && echo "INFO: short-read data: $SR1"
        [[ -s $SR2 ]] && echo "INFO: short-read data: $SR2"
    fi

    if test -z "$LR"; then
        echoerr "ERROR: No long read data set!"
        exit 1
    fi
    if test -z "$SR1"; then
        echoerr "ERROR: No short read data set!"
        exit 1
    fi

    if [[ ! -s $ODIR/long_total_length.txt ]]; then
        seqkit stats -Ta "$LR" | csvtk cut -t -f "sum_len" | csvtk del-header > "$ODIR"/long_total_length.txt
    fi
    LONG_TOTAL_LENGTH=$(cat "$ODIR"/long_total_length.txt)
    echo "DATA: long reads total (bases): $LONG_TOTAL_LENGTH"

    if [[ ! -s "$ODIR"/19mer_out.histo ]]; then
        jellyfish count -t "$NT" -C -m 19 -s 5G -o "$ODIR"/19mer_out --min-qual-char=? "$SR1" "$SR2"
        jellyfish histo -o "$ODIR"/19mer_out.histo "$ODIR"/19mer_out
    fi
    "$WDIR"/run-polap-jellyfish.R "$ODIR"/19mer_out.histo "$LONG_TOTAL_LENGTH" "$ODIR"/long_coverage.txt "$ODIR"/short_expected_genome_size.txt
    EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
    EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
    EXPECTED_COVERAGE=$(cat "$ODIR"/long_coverage.txt)
    EXPECTED_COVERAGE=${EXPECTED_COVERAGE%.*}
    echo "DATA: short reads expected genome size (bases): $EXPECTED_GENOME_SIZE"
    echo "DATA: long reads expected coverage: $EXPECTED_COVERAGE x"

    if [ "$EXPECTED_COVERAGE" -lt 30 ]; then
        echo "INFO: No reduction of the long-read data"
    else
        RATE=$(echo "scale=3; 30/$EXPECTED_COVERAGE" | bc)
        echo "DATA: long-read data reduction by rate of $RATE"
        seqkit sample -p "$RATE" "$LR" -o n.fq.gz
        echo "DATA: a reduced long-read data n.fq.gz is created"
        LR=n.fq.gz
    fi
    echo "DEBUG: end of step0"
}

# STEP: 
# library(dplyr)
# x = as_tibble(read.table("o/assembly_info.txt"))
function astep1() {
    cat >&2 <<EOM
After step1:
excucte R, then type in the following two lines.
library(dplyr)
EOM
    if [[ -s $ODIR/assembly_info.txt ]]; then
        echoerr "x = as_tibble(read.table(\"${ODIR}/assembly_info.txt\"))"
    else
        echoerr "x = as_tibble(read.table(\"${ODIR}/30-contigger/contigs_stats.txt\"))"
    fi
}

function astep2() {
    cat >&2 <<EOM
Step2: run R and
out="${ODIR}"
source("$WDIR/run-polap-sum.R")
then type in z, z.1, z.v
z %>% arrange(V6) :for annotated contigs by multiplicity order
z %>% arrange(mt<pt) :for annotated contigs by mt/pt gene counts
z.1 %>% arrange(V6) %>% print(n=1000) :for all contigs
For Step3: to check mt or pt genes in the contigs.
run:
polap -3
to find the number for the next step 4.
Use the following code to create a contig name file for step 4
  V6 is copy number, and V3 is the length of a contig
Play with filter to select contigs you want to continue with step 4
replace the number at the end of the output file or mt.contig-name-1
  with the number you get from polap -3 command
z %>% filter(V6<3000,V6>2,V2>1000) %>% select(V1) %>% write.table("o/50-annotation/mt.contig.name-1",row.names=F,col.names=F,quote=F)
EOM
}

# STEP 1: flye whole-genome assembly
# -l or -k is required
# -l is given, then reads longer than 3kbp are prepared.
function step1() {
    echo "DEBGU: start of step1"
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    command -v flye >/dev/null 2>&1 || { echo >&2 "flye: not installed"; exit 1; }

    if test -z "$LR"; then
        if test -z "$LR3K"; then 
            echo ERROR: No long-read data
            exit 1
        else
            echo INFO: Long read data: "$LR3K" should have reads longer than 3000 bp
            [[ -s $LR3K ]] && echo "DATA: $LR3K is used for the first round of flye."
        fi
    else
        if test -z "$LR3K"; then 
            LR3K=n3k.fq.gz
            if [[ -s $LR ]]; then
                seqkit seq --quiet -m "$MR" --threads 4 "$LR" -o $LR3K > /dev/null 2>&1
            else
                echoerr "ERROR: no data file found - $LR"
                exit 1
            fi
            echo "DATA: long-read minimum 3kb reads data $LR3K is created"
        else
            echo INFO: long read data: "$LR"
            echo INFO: long read data: "$LR3K" should have reads longer than 3000 bp
        fi
    fi

    if [[ -s $ODIR/assembly_info.txt ]]; then
        echoall "INFO: assembly graph already exists: $(realpath $ODIR/assembly_graph.gfa)"
        echoall "INFO: skip the step 4 of the second round of flye"
        return 0
    fi

    if [[ $FLYE_CONTIGGER == "--contigger" ]]; then
        if [[ -s $ODIR/30-contigger/graph_final.gfa ]]; then
            echoall "INFO: assembly graph already exists: $(realpath $ODIR/30-contigger/graph_final.gfa)"
            echoall "INFO: skip the step 4 of the second round of flye"
            return 0
        fi
    fi

    if [[ -s o/short_expected_genome_size.txt ]]; then
        if [[ $ODIR == "o" ]]; then
            echo "DEBUG: $ODIR == o"
        else
            cp o/short_expected_genome_size.txt "$ODIR"/short_expected_genome_size.txt
        fi
    else
        echo "ERROR: no genome size estimate"
        exit 1
    fi

    EXPECTED_GENOME_SIZE=$(cat "$ODIR"/short_expected_genome_size.txt)
    EXPECTED_GENOME_SIZE=${EXPECTED_GENOME_SIZE%.*}
    
    echo "Step 1: flye whole-genome assembly on the folder: $ODIR"
    if [ -z $RESUME ]; then
        if [[ $FLYE_CONTIGGER == "--contigger" ]]; then
            flye --nano-raw "$LR3K" --out-dir "$ODIR" \
                --threads "$NT" \
                --stop-after contigger \
                --asm-coverage 30 \
                --genome-size "$EXPECTED_GENOME_SIZE" \
                > /dev/null 2>&1
        else
            flye --nano-raw "$LR3K" --out-dir "$ODIR" \
                --threads "$NT" \
                --asm-coverage 30 \
                --genome-size "$EXPECTED_GENOME_SIZE" \
                > /dev/null 2>&1
        fi
    else
        echo "Step 1: resumming from the previous run on the folder: $ODIR"
        if [[ $FLYE_CONTIGGER == "--contigger" ]]; then
            flye --nano-raw "$LR3K" --out-dir "$ODIR" \
                --threads "$NT" \
                --stop-after contigger \
                --asm-coverage 30 \
                --genome-size "$EXPECTED_GENOME_SIZE" \
                --resume \
                > /dev/null 2>&1
        else
            flye --nano-raw "$LR3K" --out-dir "$ODIR" \
                --threads "$NT" \
                --asm-coverage 30 \
                --genome-size "$EXPECTED_GENOME_SIZE" \
                --resume \
                > /dev/null 2>&1
        fi
    fi

    [[ $MULTISTEP -eq 0 ]] && astep1
    if [[ -s $ODIR/assembly_info.txt ]]; then
        echoall "INFO: assembly graph: $(realpath $ODIR/assembly_graph.gfa)"
    else
        echoall "INFO: assembly graph: $(realpath $ODIR/30-contigger/graph_final.gfa)"
    fi

    echo "DEBUG: end of step1"
}

# STEP 2: organelle gene annotation
# select contigs by length and annotate them for 
# mt or pt genes.
function step2() {
    echo "DEBUG: start of step2"
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    command -v makeblastdb >/dev/null 2>&1 || { echo >&2 "makeblastdb: not installed"; exit 1; }
    command -v tblastn >/dev/null 2>&1 || { echo >&2 "tblastn: not installed"; exit 1; }
    command -v bedtools >/dev/null 2>&1 || { echo >&2 "bedtools: not installed"; exit 1; }

    echo Step 2: organelle gene annotation ...
    if [[ -s $ODIR/assembly_info.txt ]]; then
        "$WDIR"/run-polap-annotation "$ODIR" $NT $ALL_ANNOTATE
    else
        FLYE_CONTIGGER="--contigger"
        "$WDIR"/run-polap-annotation "$ODIR" $NT $ALL_ANNOTATE $FLYE_CONTIGGER
    fi
    if [ $? -ne 0 ]; then
        echo "ERROR: run-polap-annotation $ODIR $NT"
    fi

    if [[ $MULTISTEP -eq 0 ]]; then
        astep2
        if [[ -s $ODIR/assembly_info.txt ]]; then
            echoall "INFO: assembly graph: $(realpath $ODIR/assembly_graph.gfa)"
        else
            echoall "INFO: assembly graph: $(realpath $ODIR/30-contigger/graph_final.gfa)"
        fi
    fi

    echo "DEBUG: end of step2"
}

# STEP 3: organelle contigs selection 
function step3() {
    echo "DEBUG: start of step3"
    [[ $MULTISTEP -eq 0 ]] && bstep4

    FLYEDIR=$ODIR
    CONTIGNAME=${ODIR}/50-annotation/mt.contig.name
    LOG=$ODIR/assembly_info_organelle_annotation_count.txt
    echo "Step 3: mtDNA contig candidates selection"
    if [[ -s $ODIR/assembly_info.txt ]]; then
        FLYE_CONTIGGER="--polishing"
        "$WDIR"/run-polap-mtcontig.R "$FLYEDIR" "$CONTIGNAME" "$LOG" "$FLYE_CONTIGGER" > /dev/null 2>&1
    else
        FLYE_CONTIGGER="--contigger"
        "$WDIR"/run-polap-mtcontig.R "$FLYEDIR" "$CONTIGNAME" "$LOG" "$FLYE_CONTIGGER" > /dev/null 2>&1
    fi

    echoall "INFO: $CONTIGNAME-1 for mtDNA contig candidates"
    echoall "INFO: $CONTIGNAME-2 for ptDNA contig candidates"
    echoall "INFO: annotation: column -t $LOG"
    echo "DEBUG: end of step3"
}

function bstep4() {
    echoerr "Before Step 4:"
    for i in {1..9}; do 
        if ! test -s "$ODIR"/50-annotation/mt.contig.name-"$i"; then
    cat >&2 <<EOM
Next 60-mt trial number is $i
Execute R:
out="${ODIR}"
source("$WDIR/run-polap-sum.R")
z %>% select(V1) %>% write.table("${ODIR}/50-annotation/mt.contig.name-$i",row.names=F,col.names=F,quote=F)
Then execute:
polap -4 $i -o $ODIR -k <n3k-longread fastq>
EOM
            break
        fi
    done
}

function ask_yes_or_no() {
    read -p "$1 ([y]es or [N]o): "
    case $(echo $REPLY | tr '[A-Z]' '[a-z]') in
        y|yes) echo "yes" ;;
        *)     echo "no" ;;
    esac
}

# STEP 4: flye organelle genome assembly
# LR3K=ccapn3k.fq.gz
function step4() {
    echo "DEBUG: start of step4"
    [[ $MULTISTEP -eq 0 ]] && version_print
    MULTISTEP=1
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    command -v minimap2 >/dev/null 2>&1 || { echo >&2 "minimap2: not installed"; exit 1; }
    command -v csvtk >/dev/null 2>&1 || { echo >&2 "csvtk: not installed"; exit 1; }

    ADIR=$ODIR/50-annotation
    MTDIR=$ODIR/60-mt-$STEP4

    if [[ -z $POLAP_SKIP ]]; then
        if [[ -d $MTDIR ]]; then
            if [[ "no" == $(ask_yes_or_no "Do you want to delete the previous run [$MTDIR]?") ]]; then
                echo "Okay!"
                exit 0
            fi
            rm -rf "$MTDIR"
        fi
        mkdir "$MTDIR"
    fi

    if test -z "$LR3K"; then 
        LR3K=n3k.fq.gz
        if [[ ! -s $LR3K ]]; then
            echo ERROR: No 3K long-read data!
            exit 1
        fi
    fi

    if [[ $USE_EDGES == "--use-edges" ]]; then
        if [[ -s $ODIR/assembly_info.txt ]]; then
            echo "ERROR: not implemented yet"
            exit 1
            # ASSEMBLY_FASTA=$ODIR/assembly.fasta # graph_final.fasta ?
        else
            ASSEMBLY_FASTA=$ODIR/30-contigger/graph_final.fasta
        fi
        echo "INFO: use edges not contigs: $ASSEMBLY_FASTA"
    else
        if [[ -s $ODIR/assembly_info.txt ]]; then
            ASSEMBLY_FASTA=$ODIR/assembly.fasta
        else
            ASSEMBLY_FASTA=$ODIR/30-contigger/contigs.fasta
        fi
    fi
    echo "Step 4: flye organelle genome assembly on the folder: $MTDIR"

    if [[ ! -s "$MTDIR/1.fq.gz" ]]; then
        echo "INFO: organelle contigs selection"
        if [[ -s $ADIR/mt.contig-$STEP4.fa ]]; then
            cat $ADIR/mt.contig-$STEP4.fa $ASSEMBLY_FASTA > $ODIR/assembly_ring.fa
            seqkit grep -f $ADIR/mt.contig.name-$STEP4 $ODIR/assembly_ring.fa -o $MTDIR/contig.fa > /dev/null 2>&1
        else
            seqkit grep -f $ADIR/mt.contig.name-$STEP4 $ASSEMBLY_FASTA -o $MTDIR/contig.fa > /dev/null 2>&1
        fi
        CONTIG_LENGTH=$(seqkit stats -Ta $MTDIR/contig.fa | csvtk cut -t -f "sum_len" | csvtk del-header)
        echo "DATA: $LR3K is used to select reads"
        if [[ ! -s "$MTDIR/contig.paf" ]]; then
            minimap2 -cx map-ont "$MTDIR"/contig.fa "$LR3K" -t "$NT" -o "$MTDIR"/contig.paf > /dev/null 2>&1
        fi
        echo "DATA: mininmum length of long reads in the selection mapping: $MR"
        cut -f1-11 "$MTDIR"/contig.paf | awk -v minlength=$MR '{if ($2>=minlength) {print}}' > "$MTDIR"/contig.tab


        echo "INFO: organelle read selection min length: $SINGLE_MIN bp"
        contig_count=$(wc -l < $ADIR/mt.contig.name-$STEP4)
        if [ "$contig_count" -gt 1 ]; then
            # "$WDIR"/run-polap-pairs.R $ADIR/mt.contig.name-$STEP4 $MTDIR/contig.tab $MTDIR $PAIR_MIN $SINGLE_MIN > /dev/null 2>&1
            "$WDIR"/run-polap-pairs.R $ADIR/mt.contig.name-$STEP4 $MTDIR/contig.tab $MTDIR $SINGLE_MIN $SINGLE_MIN > /dev/null 2>&1
            cat $MTDIR/*.name $MTDIR/single.names | sort | uniq > $MTDIR/1.names
        else
            "$WDIR"/run-polap-single.R $MTDIR/contig.tab $MTDIR $SINGLE_MIN > /dev/null 2>&1
            cat $MTDIR/single.names | sort | uniq > $MTDIR/1.names
        fi
        seqkit grep -f $MTDIR/1.names $LR3K -o $MTDIR/1.fq.gz > /dev/null 2>&1
        echo "DATA: organelle reads in $MTDIR/1.fq.gz"
    fi

    # target coverage: 50
    # total length of the data: X
    # expected mtDNA length: Y = sum of the selected contigs
    # X/Y = expected coverage
    # if target coverage > the expected coverage
    #   do the flye assembly
    # else
    #   sample reads so that 
    #     the expected coverage goes down to the target coverage
    # fi
    TOTAL_LENGTH=$(seqkit stats -Ta $MTDIR/1.fq.gz | csvtk cut -t -f "sum_len" | csvtk del-header)
    EXPECTED_COVERAGE=$((TOTAL_LENGTH / CONTIG_LENGTH))
    echo "INFO: organelle genome size based on contig selection: $CONTIG_LENGTH"
    echo "INFO: expected coverage: $EXPECTED_COVERAGE x"
    if [[ -z $NO_COVERAGE_CHECK ]]; then

        if [ "$EXPECTED_COVERAGE" -lt $COV ]; then
            echo "DATA: no data reduction: COV=$COV"
            ln -s 1.fq.gz $MTDIR/2.fq.gz
        else
            RATE=$(echo "scale=10; $COV/$EXPECTED_COVERAGE" | bc)
            echo "DATA: data reduction by rate of $RATE"
            seqkit sample -p $RATE $MTDIR/1.fq.gz -o $MTDIR/2.fq.gz 
        fi

        if [ -z $RESUME ]; then     
            flye --nano-raw $MTDIR/2.fq.gz --out-dir $MTDIR/o \
                --asm-coverage 30 \
                --genome-size $CONTIG_LENGTH \
                --threads $NT > /dev/null 2>&1
        else
            flye --nano-raw $MTDIR/2.fq.gz --out-dir $MTDIR/o \
                --asm-coverage 30 \
                --genome-size $CONTIG_LENGTH \
                --threads $NT --resume > /dev/null 2>&1
        fi
    else
        echo "DATA: no reduction in the final flye run"
        if [ -z $RESUME ]; then     
            flye --nano-raw $MTDIR/1.fq.gz --out-dir $MTDIR/o \
                --threads $NT > /dev/null 2>&1
        else
            flye --nano-raw $MTDIR/1.fq.gz --out-dir $MTDIR/o \
                --threads $NT --resume > /dev/null 2>&1
        fi
    fi

    ODIR=$MTDIR/o
    if [[ -s $ODIR/assembly_info.txt ]]; then
        echoall "INFO: assembly graph: $(realpath $ODIR/assembly_graph.gfa)"
    else
        echoall "INFO: assembly graph: $(realpath $ODIR/30-contigger/graph_final.gfa)"
    fi
    ALL_ANNOTATE="--all-annotate"
    # FLYE_CONTIGGER="--polishing" # does not matter
    step2
    step3

    echo "DEBUG: end of step4"
}

# STEP 5: organelle genome candidate validation
# samtools coverage
# 
# bio conda environment
function step5() {
    command -v minimap2 >/dev/null 2>&1 || { echo >&2 "minimap2: not installed"; exit 1; }
    command -v samtools >/dev/null 2>&1 || { echo >&2 "samtools: not installed"; exit 1; }

    # minimap2 -ax map-ont $FA $LR3K -o 1.sam
    # samtools view -u .1.to.cpsen3k.sam | samtools sort -o cpseudochinensis.mt1.1.to.cpsen3k.bam
    # samtools coverage -A -w 32 cpseudochinensis.mt1.1.to.cpsen3k.bam

    minimap2 -ax map-ont $FA $LR3K \
      | samtools view -u | samtools sort -o 1.bam
    samtools coverage -A -w 32 1.bam
    
    echo Change your conda environment before performing STEP 6.
}

# STEP 6: polishing
#
# py2 conda environment
# 
function step6() {
    command -v msbwt >/dev/null 2>&1 || { echo >&2 "msbwt: not installed"; exit 1; }
    command -v ropebwt2 >/dev/null 2>&1 || { echo >&2 "ropebwt2: not installed"; exit 1; }
    
	if [[ $SR1 = *.fastq || $SR1 = *.fq ]];then
        cat $SR1 $SR2 \
            | awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN \
            | msbwt convert $ODIR/msbwt
	elif [[ $SR1 = *.fq.gz || $SR1 = *.fastq.gz ]];then
        zcat $SR1 $SR2 \
            | awk 'NR % 4 == 2' | sort | tr NT TN | ropebwt2 -LR | tr NT TN \
            | msbwt convert $ODIR/msbwt
    fi
}

function step7() {
    fmlrc -p $NT $ODIR/msbwt/comp_msbwt.npy $PA $FA
}

# filter subcommand
filter__main() {
    while getopts "he:k:o:" option; do
        case $option in
            e) FA=$OPTARG;;
            k) LR3K=$OPTARG;;
            o) ODIR=$OPTARG;;
            h) # display Help
                usage
                ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    PER=0.9
    FDIR=$ODIR/70-filter
    mkdir -p $FDIR
    if [[ ! -s $FDIR/excluder.paf ]];then
        minimap2 -c -t $NT -x map-ont $FA $LR3K -o $FDIR/excluder.paf 2>/dev/null
    fi

    if [[ ! -s $FDIR/excluder.name ]]; then
        awk '{print $1, $2, ($4-$3)/$2}' $FDIR/excluder.paf > $FDIR/excluder_1.paf
        awk -v per=$PER '{if ($3>=per) {print}}' $FDIR/excluder_1.paf > $FDIR/excluder_2.paf
        awk '{print $1}' $FDIR/excluder_2.paf > $FDIR/excluder.name
        seqkit grep -v -f $FDIR/excluder.name $LR3K -o $FDIR/excluder.fq.gz
    fi

    if [[ ! -s $FDIR/o/assembly_info.txt ]]; then
        flye --nano-raw $FDIR/excluder.fq.gz --out-dir $FDIR/o --threads $NT > /dev/null 2>&1
    fi
}

filter() {
  local cmdname=$1; shift
  if type "filter__$cmdname" >/dev/null 2>&1; then
    "filter__$cmdname" "$@"
  fi
  exit 0
}


function ncbi() {
  local cmdname=$1; shift
  if type "ncbi__$cmdname" >/dev/null 2>&1; then
    "ncbi__$cmdname" "$@"
  fi
  exit 0
}


function ncbi_command_parse() {
    BIOPRJ=""
    SPECIES=""
    SRA=""
    while getopts "b:s:r:" option; do
        case $option in
            b) BIOPRJ=$OPTARG ;;
            s) SPECIES=$OPTARG ;;
            r) SRA=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done
}

function ncbi__bioproject {
    ncbi_command_parse "$@"
    esearch -db bioproject -query "$BIOPRJ" | elink -target sra | efetch -format runinfo > "$BIOPRJ".txt
    echo "cat $BIOPRJ.txt | csvtk cut -f Run,bases,LibraryName,LibraryStrategy,LibrarySource,LibraryLayout,Platform,ScientificName | csvtk pretty | less -S" 1>&2
}

function ncbi__sra {
    ncbi_command_parse "$@"
    # esearch -db sra -query $SRA | efetch -format runinfo | csvtk cut -f BioProject | csvtk del-header
    esearch -db sra -query "$SRA" | efetch -format runinfo > "$SRA".txt
    echo "use: csvtk cut -f BioProject | csvtk del-header" 1>&2
}

function ncbi__tax {
    ncbi_command_parse "$@"
    esearch -db bioproject -query "$BIOPRJ" | elink -target biosample | elink -target taxonomy | efetch -format native > "$BIOPRJ".taxonomy
}

function ncbi__mtdna {
    ncbi_command_parse "$@"
    esearch -db nuccore -query "(mitochondrion[Title] AND complete[Title] AND genome[Title]) AND ${SPECIES}[Organism]" | efetch -format gb > "$SPECIES".mt.gb
}

function ncbi__ptdna {
    ncbi_command_parse "$@"
    esearch -db nuccore -query "(chloroplast[Title] AND complete[Title] AND genome[Title]) AND ${SPECIES}[Organism]" | efetch -format gb > "$SPECIES".pt.gb
}

function ncbi__cpdna {
    ncbi__ptdna "$@"
}

function aflye() {
  local cmdname=$1; shift
  if type "aflye__$cmdname" >/dev/null 2>&1; then
    "aflye__$cmdname" "$@"
  fi
}


function aflye_command_parse() {
    ODIR=o
    N=1
    CONTIGNAME=""
    FASTANAME=""
    BACKUP="species"
    while getopts "o:n:c:f:b:" option; do
        case $option in
            o) ODIR=$OPTARG ;;
            n) N=$OPTARG ;;
            c) CONTIGNAME=$OPTARG ;;
            f) FASTANAME=$OPTARG ;;
            b) BACKUP=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done


}


function aflye__info() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    cat $ODIR/60-mt-$N/o/assembly_info.txt
}

function aflye__annotation() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    column -t o/assembly_info_organelle_annotation_count.txt 1>&2
    # $ column -t o/60-mt-1/o/assembly_info_organelle_annotation_count.txt
}

function aflye__mtseed() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    echo "file:o/50-annotation/mt.contig.name-$N" 1>&2
    cat o/50-annotation/mt.contig.name-$N 1>&2
}


function aflye__bandage() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    if [[ -s $ODIR/assembly_graph.gfa ]]; then
        echo "Whole genome assemble graph:"
        realpath $ODIR/assembly_graph.gfa
    fi
    if [[ -s $ODIR/60-mt-$N/o/assembly_graph.gfa ]]; then
        echo "mtDNA genome assemble graph at [$ODIR/60-mt-$N/o]:"
        realpath $ODIR/60-mt-$N/o/assembly_graph.gfa
    fi
}

function aflye__check-edge () {
    # local cmdname=$1; shift
    echo "DEBUG: aflye check-edge start"
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    grep $CONTIGNAME "$ODIR"/30-contigger/contigs_stats.txt
    echo "DEBUG: aflye check-edge end"
}

# polap aflye seq -p contig_1 -f species.mt.0.fa
function aflye__seq() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    aflye_command_parse "$@"
    
    if [[ $N -eq 0 ]]; then
        seqkit grep -n -p $CONTIGNAME $ODIR/assembly.fasta -o $FASTANAME
    else
        seqkit grep -n -p $CONTIGNAME $ODIR/60-mt-$N/o/assembly.fasta -o $FASTANAME
    fi
}





function aflye__backup() {
    aflye_command_parse "$@"

    # shift $((OPTIND - 1))
    # msd_file=$1
    # echo $msd_file
    # echo $BACKUP
    # return 0

    BACKUPDIR=$BACKUP
    BACKUPODIR=$BACKUP/o
    mkdir -p "$BACKUPODIR"/30-contigger
    mkdir -p "$BACKUPODIR"/50-annotation
    mkdir -p "$BACKUPODIR"/60-mt-1/o
    cp "$ODIR"/30-contigger/contigs.fasta "$BACKUPODIR"/30-contigger
    cp "$ODIR"/30-contigger/contigs_stats.txt "$BACKUPODIR"/30-contigger
    cp "$ODIR"/30-contigger/graph_final.* "$BACKUPODIR"/30-contigger
    cp "$ODIR"/50-annotation/mt.contig.name-* "$BACKUPODIR"/50-annotation
    cp "$ODIR"/50-annotation/mt.gene.count "$BACKUPODIR"/50-annotation
    cp "$ODIR"/50-annotation/pt.gene.count "$BACKUPODIR"/50-annotation
    cp "$ODIR"/60-mt-1/1.names "$BACKUPODIR"/60-mt-1/
    cp "$ODIR"/60-mt-1/o/assembly.fasta "$BACKUPODIR"/60-mt-1/o
    cp "$ODIR"/60-mt-1/o/assembly_graph.gfa "$BACKUPODIR"/60-mt-1/o
    cp "$ODIR"/60-mt-1/o/assembly_info.txt "$BACKUPODIR"/60-mt-1/o
    cp "$ODIR"/60-mt-1/o/assembly_info_organelle_annotation_count.txt "$BACKUPODIR"/60-mt-1/o
    if [[ -s $ODIR/assembly.fasta ]]; then
        cp "$ODIR"/assembly.fasta "$BACKUPODIR"
        cp "$ODIR"/assembly_graph.gfa "$BACKUPODIR"
        cp "$ODIR"/assembly_info.txt "$BACKUPODIR"
    fi
    cp "$ODIR"/19mer_out.histo "$BACKUPODIR"
    cp "$ODIR"/*.txt "$BACKUPODIR"
    [[ -s "$ODIR"/../mt.0.fa ]] && cp "$ODIR"/../mt*fa "$BACKUPDIR"
    [[ -s "$ODIR"/../mt1.0.fa ]] && cp "$ODIR"/../mt*fa "$BACKUPDIR"
    [[ -s "$ODIR"/../x.aln ]] && cp "$ODIR"/../x.aln "$BACKUPDIR"
    cp "$ODIR"/../README "$BACKUPDIR"
    cp "$ODIR"/../polap.log "$BACKUPDIR"
    tar zcf "$BACKUP".tar.gz "$BACKUPDIR"
    rm -rf "$BACKUPDIR"
}

function aflye__recovery() {
    aflye_command_parse "$@"
    BACKUPDIR=${BACKUP%.tar.gz}
    tar zxf "$BACKUP"
}

function compare () {
    local query=$1; shift
    local subject=$1; shift
    command -v blastn >/dev/null 2>&1 || { echo >&2 "blastn: not installed"; exit 1; }

    blastn -query $query -subject $subject > $query.$subject.txt
}

function rearrange() {
    local POS=$1; shift
    local IN=$1; shift
    local OUT=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    POSP=$((POS - 1))

    seqkit subseq -r 1:$POSP $IN -o 1.fa
    seqkit subseq -r $POS:-1 $IN -o 2.fa
    seqkit concat 2.fa 1.fa -o $OUT
    rm 1.fa 2.fa
}

function clustal () {
    if [[ -s x.aln ]]; then
        echoall "INFO: clustalw alignemnt is found."
    else
        local MT1=$1; shift
        local MT2=$1; shift
        command -v clustalw2 >/dev/null 2>&1 || { echo >&2 "clustalw2: not installed"; exit 1; }
        cat $MT1 $MT2 > x.fa
        clustalw2 x.fa
    fi
    # TODO: works for only Linux.
    GAP1=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
    GAP2=$(sed -n '5~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | tr -dc '-' | wc -c)
    MATCH=$(sed -n '6~4p' x.aln | tr -dc '*' | wc -c)
    TOTAL=$(sed -n '4~4p' x.aln | tr -s ' ' | cut -d' ' -f2 | tr -d '\n' | wc -c)
    GAP=$((GAP1 + GAP2))
    MISMATCH=$((TOTAL - MATCH - GAP))
    echoall "INFO: pairwise alignment:   length: $TOTAL"
    echoall "INFO: pairwise alignment:    match: $MATCH"
    echoall "INFO: pairwise alignment: mismatch: $MISMATCH"
    echoall "INFO: pairwise alignment:     gaps: $GAP"
}


function of() {
  local cmdname=$1; shift
  if type "of__$cmdname" >/dev/null 2>&1; then
    "of__$cmdname" "$@"
  fi
  exit 0
}


function of_command_parse() {
    # local cmdname=$1; shift

# sequence alignment with orthofinder and muscle
ODIR=of
FASTA=""
SPECIES=species.of
GENE=species.gene        # gene-to-remove.txt
ALLFASTA="a.fa.1"        # a.fa.1
FILTERFASTA="a.fa"       # a.fa
N=2
LOCUS=""

    while getopts "a:b:s:g:f:o:n:l:" option; do
        case $option in
            a) ALLFASTA=$OPTARG ;;
            b) FILTERFASTA=$OPTARG ;;
            s) SPECIES=$OPTARG ;;
            g) GENE=$OPTARG ;;
            f) FASTA=$OPTARG ;;
            o) ODIR=$OPTARG ;;
            n) N=$OPTARG ;;
            l) LOCUS=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done
}

# polap of -a a.fa.1 -b a.fa -s species.of -g gene-to-remove.txt -f cpseudochinensis.mt.1.faa -o of
function of__prepare() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }

    of_command_parse "$@"

    rm -rf $ODIR
    mkdir $ODIR

    if [ -s $GENE ]; then
        seqkit grep -v -f $GENE $ALLFASTA > $FILTERFASTA
    else
        cp $ALLFASTA $FILTERFASTA
    fi
    while read -r g; do seqkit grep -r -p "l/|$g" $FILTERFASTA -o "of/$g.fa"; done < $SPECIES


    # cp $FASTA $ODIR/target.fa
    # orthofinder -f $ODIR

    echo "Check: $ODIR for amino acid sequences"
    echo "less $ODIR/*.fa"    
}


function of__run() {
    # local cmdname=$1; shift
    command -v seqkit >/dev/null 2>&1 || { echo >&2 "seqkit: not installed"; exit 1; }
    command -v orthofinder >/dev/null 2>&1 || { echo >&2 "orthofinder: not installed"; exit 1; }

    of_command_parse "$@"
    of__prepare "$@"

    # cp $FASTA $ODIR/target.fa
    orthofinder -f "$ODIR"

    echo "Check: $ODIR for orthofinder"
    echo "find . -name Orthogroups.GeneCount.tsv | xargs open"    
}

# redoof -n 60
function of__align() {
    # local cmdname=$1; shift

    of_command_parse "$@"

    rm -rf "$ODIR"/d 
    rm -rf "$ODIR"/i
    mkdir -p "$ODIR"/d
    mkdir -p "$ODIR"/i
    for ((i=0; i <= N; i++)); do
        printf -v j "%07d" $i
        cp "$(find $ODIR -name Orthogroup_Sequences)"/OG"${j}".fa "$ODIR"/d;
    done

    for i in $ODIR/d/*.fa; do muscle -quiet -align $i -output $ODIR/i/$(basename ${i%.fa}.afa); done

    echo "Check: $ODIR/i for alignment"
    echo "find . -name Orthogroups.GeneCount.tsv | xargs open"
}

# polap refine -a a.fa.1 -b a.fa -s species.of -g gene-to-remove.txt -f cpseudochinensis.mt.1.faa -o of -n 33
# of/d
# of/i
# polap of refine -a a.fa.1 -b a.fa -s species.of -g gene-to-remove.txt -f cpseudochinensis.mt.1.faa -o of -n 2
function of__refine() {
    # local cmdname=$1; shift

    of_command_parse "$@"
    of__run "$@"
    of__align "$@"

    echo "Check: $ODIR/i for alignment"
    echo "find . -name Orthogroups.GeneCount.tsv | xargs open"
    exit 0
}



function geseq() {
    echo "input: GeSeq gff3"
    echo "output: gff3 for NCBI Genome Workbench"

    sed -i 's/1\tI/0\tI/' ccapricornis-20230702-142430_chr1_GFF3.gff3
    # genome workbench
cat job-results-202372572651/ccapricornis-20230702-142430_chr1_GFF3.gff3 | dos2unix | grep -v Chloe | sed 's/1\tI/0\tI/' > ccapricornis.cp.1.gff
cat job-results-202372572651/claticeps-20230702-142505_chr1_GFF3.gff3 | dos2unix | grep -v Chloe | grep -v OGDRAW | sed 's/1\tI/0\tI/' > claticeps.cp.1.gff
}

# polap iq -n 33 -g of -l SWU240720_cds-blatx
function iq() {

    # LOCUS=SWU240720_cds-blatx
    ODIR=phylogenies
    OG="of"
    N=1
    LOCUS=""
    while getopts "l:g:o:n:" option; do
        case $option in
            l) LOCUS=$OPTARG ;;
            g) OG=$OPTARG ;;
            o) ODIR=$OPTARG ;;
            n) N=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    rm -rf "$ODIR"
    mkdir -p "$ODIR"/d
    mkdir -p "$ODIR"/i
    for ((i=0; i <= N; i++)); do
        printf -v j "%07d" $i
        cp "$(find $OG -name Orthogroup_Sequences)"/OG"${j}".fa "$ODIR"/d;
    done

    
    # for i in $ODIR/d/*.fa; do 
    #     sed -i -e "s/$LOCUS/target/" $i
    # done

    for i in $ODIR/d/*.fa; do 
        # cat $i | perl -pe's/l\|([A-Za-z0-9]+)\.\d+_(\S+)/>$1/' | perl -pe's/>(target)_\S+/>$1/' > ${i%.fa}.fa1; 
        cat $i | perl -pe's/^>[a-z]{3}\|([A-Za-z0-9_]+)\.{1}.+/>$1/' > ${i%.fa}.fa1; 
    done

    for i in $ODIR/d/*.fa1; do seqkit rmdup -n $i -o ${i%.fa1}.faa; done
    for i in $ODIR/d/*.faa; do muscle -quiet -align $i -output ${i%.faa}.afa; done
    mkdir -p $ODIR/s
    cp $ODIR/d/*.afa $ODIR/s
    iqtree -p $ODIR/s -T AUTO -B 1000
}

# polap genes -g of 
function genes () {
    OG="of"
    SPECIES=species.of
    while getopts "s:g:" option; do
        case $option in
            s) SPECIES=$OPTARG ;;
            g) OG=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    MDIR=$(dirname $0)
    "$MDIR"/run-polap-confirm-genes.sh $(find $OG -name N0.tsv)
}

# polap species
function species () {
    SPECIES=species.of
    while getopts "s:" option; do
        case $option in
            s) SPECIES=$OPTARG ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    if [ -s "$SPECIES" ]; then
        while true; do
            read -p "File:$SPECIES exists. Do you want to replace it? " yn
            case $yn in
                [Yy]* ) break;;
                [Nn]* ) exit;;
                * ) echo "Please answer yes or no.";;
            esac
        done
    fi

    MDIR=$(dirname $0)
    while read -r g; do "$MDIR"/ncbitools fetch tax $g; done < "$SPECIES" | cut -d',' -f1 > species.map
    echo "Check: species.map"
}


fail () {
    printf '%s\n' "$1" >&2
    return "${2:-1}"
}

# polap draw -s 1 -o t1.pdf
function draw () {

    # LOCUS=SWU240720_cds-blatx
    ODIR=phylogenies
    OG=""
    N=1

    STEP=0
    T=phylogenies/s.treefile
    PDFFILE="o.pdf"
    NODE=0
    MAP=species.map
    LOCUS=""             # SWU240720
    OUTGROUP=""          # OL347690,MT483944
    GENE=phylogenies/genes.tsv
    ROOT=0
    NODESIZE=0
    while getopts "s:t:p:n:m:l:o:r:g:a" option; do
        case $option in
            s) STEP=$OPTARG ;;
            t) T=$OPTARG ;;
            p) PDFFILE=$OPTARG ;;
            n) NODE=$OPTARG ;;
            m) MAP=$OPTARG ;;
            l) LOCUS=$OPTARG ;;
            o) OUTGROUP=$OPTARG ;;
            r) ROOT=$OPTARG ;;
            g) GENE=$OPTARG ;;
            a) NODESIZE=1 ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    MDIR=$(dirname $0)
    # polap -t phylogenies/s.treefile
    # polap draw -s 1 -p t1.pdf -n 11
    if test "$STEP" -eq 1; then
        if test $NODE -gt 0; then
        echo $NODE
            "$MDIR"/run-polap-draw.R --tree $T --step 1 --pdf $PDFFILE --node $NODE
        else
            "$MDIR"/run-polap-draw.R --tree $T --step 1 --pdf $PDFFILE
        fi
    fi
    

    # polap draw -s 2 -p t3.pdf -r 25 -n 12 -m species.map -t phylogenies/s.treefile -a
    if test "$STEP" -eq 2; then
        if test $NODESIZE -eq 0; then
            "$MDIR"/run-polap-draw.R --pdf $PDFFILE --step $STEP --tree $T --node $NODE --root $ROOT --map $MAP 
        else
            "$MDIR"/run-polap-draw.R --pdf $PDFFILE --step $STEP --tree $T --node $NODE --root $ROOT --map $MAP --nodesize
        fi
    fi
    
    if test "$STEP" -eq 3; then
        "$MDIR"/run-polap-draw.R --pdf $PDFFILE --step $STEP --tree $T --node $NODE --root $ROOT --map $MAP 
# --step 4 --map species.map --tree phylogenies/s.treefile --root 28 --node 11 --genes phylogenies/genes.csv --outgroup OL347690,OQ645347,MT483944 --pdf t2.pdf 
    fi


    # polap draw -s 4 -p tg.pdf -m species.map -g phylogenies/genes.tsv -o OL347690,MT483944 -l SWU240720
    if test "$STEP" -eq 4; then
        test -n "$OUTGROUP" || fail "--outgroup is empty"
        "$MDIR"/run-polap-draw.R --pdf $PDFFILE --step $STEP --map $MAP --genes $GENE --outgroup $OUTGROUP
    fi


    if test "$STEP" -eq 5; then
        "$MDIR"/run-polap-draw.R --pdf $PDFFILE --step $STEP --map $MAP --genes $GENE --outgroup $OUTGROUP --tree $T --node $NODE --root $ROOT
# run-polap-draw.R --map species.map --genes phylogenies/genes.csv --outgroup OL347690,MT483944 --step 5 --pdf t5.pdf --locus SWU240720 --tree phylogenies/s.treefile --root 28 --node 11
    fi

    exit 0
}

# polap assemble -l long.fq.gz
function assemble() {
    echo "DEBUG: assemble - start"
    MULTISTEP=1

    ODIR=o
    FLYE_CONTIGGER="--contigger"

    while getopts "s:l:a:b:o:k:t:rxn" option; do
        case $option in
            s) # SRA=$OPTARG
                set -f # disable glob
                IFS=',' # split on space characters
                SRA=($OPTARG) ;; # use the split+glob operator
            l) LR=$OPTARG ;;
            a) SR1=$OPTARG ;;
            b) SR2=$OPTARG ;;
            o) ODIR=$OPTARG ;;
            k) LR3K=$OPTARG ;;
            t) NT=$OPTARG ;;
            r) RESUME="--resume" ;;
            x) FLYE_CONTIGGER="--polishing" ;;
            n) NO_REDUCTION_READS="--no-reduction-reads" ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    if [[ ${#SRA[@]} -eq 2 ]]; then
        SRALONG=${SRA[0]}
        SRASHORT=${SRA[1]}
    fi

    version_print
    step0
    FLYE_CONTIGGER="--contigger"
    step1
    step2
    STEP4=1
    step3
    ALL_ANNOTATE="--all-annotate"
    FLYE_CONTIGGER="--polishing"
    step4
    echo "DEBUG: assemble - end"
    STEP4=0 # to prevent another step4 in the main
}

# polap assemble -l long.fq.gz
function bflye() {
    echo "DEBUG: bflye - start"
    MULTISTEP=1

    FLYE_CONTIGGER="--contigger"
    ODIR=o

    while getopts "s:l:a:b:o:k:t:rxn" option; do
        case $option in
            s) # SRA=$OPTARG
                set -f # disable glob
                IFS=',' # split on space characters
                SRA=($OPTARG) ;; # use the split+glob operator
            l) LR=$OPTARG ;;
            a) SR1=$OPTARG ;;
            b) SR2=$OPTARG ;;
            o) ODIR=$OPTARG ;;
            k) LR3K=$OPTARG ;;
            t) NT=$OPTARG ;;
            r) RESUME="--resume" ;;
            x) FLYE_CONTIGGER="--polishing" ;;
            n) NO_REDUCTION_READS="--no-reduction-reads" ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    if [[ ${#SRA[@]} -eq 2 ]]; then
        SRALONG=${SRA[0]}
        SRASHORT=${SRA[1]}
    fi

    version_print
    step0
    step1

    echo "DEBUG: bflye - end"
}

function annotate() {
    echo "DEBUG: annotate - start"
    MULTISTEP=1
    ODIR=o
    while getopts "o:t:cy" option; do
        case $option in
            o) ODIR=$OPTARG ;;
            t) NT=$OPTARG ;;
            c) FLYE_CONTIGGER="--contigger" ;;
            y) ALL_ANNOTATE="--all-annotate" ;;
            # h) usage_of ;;
            \?) # incorrect option
                echo "Error: Invalid option; try -h option"
                exit;;
        esac
    done

    version_print
    step2
    STEP4=1
    step3

    echo "DEBUG: annotate - end"
    STEP4=0 # to prevent another step4 in the main
}

function logit() {
    while read
    do
        # echo "$(date) $REPLY" >> ${LOG_FILE}
        # -1 means "current time"
        # printf "[%(%Y-%m-%d %T)T] %s\n" -1 "$REPLY" >> ${LOG_FILE}
        printf "[%s] %s\n" "$(date +"%Y-%m-%d %T")" "$REPLY" >> ${LOG_FILE}
    done
}

# function echoerr() { echo "$@" 1>&2; }


################################################################
# Variables

COV=100
SRA=""
SRALONG=""
SRASHORT=""
LR3K=""
LR=""
SR1=""
SR2=""
ODIR=o
PA=""
FA=""
MR=3000
NT=2
RESUME=""
ALL_ANNOTATE="--selective-annotate"
FLYE_CONTIGGER="--contigger"
USE_EDGES="--no-use-edges"
NO_REDUCTION_READS=""
NO_COVERAGE_CHECK=""
STEP0=0
STEP1=0
STEP2=0
STEP3=0
STEP4=0
STEP5=0
STEP6=0
STEP7=0
MULTISTEP=0
# v1: 500/1000
# v2: 3000
PAIR_MIN=500     # 3k or 5k
SINGLE_MIN=3000  # 3k or 5k
BACKUP=species

################################################################
# MAIN
if [ $# -eq 0 ]; then
    usage
fi

# a log to all message
# https://stackoverflow.com/questions/49851882/how-to-log-echo-statement-with-timestamp-in-shell-script
LOG_FILE="./polap.log"
# exec 3>&1 1>> >(logit) 2>&1
exec 3>&1 1>> >(logit)

CMD="polap $*"
echo "CMD: $CMD"

# subcommand function call
if declare -f "$1" >/dev/null 2>&1; then
    # invoke that function, passing arguments through
    "$@" # same as "$1" "$2" "$3" ... for full argument list
else
    # main step option check
    if [[ -z $(getopt -T) ]]; then
        set_options "$@"
    else
        echoerr "WARNING: long options are not be available in MacOS"
        set_options0 "$@"
    fi

    if test $STEP0 -eq 1; then step0; fi
    if test $STEP1 -eq 1; then step1; fi
    if test $STEP2 -eq 1; then step2; fi
    if test $STEP3 -eq 1; then step3; fi
    if test "$STEP4" -gt 0; then step4; fi
    if test $STEP5 -eq 1; then step5; fi
    if test $STEP6 -eq 1; then step6; fi
    if test $STEP7 -eq 1; then step7; fi
fi

ELAPSED="Time: $((SECONDS / 3600))hrs $(((SECONDS / 60) % 60))min $((SECONDS % 60))sec - $CMD"
echo "$ELAPSED"
